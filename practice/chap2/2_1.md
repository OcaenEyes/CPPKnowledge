<!--
 * @Author: OCEAN.GZY
 * @Date: 2022-08-10 21:28:01
 * @LastEditors: OCEAN.GZY
 * @LastEditTime: 2022-08-10 23:45:56
 * @FilePath: \ocean-books\C++实战100天\chap2\2_1.md
 * @Description: 注释信息
-->
# 实现原理

在C/C++的编程中，内存管理一直是一个盛产BUG的重灾区。C/C++内存管理严格要求编码人员在编码的过程中，申请出来的内存资源必须要记得归还；归还内存资源时必须要确保没有任何模块正在使用该内存。

这真是很令人头疼的问题啊：

第一，依赖于人要记得做的事，人总是有可能会忘记去做；

第二，就算在某个模块的实现中，实现者确实做了所有TA该记得做的事，但谁又能保证，后续该模块的维护者也能够有如此好的记性呢；

第三，当一个项目中模块多而关系复杂的时候，一个内存资源有可能被多个模块共同使用着，这时确定何时才能安全的释放内存资源，将是一个很困难的问题。

基于以上种种，很多基于C++的大型项目中，都会去实现一种称为智能指针的类，如android项目的轻量级指针类sp，C++STL里也有智能指针auto_ptr。

所谓的智能指针，首先它是一个指针，所以能指向内存资源；然后它区别于一般的指针，它是智能的，而所谓的智能是指它：1.能够自动的帮你释放内存，2.还能够知道什么时候释放内存才是安全的。
C++中智能指针的实现主要依赖于两个技术概念：

1. 析构函数，对象被销毁时会被调用的一个函数，对于基于栈的对象而言，如果对象离开其作用域则对象会被自动销毁，而此时析构函数也自动会被调用。
2. 引用计数技术，维护一个计数器用于追踪资源(如内存)的被引用数，当资源被引用时，计数器值加1，当资源被解引用时，计算器值减1。
3. 操作符重载。

智能指针的大致实现原理就是在析构函数中，检查所引用对象的引用计数，如果引用计数为0，则真正释放该对象内存。
详细的实现原理，我们在实验的过程中慢慢去理解。