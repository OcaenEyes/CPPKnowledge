{"./":{"url":"./","title":"关于作者","keywords":"","body":"C++知识积累 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 14:40:48 "},"practice/summary.html":{"url":"practice/summary.html","title":"C++从入门到实战","keywords":"","body":"从入门到实战，一些经典有趣的实战案例 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:28:48 "},"practice/chap1/summary.html":{"url":"practice/chap1/summary.html","title":"基础知识","keywords":"","body":" Part 1 基础知识 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:37:47 "},"practice/chap1/c++语言概述.html":{"url":"practice/chap1/c++语言概述.html","title":"C++语言概述","keywords":"","body":" C++语言概述 C++ 语言的产生 C 语言最初是贝尔实验室的 Dennis Ritchie 在 B 语言的基础上开发出来的。C 语言具有运算符和数据结构丰富、语言简洁灵活、程序执行效率高等系列优点，被市场广泛应用。但 C 语言终究是面向过程的编程语言，与其他面向过程的编程语言一样，无法满足运用面向对象方法的开发需求。 而 C++ 语言便是在优化 C 语言的基础上为支持面向对象的程序设计而研制的一个通用目的的程序设计语言。在后来的持续研究中，C++ 增加了许多新概念，例如虚函数、重载、继承、标准模板库、异常处理、命名空间等。 C++ 语言的特点 C++ 语言的特点主要表现在两个方面： 全面兼容 C 语言 和 支持面向对象的方法。 由于 C++ 可以全面兼容 C，这就使得部分由 C 语言编写的代码在未经修改的情况下就可以为 C++ 所用，这极大的促进了 C++ 的普及和面向对象技术的广泛应用。 C++ 最具有意义的一面就是支持面向对象的方法。与 C 兼容的特点虽赋予 C++ 双重特点，但 C 和 C++ 在概念上却是两种完全不同的程序设计语言，所以在 C++ 中应注意按照面向对象的思维去编写代码。 此外，C++ 在保持 C 简洁、高效等特点的基础上，对 C 的类型系统进行改革和扩充，因此 C++ 编译环境能检测出的类型错误更多。 C++的扩展名和注释符 扩展名 C++ 源文件的扩展名与运行的具体编译器有关，一般有 .cc、.cxx、.cpp 和 .cp。与源文件相关的头文件扩展名一般是 .h。课程实验环境中的源文件扩展名一般为 .cpp，与之相关的头文件扩展名一般为 .h。 注释符 与其他语言类似，C++ 也有为代码提供辅助信息的注释符。 单行注释：//注释内容 int x;//定义 x 的数据类型为 int 块注释：/ 注释内容 / if(x>y)return x; else return y; /* 如果 x 大于 y 则返回 x 否则返回 y */ 注释符可以放置在代码的任何位置，且不参与代码运行。 命名空间 命名空间里面包含了逻辑结构上相互关联的一组类、函数、模板等。命名空间像是一个容器，把某些在逻辑结构上相关的 “ 对象 ” 放在一起并与外界区分。特别的，命名空间里的变量名或类名可以和命名空间外的变量名或类名重名。 使用命名空间的时候，我们可以用 花括号 把声明块括起来，再以关键字 namespace 开头并命名，其基本格式如下： namespace 命名空间的名字 { 声明块 } 其中声明块中可以包含变量、类、函数等。例如： namespace S { int x; void FunA() { ... } } 在命名空间外使用命名空间内的成员： 命名空间的名字加上作用域运算符 :: 。 参考上例 namespace S，若访问 x，可写成 S::x；访问 FunA() 则为 S::FunA()。 命名空间的嵌套， 具有分层屏蔽的作用。例如： namespace S1 { namespace S2 { int x; void FunA() { ... } } } 若要访问 x，则可写为 S1::S2::x，同理，访问 FunA() 则可写为 S1::S2::FunA()。 using 声明：若命名空间内的某个成员使用了 using 声明，那么这个成员在程序的后续使用中，可直接使用成员名，无需添加限定修饰名。使用 using 声明： 以关键字 using 开头后跟命名空间内的成员名。参考上例嵌套的命名空间： namespace S2 中 int x 的 using 声明为：using S1::S2::x; 。 注意： using namespace 后不能加类名或变量名。同上，若 namespace S2 中 int x 的 using 声明写为 using namespace S1::S2::x 便是错误的。 using 指示符可以一次性地使命名空间内的全体成员被直接使用。using 指示符的使用： 以关键字 using namespace 开头后跟命名空间名字。特别的，std 命名空间声明和定义了标准 C++ 库中的所有组件，使用 using namespace std; 则可使用标准 C++ 库中的所有成员。 C++语言的输入输出 C++ 标准 I/O 库包含 iostream、fstream 和 sstringstream。iostream、fstream 比较常用，一般操作于输入和输出，相较于前两者来说 sstringstream 的出现频率就低了许多，一般操作于数据的格式化。为了能更好的理解 C++ 语言的标准 I/O 库，我们参考 cplusplus 官网 的相关内容，整理注释了一份关于输入输出流类继承体系的关系图 标准输出流对象 cout 预定义的插入符 “ cout 在输出语句中，若串联多个插入符，则可输出多个数据项。例如： cout 则依次输出 a,b,c 三个数据项的值。 若插入符后面是复杂的表达式，则系统自动计算其表达式的值并传给插入符。例如： cout 依次输出字符串 “ a+b= ” 以及 a+b 的计算结果。 标准输入流对象 cin 预定义的提取符 “ >> ” 作用在流类对象 cin 上可实现对键盘输入的提取操作，其格式为： cin >> 表达式1 >> 表达式2... 其中表达式通常用于存放输入值的变量。例如： int a,b; cin >> a >> b; 即编译执行后，输入 a 和 b 的值，a 和 b 之间使用空格分隔。如输入：1 2，则给 a 赋值为 1，b 赋值为 2。 简单的 I/O 格式控制 一般情况下，使用 cin 和 cout 进行数据的输入和输出时，会自动按照默认的格式进行处理。如若需要设定特殊的格式，可利用 C++ I/O 流类库提供的操纵符进行调整。这些操纵符可直接嵌入到输入输出语句中实现格式控制。常用的 I/O 流类库操纵符： 操纵符名 含义 dec 数值数据采用十进制表示 hex 数值数据采用十六进制表示 oct 数值数据采用八进制表示 ws 提取空白符 endl 插入换行符，并刷新流 ends 插入空字符 setsprecision ( int ) 设置浮点数的小数位数，包括小数点 setw ( int ) 设置域宽 编译运行 GCC 和 G++ 是由 GNU 开发的编程语言编译器，其中 GCC 用来编译 C 语言程序；G++ 用来编译 C++ 语言程序。 g++ -o 的功能：生成可执行文件，其基本格式为: g++ 需生成可执行文件的源文件名 -o 可执行文件名称 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/基本数据类型.html":{"url":"practice/chap1/基本数据类型.html","title":"基本数据类型","keywords":"","body":" 基本数据类型 编写计算机程序的目的在于高效解决现实生活中的问题，正因如此，高级语言为我们提供了许多的数据类型。C++ 的数据类型分为基本数据类型和自定义数据类型，其基本数据类型如下： 数据类型名 长度（字节） 取值范围 char 1 -128 ~ 127 或 0 ~ 255 bool |1 |true, false signed char |1 |-128 ~ 127 unsigned char |1 |0 ~ 255 short |2 |-32768 ~ 32767 unsigned short |2 |0 ~ 65535 int |4 |-2147483648 到 2147483647 unsigned int |4 |0 ~ 4294967295 long |8 |-9223372036854775808 到 9223372036854775807 unsigned long |8 |0 到 18,446,744,073,709,551,615 float |4 |3.4E-38 ~ 3.4E+38 double |8 |1.7E-308 ~ 1.7E+308 long double |16 |长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 各种类型的存储大小和具体操作系统的位数有关，目前大部分系统为 64 位，与上表基本一致。 由上表可知，C++ 的基本数据类型一般包括：bool、char、int、float 和 double。其中关键字 signed、unsigned、short、long 被称为修饰符。特别的，当用 short 或 long 修饰 int 时，int 可省略不写，表示短整型数据或长整型数据。 string 类 string 是 C++ 标准库的一个重要部分，主要用于字符串的处理，string 类的头文件为：#include。使用 string 可以对字符串的对象执行某些操作，例如拼接、查找等。 此课程属性为基础入门，所以暂不对 string 类进行过多介绍。若想要深度了解或学习 string 类的相关知识，可在本次实验后继续学习 C++ 进阶应用实战 - 初识类与对象。 struct struct 是由一系列相同或不同的数据类型组成的数据集合，也称结构体，是一种复合型的数据类型。 C++ 语言中 struct 的基本结构 struct struct_name { memberList }varList 其中 struct 为结构体的关键字，struct_name 为结构体的名字，memberList 为结构体成员变量及成员函数的列表，varList 为结构体声明的变量。使用 varList.元素名 可调用结构体中的元素。 例如在实验环境中新建一个名为 stru.cpp 的文件并输入： #include using namespace std; struct shiyanlou //定义 shiyanlou 结构体。 { int a; //定义 a 的数据类型为整型。 int pri() {return a;}//定义 pri() 的功能为返回 a 的值。 }s1; int main() { cout其中 sbefore 输出未初始化变量的结果，safter 输出已初始化变量的结果： C++ 语言中 struct 与 C 语言中 struct 的区别 在 C++ 语言中，可直接使用结构体名来声明变量；在 C 语言中，不能直接使用结构体名来声明变量，需前缀 struct。 C++ 语言的 struct 中既可以定义成员变量又可以定义成员函数；C 语言的 struct 中只能定义成员变量，不能定义成员函数。例如： struct shiyanlou { int a; int pri() {return a;} }s1; 在 C++ 的编译过程中，此结构体不会出错。但若在 C 语言中，由于 int pri() {return a;} 为成员函数，会出现编译报错。 变量 变量来源于数学，是计算机语言中能储存计算结果且在程序执行过程中可以变化的量。变量需要用名字来标识且需指定相应的数据类型，变量声明的形式如下： 数据类型 变量名1，变量名2... 注意：变量的命名不是随意的，需遵守以下规则： 变量名只能包含字母（A-Z，a-z）和数字（0-9）或者下划线（_）。 变量名首位必须是字母或下划线。 不能使用 C++ 的关键字来命名变量，以免冲突。例如：struct。 变量名区分大小写。 例如声明两个 int 类型的变量：int a_1,b 变量分为局部变量与全局变量。由某对象或某个函数所创建的变量通常都是局部变量，只能被内部引用，而无法被其它对象或函数引用，全局变量是可以被本程序所有对象或函数引用。 局部变量 局部变量 只作用于当前模块。例如新建一个名为 localvar.cpp 的文件并输入： #include using namespace std; int main() { int a = 2; //此局部变量只作用于当前模块。 cout在主函数 int main() 中定义了一个局部变量 a 且赋值为 2，若在主函数中对局部变量 a 进行输出，则直接输出 2。 全局变量 当两个或两个以上模块或函数需要用到同一个变量时，可以把变量定义为 全局变量。例如新建一个名为 globalvar.cpp 的文件并输入： #include using namespace std; int global1 = 1; //定义全局变量 global1。 void func() { cout上述代码中，void func() 和 int main() 都需要使用变量 global1，即定义其为全局变量，供多个模块使用。 重名现象 当全局变量与局部变量重名的时候，起作用的是局部变量，全局变量被屏蔽掉。我们修改 globalvar.cpp 文件为以下内容： #include using namespace std; int global1 = 1; //定义全局变量 global1。 void func() { cout我们在 int main() 中定义局部变量 int global1，此时出现重名现象。则 int main() 中 cout 常量 常量是指具有固定值的表达式，其值在程序运行的整个过程中是不可改变的。常量一般分为整型常量、实型常量、字符常量、字符串常量和布尔常量。 整型常量 即以文字形式出现的整数，包括正整数、负整数和零。在 C++ 中支持十进制、八进制和十六进制的整数。 十进制表示的整型常量：由 - / + 和 若干 0 - 9 的数字组合，例如：2、- 2、356 等。 八进制表示的整型常量:以 0 开头后跟若干个 0 - 7 数字，例如：0333、06 等。 十六进制表示的整型常量：以 0x 开头后跟 0 - 9 的数字及 A-F 的字母，例如：0x12、0x3A 等。 一般的，当十进制表示的整型常量为正整数时，可省略 +；八进制和十六进制通常表示无符号的整数，所以不必添加 - / +。 实型常量 即以文字形式出现的实数，包括一般形式和指数形式。 一般形式，即正常表达的数字，例如：3.14、- 6.78 等。 指数形式，通俗来说就是我们在数学中常用的 n 乘以 10 的 x 次方，例如：3.1E+6 表示的则是 3.1 乘以 10 的 6 次方，即 3100000；6.9E-2 表示的则是 6.9 乘以 10 的 - 2 次方，即 0.069。 字符常量 用单引号括起来的一个字符称为字符常量。例如：'a'、'D' 等。 例如回车、换行、制表符等既无法显示又不能输入的特殊字符，需要利用 C++ 预定义的转义序列在程序中表示。下面是常用的预定义的转义序列表： 字符常量形式 含义 \\n |换行 \\r |回车 \\t |水平制表符 \\v |垂直制表符 \\a |响铃 \\f |换页 \\ |字符 '\\' \\\" |双引号 \\' |单引号 例如：input：\\n 则在输出字符串 'input：'后执行换行操作。 字符串常量 用双引号括起来的字符序列称为字符串常量。例如：\"shiyanlou\"、\"an apple\" 等。 若要在字符序列中包含双引号，例如表示语句：You choose \"time\" or \"happy\"，我们则需利用预定义的转义序列 \\\" 来表示句中的双引号。定义其字符串常量为：\"You choose \\\"time\\\" or \\\"happy\\\"\"。 布尔常量 布尔常量只有 TRUE 和 FALSE 两种。 常量声明 常量声明一般有两种方式，一是使用 #define 预处理、二是使用 const 关键字。 使用 #define 预处理 格式：#define name value #define PI 3.14159 #define NEWLINE '\\n' 使用 const 关键字 格式：const type name = value const double pi = 3.14; const char tab = '\\t'; 运算符和表达式 表达式是运算符及其运算数的序列，它指定一项计算。一般分为算数运算符和算数表达式、逻辑运算符和逻辑表达式、关系运算符和关系表达式、条件运算符和条件表达式。 算数运算符和算数表达式 算数运算符包括基本算数运算符和自增自减运算符；算数表达式一般由算数运算符、操作数和括号组成。下面是基本的算数运算符和算数表达式： 运算符名 语法 描述 表达式 一元加 |+a |正号 |+a = 6 一元减 |-a |负号 |-a = -6 加 |a + b |两数相加 |a + b = 6 减 |a - b |两数相减 |a - b = 6 乘 |a b |两数相乘 |a b = 8 除 |a / b |两数相除 |a / b = 8 模 |a % b |两数整除后取余 |a % b = 3 自增 |a++ 或 ++a |整数本身加一 |a++ = 6 或 ++a = 6 自减 |a-- 或 --a |整数本身减一 |a-- = 6 或 --a = 6 a++ 和 ++a 的区别：++a 称为前缀形式，在表达式计算之前完成自加运算；a++ 称为后缀形式，在表达式计算之后完成自加运算。同理，--a 和 a-- 亦如此，--a 在表达式计算之前完成自减运算；a-- 在表达式计算之后完成自减运算。例如新建 self.cpp 文档，输入： #include using namespace std; int main() { int i=1; cout其中 cout 逻辑运算符和逻辑表达式 逻辑表达式是通过逻辑运算符将操作数或等式进行逻辑判断的语句。在下面基本的逻辑运算符和逻辑表达式中，我们假设布尔变量 a 为 TRUE，b 为 FALSE： 运算符 运算符名 描述 表达式及结果 && |与 |当且仅当所有操作数都为 TRUE，表达式才为 TRUE |(a && b) 为 FALSE || |或 |任一操作数为 TRUE，表达式为 TRUE |(a || b) 为 TRUE ! |非 |取反。若操作数为 TRUE，表达式为 FALSE；若操作数为 FALSE，表达式为 TRUE |(!b) 为 TRUE 关系运算符和关系表达式 关系表达式最终产生的是一个布尔结果，它使用关系运算符判断操作数值之间的关系。若关系正确，则结果为 TRUE，若关系错误，则结果为 FALSE。在下面基本的关系运算符和关系表达式中，我们假设 a 为 3，b 为 4： 运算符 |运算符名 |描述 |表达式及结果 |-|-|-|-| == |等于 |判断两个操作数的值是否相等，如果相等则结果为 TRUE |(a == b) 为 FALSE != |不等于 |判断两个操作数的值是否相等，如果不等则结果为 TRUE |(a != b) 为 TRUE |大于 |判断左操作数的值是否大于右操作数的值，如果是那么结果为 TRUE |(a > b) 为 FALSE = |大于等于 |判断左操作数的值是否大于或等于右操作数的值，如果是那么结果为 TRUE |(a >= b) 为 FALSE 条件运算符和条件表达式 在 C++ 中条件运算符 ? 是三元运算符，其表达式为： 条件表达式 ? 表达式1 : 表达式2 如果条件表达式的值为 TRUE ，则返回 表达式1 的值，否则返回 表达式2 的值。 例如新建 condition.cpp 文件，输入： #include using namespace std; int main() { int a = 5; int b = 3; int c; c=(a>b)? a : b; //如果a大于b则返回a，否则返回b coutc 用于接收三元运算符的返回值，又因为 a>b 的布尔值为 TRUE，所以返回 a 的值。 拓展 sizeof 运算符 用于计算 对象 类型或 表达式结果 类型在内存中所占的字节数，其形式为：sizeof (对象类型名) 或 sizeof(表达式)。 在 C++ 中逗号也是一个运算符，称为 逗号运算符，其形式为：表达式1,表达式2。定义了从左到右的求解顺序，例如 a = 1,a + 1 其值为 2。 C++ 中最简单的赋值运算符是 '='。例如 a = (x=4) / (y=2) 表达的则是 x 赋值为 4，y 赋值为 2，a 赋值为 4 / 2，即 2。除了 =，C++ 中还有一些其他比较常用的赋值运算符： 运算符 运算符名 实例 等价于 += |加赋值 |i += 5 |i = i + 5 -= |减赋值 |i -= 5 |i = i - 5 = |乘赋值 |i = 5 |i = i * 5 /= |除赋值 |i /= 5 |i = i / 5 %= |求余赋值 |i %= 5 |i = i % 5 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/内存分配.html":{"url":"practice/chap1/内存分配.html","title":"内存分配","keywords":"","body":" 内存分配 不同的内存分配方式，有不同的内存调度机制。C++ 语言的三种内存分配方式分别是：静态存储区分配、栈内存分配和堆内存分配。 静态存储区分配 静态分配方式下的内存在程序编译的时候就已经分配好了且存在于程序的整个运行过程。例如 static 变量，其生命周期随程序的结束而结束，而非像一般变量随函数或作用域的结束而结束。 除了 static 变量，还有一种全局对象 static object，也可以存放在静态存储区。 栈内存分配 栈内存分配方式下的内存是存在于某作用域的一块空间。例如调用某个函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会被自动释放。 函数内局部变量的生命周期：起于变量声明，止于函数执行结束。 堆内存分配 堆内存分配，也称 动态内存分配，通常使用 new 和 delete 关键字进行管理。堆内存空间可由用户手动分配和释放，所以其生存周期由用户指定，较为灵活。但频繁的分配、释放大小不同的堆空间会产生内存碎片。 管理内存 C 语言中一般使用 malloc() 函数来分配内存空间，free() 函数来释放内存空间。但在 c++ 语言中我们使用 new 关键字来分配内存空间，delete 关键字来释放内存空间。后者在性能等方面优于前者。 在学习使用 new 和 delete 关键字之前我们先初步了解一下指针的概念及其一般形式。 指针是一个变量，其值是另一个变量的地址。指针变量声明的一般形式为： type *pointerVar-name 其中 type 为指针的数据类型，* 是定义指针的关键符，pointerVar-name 指定指针变量名。 例如：char *p，即定义了一个字符型指针变量 p。 指针的另一些基本内容会在后续的实验中详细介绍，本次实验对指针的内容仅做了解。现在我们正式学习 new 关键字和 delete 关键字。 new 关键字 new 关键字 用于堆内存的分配，可自动计算所要分配内存空间的大小，其基本使用形式为： 指针变量名 = new 类型 例如： int *p; //定义一个整型指针变量 p = new int; 其中 p = new int; 表示动态分配一个存放整型数据的内存空间，并将其首地址赋给整型指针变量 p，此时省略指针变量 p 前的 *。 delete 关键字 delete 关键字 用于堆内存的释放，其基本形式为： delete 指针变量 例如： int *p; //定义一个整型指针变量 p = new int; //省略指针操作过程 delete p; 其中 delete p; 表示释放指针变量 p 指向的内存空间，此时省略指针变量 p 前的 *。 注意：使用 new 获取的内存空间必须使用 delete 进行释放。 我们用实例来加深一下 new 和 delete 关键字的使用方式，新建 mans.cpp 文件，输入： #include using namespace std; int main() { int *p; //定义一个整型的指针变量 p。 p = new int; //动态分配一个存放整型数据的内存空间，并将其首地址赋给整型指针变量 p。 *p = 6; //为指针指向的内存块赋值为 6。 cout程序首先定义了整型指针变量 p，然后使用 new 关键字为其分配 int 型的内存空间，并让指针 p 指向分配的内存空间。随后为内存块赋值为 6，并且输出所赋的值。最后释放指针变量 p。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/基本控制结构.html":{"url":"practice/chap1/基本控制结构.html","title":"基本控制结构","keywords":"","body":" 基本控制结构 顺序结构 顺序结构是最简单的控制结构，也是 C++ 程序默认的执行流程。在此结构中，程序将按照书写的先后顺序自上而下依次执行。一般情况下，若程序中不包含选择结构、循环结构和跳转语句，则此程序为顺序结构。例如新建 sequence.cpp 文件，输入： #include using namespace std; int main() { int a,b; a=3; b=5; cout此程序中，语句按照从上至下的顺序依次执行：首先定义了 a 和 b 两个 int 型变量，然后给 a 赋值为 3，b 赋值为 5，最后输出 a+b 的结果。 选择结构 根据判定条件的结果，选择相应执行语句的控制结构称为选择结构。 使用条件运算符实现选择结构 利用条件运算符 ? 可以实现一个简单的选择结构，其基本形式为： 条件表达式 ? 表达式1 : 表达式2 此方式需根据条件表达式的判断结果，选择表达式 1 或者表达式 2。其具体意义是：若条件表达式的布尔值为 TRUE ，则返回 表达式1 的值，否则返回 表达式2 的值。例如新建 choose1.cpp 文件，输入： #include using namespace std; int main () { int x,y=7; //声明局部变量 x 和 y 并给 y 赋值为 7。 x=(y程序中 x=(y 使用 if 语句实现选择结构 if 是典型的用于实现选择结构的语句，例如 if(X==1) i++; 当满足条件 X==1 时，执行语句 i++。if 语句一般分为简单的 if...else 语句、嵌套的 if 语句和 if...else if 语句三类。 简单的 if...else 语句 的基本结构为： if(判定条件){ 判定条件为 TRUE 时的执行语句 } else{ 判定条件为 FALSE 时的执行语句 } 和使用条件运算符实现选择结构的方式类似。首先进入判定条件，若判定条件的布尔值为 TRUE 则执行 if 花括号内的语句，不执行 else 花括号内的语句；若判定条件的布尔值为 FALSE 则执行 else 花括号内的语句，不执行 if 花括号内的语句。例如新建 choose2.cpp 文件，输入： #include using namespace std; int main () { int x,y=7; //声明局部变量 x 和 y 并给 y 赋值为 7。 if(y因为 y = 7 即 y 嵌套的 if 语句 的基本结构为： if(判定条件 1){ if(判定条件 2){ 判定条件 1 和判定条件 2 均为 TRUE 时的执行语句 } else{ 判定条件 1 为 TRUE 且判定条件 2 为 FALSE 时的执行语句 } } else{ if(判定条件 3){ 判定条件 1 为 FALSE 且判定条件 3 为 TRUE 时的执行语句 } else{ 判定条件 1 和判定条件 3 均为 FALSE 时的执行语句 } } 嵌套的 if 语句只是把简单的 if...else 语句中的执行语句换成了 if...else 语句。当判定条件 1 的布尔值为 TRUE 时，进入判定条件 2；当判定条件 1 的布尔值为 FALSE 时，进入判定条件 3。例如新建 choose3.cpp 文件，输入： #include using namespace std; int main () { int x;//声明局部变量 x。 int y=7; //声明局部变量 y 且赋值为 7。 int z=3;//声明局部变量 z 且赋值为 3。 if(y2){ // 判定 z 是否大于 2。 x=2; //判定条件 z>2 为 TRUE 时。 } else{ x=3; //判定条件 z>2 为 FALSE 时。 } } cout因为 y = 7 即 y 2 的布尔值为 TRUE，所以 x 输出 2。 if...else if 语句 的基本结构为： if(判定条件1){ 满足判定条件 1 时执行的语句 } else if(判定条件2){ 满足判定条件 2 时执行的语句 } else{ 既不满足判定条件 1，也不满足判定条件 2 时的执行语句 } 注意：嵌套 if 语句的判定条件可针对不同对象进行判定，例如上例，先判定条件 y2。而 if...else if 语句只能针对同一对象进行判定，例如新建 choose4.cpp 文件，输入： #include using namespace std; int main () { int x,y=7; //声明局部变量 x 和 y 并给 y 赋值为 7。 if(y>8){ //判定 y 是否大于 8。 x=1; //当 y>8 时 x = 1。 } else if(y>5){ x=2; //当 y>5 时 x = 2。 } else{ x=3; //若既不满足 y>8，也不满足 y>5 时，x = 3。 } cout因为 y=7 不满足 y>8 而满足 y>5，所以 x 的值为 2。 使用 switch 语句实现选择结构 switch 语句比较特殊，其目的是检查常量表达式中的值，其基本结构为： switch(表达式){ case 值1: 代码块1 break; case 值2: 代码块2 break; ... default: 默认执行的代码块 } 当 switch 表达式的值和 case 语句选择的值相同时，从此 case 位置开始向下执行，直到遇到 break 语句或 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的默认代码。例如新建 choose5.cpp 文件，输入： #include using namespace std; int main () { cout>ch; //从键盘输入 ch 的值。 switch(ch){ case 'w': //键入 w 时。 cout键入 w 输出文本 \"上\" 并跳出 switch 语句；键入 s 输出文本 \"下\" 并跳出 switch 语句；键入 a 输出文本 \"左\" 并跳出 switch 语句；键入 d 输出文本 \"右\" 并跳出 switch 语句；键入非 a/s/d/w 中的字符，则输出提示信息 \"输入错误！\"。 循环结构 允许多次执行某一条语句或某个语句组的控制结构称为循环语句，在 C++ 中有 while 语句、do...while 语句、for 语句三种循环控制语句。 使用 while 语句实现循环结构 while 语句的执行过程是先判断，再执行。其基本结构为： while(条件){ 代码块 } while的语句流程 执行 while 语句时，首先判断 while 后面的条件是否成立( TRUE or FALSE )。若成立，则执行循环内的代码，直到条件不成立；若不成立，则执行 while 语句后的其他语句。例如新建 circle1.cpp 文件，输入： #include using namespace std; int main() { int sub = 0; //定义变量 sub 并赋值为 0。 int i = 1; //定义变量 i 并赋值为 1。 while(i在此程序中，sub 的初始值为 0，i 的初始值为 1。执行到 while 语句时，i 第一次循环：sub=0+1=1；执行 i++ 语句后的 i 值为 2，i 第二次循环：sub=0+1+2=3；执行 i++ 语句后的 i 值为 3，i 第三次循环：sub=0+1+2+3=6；执行 i++ 语句后的 i 值为 4，i 第四次循环：sub=0+1+2+3+4=10；执行 i++ 语句后的 i 值为 5，i 最后输出 sub 的值为 10。 使用 do...while 语句实现循环结构 do...while 语句的执行过程是先执行，再判断。其基本结构为： do{ 代码块 }while(条件); do...while的流程 执行 do...while 语句时，先执行一次循环体内的语句，然后再判断循环条件是否成立。如果条件成立，则继续执行，直到循环条件不成立；若条件不成立，执行 while 语句后的其他语句。例如新建 circle2.cpp 文件，输入： #include using namespace std; int main() { int sub = 0; //定义变量 sub 并赋值为 0。 int i = 1; //定义变量 i 并赋值为 1。 do{ sub += i; //执行 sub = sub + i。 i++; //i 累加 1 }while(i在此程序中，sub 的初始值为 0，i 的初始值为 1。执行到 do...while 语句时，直接进入循环体执行。 第一次循环：sub=0+1=1；执行 i++ 语句后的 i 值为 2。 i i i i 最后输出 sub 的值为 10。 使用 for 语句实现循环结构 for 语句允许指定循环的增量。其基本结构为： for(循环变量初始化;循环条件;循环增量) { 代码块 } for的流程 使用 for 语句实现循环结构的第一步就是初始化循环变量，然后判定循环条件，如果布尔值为 TRUE 则执行代码块中的语句，直到条件判定的布尔值为 FALSE 时终止循环；否则，循环结束。例如新建 circle3.cpp 文件，输入： #include using namespace std; int main() { int sub = 0; //定义变量 sub 并赋值为 0。 int i; //定义变量 i。 for(i=1;i执行 for 语句。设定 i 的初始值为 1，判定条件为 i i 执行第二次循环：sub=0+1+2=3；返回到循环增量处，执行 i++ 语句，此时 i=3，i 执行第三次循环：sub=0+1+2+3=6；返回到循环增量处，执行 i++ 语句，此时 i=4，i 执行第四次循环：sub=0+1+2+3+4=10；返回到循环增量处，执行 i++ 语句，此时 i=5，i 最后输出 sub 的值为 10。 拓展 与 if 嵌套语句类似，循环结构也可以进行 循环嵌套。循环结构为： for 嵌套 for(循环变量初始化1; 循环条件1; 循环增量1) { for(循环变量初始化2; 循环条件2; 循环增量2){ 代码块2 } 代码块1 } copy while 嵌套 while(条件1){ while(条件2){ 代码块2 } 代码块1 } do-while 循环 do{ 代码块1 do{ 代码块2 }while(条件2); }while(条件1); 注意：尽量避免设计层次过多的循环嵌套。 循环结构和选择结构可以互相嵌套，例如在 for 语句中嵌套 if 语句： for(循环变量初始化;循环条件;循环增量) { ... if(判定条件){ 判定条件为 TRUE 时的执行语句 } else{ 判定条件为 FALSE 时的执行语句 } } 判定条件永恒为 TRUE 的循环称为 死循环。例如： int i=1 while(i==1){ cout由于判定条件 i==1 的布尔值永恒为 TRUE，所以程序将无限循环输出字符串 \"1\"。值得注意的是，程序中应不含死循环，除非有特殊需求。 其他控制语句 continue 与 break 语句的区别 continue：结束本次循环，所在循环体并未结束。 例如新建 other.cpp 文件，输入： #include using namespace std; int main(){ int i; for (i=0;i循环至 i=3 时，满足条件 i==3 执行 continue 语句：直接跳出 本次循环 且不执行循环体内 continue 后的其他语句。随后再次执行循环增量 i++ 语句，判定循环条件，执行循环体。 break：结束整个循环体，所在循环体已结束。 将 other.cpp 文件中的 continue 修改为 break，如下： #include using namespace std; int main(){ int i; for (i=0;i循环至 i=3 时，满足条件 i==3 执行 break 语句，直接退出 for 循环，结果只输出数字 3 前面的数字 0 1 2。 goto 语句的使用 goto 语句允许把控制无条件转移到同一函数内的标记语句。但在任何的编程语言中，都不建议使用 goto 语句，因为它使得程序的控制流难以跟踪。 goto 语句的语法： goto label; ... label: statement; 当执行 goto label; 语句时，直接跳转并执行 label 标记的语句。例如新建 gtacc.cpp 文件，输入： #include using namespace std; int main(){ int i=3; if (i==3){ goto acc; } else{ cout因为 if 语句中判定条件 i==3 的布尔值为 TRUE ，所以执行语句 goto acc; 后直接跳转到语句 cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/函数的定义与使用.html":{"url":"practice/chap1/函数的定义与使用.html","title":"函数的定义与使用","keywords":"","body":" 函数的定义和使用 C++ 中的函数分为 C++ 标准库函数和自定义函数。使用标准库函数需要包含特定的头文件，比如使用 vector 功能时，需包含头文件 #include。而自定义函数是用户自定义命名和声明的一组语句，其基本结构为： type name(parameter list){ code } 其中 type 为函数的返回值类型；name 为函数的名称，也是调用函数所使用的标识符；parameter list 为传递给函数的参数列表；code 为函数的主体，存放函数需要执行的语句。例如我们定义一个 add 函数： int add(int a,int b){ return a + b; } add 函数的功能是利用 return 关键字返回 a 加 b 的和。 函数的声明与调用 函数的声明 如果希望在定义函数前调用函数，则需要在调用函数前声明函数，其结构为： type name(parameter list); 其中 type 为函数的返回值类型；name 为函数的名称；parameter list 为传递给函数的参数列表。例如上例的 add 函数，如果要在定义 add 函数前调用 add 函数，则需要在调用此函数前，对函数进行声明： int add(int a,int b); //函数声明。 int main(){ 调用 add 函数 //在未定义函数前调用函数。 } int add(int a,int b){ return a + b; } //定义函数 函数的调用 调用函数时，需暂停主调函数的执行，转入执行被调函数，当被调函数执行至 return 语句或函数末尾时，被调函数执行完毕，转回执行主调函数。可按如下格式调用函数： 函数名(实参列表) 注意：实参列表应与函数原型的参数个数及参数类型一致。 新建 addhs.cpp 文件，输入： #include using namespace std; int add(int a,int b); //函数声明。 int main() { int x,y; cout>x>>y; //通过输入的方式给 x y 赋值。 int c=add(x,y);//在未定义函数前调用函数。将函数的返回结果赋给变量 c。 cout执行语句 int c=add(a,b) 时，暂停执行 int main() 函数，转入执行 add 函数。把用户输入的 x、y 值传给 add 函数的变量 a、b，最后将语句 return a + b; 的结果赋给变量 c。 参数传递 在定义函数时，参数是没有实际值的，只起一个占位作用，所以称为形式参数，简称 \"形参\"；在调用函数时，参数必须有一个确定的值，是真正能对结果起作用的因素，所以称为实际参数，简称 \"实参\"。函数的 参数传递 指的是形参与实参结合的过程，其基本方式包括值传递和引用传递两种。 注意：形式参数的本质和局部变量相似，在进入函数的时候创建，退出函数的时候销毁。 值传递 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。例如新建 swapxy.cpp，输入： #include using namespace std; void swap(int a,int b){ //定义空函数 swap，用于交换 a 和 b 的值。 int t=a; //定义中间变量 t，并将 a 的值赋给变量 t。 a=b; //将 b 的值赋给 a。 b=t; //将 t 的值赋给 b，又因为 t=a，所以把 a 的值赋给 b。 } int main(){ int x=3; int y=4; cout主函数中第一句 cout 引用传递 使用引用传递，需要在定义函数时，在参数前加上符号 &，该方法把参数的引用复制给形式参数，修改形式参数会影响实际参数。例如修改 swapxy.cpp 文件为以下内容： #include using namespace std; void swap(int &a,int &b){ //定义空函数 swap，用于交换 a 和 b 的值。 int t=a; //定义中间变量 t，并将 a 的值赋给变量 t。 a=b; //将 b 的值赋给 a。 b=t; //将 t 的值赋给 b，又因为 t=a，所以把 a 的值赋给 b。 } int main(){ int x=3; int y=4; cout函数 swap 的形参属于引用类型，所以修改形参将影响实参。 拓展 默认参数 在 C++ 中，函数可定义具有默认值的参数，即 默认参数。当调用函数时，如果用户指定了参数值，则使用用户指定的值；如果参数值缺省，则使用默认参数。例如新建 defaultcs.cpp，输入： #include using namespace std; int add(int a,int b = 5){//变量 b 的值默认为 5。 return a + b; } int main() { int a,b; cout>a>>b; coutadd(a) 的返回结果为：输入的 a 值与默认 b 值之和。 add(a,b) 的返回结果为：输入的 a 值与输入的 b 值之和。 函数重载 函数重载 指定义一个参数类型或参数个数不同的重名函数。当程序执行时，编译器将调用参数类型与函数形参类型一致的函数。例如新建 renamehs.cpp，输入： #include using namespace std; int add(int a,int b){ //定义整型函数 add。 int c; c = a - b; return c; } double add(double a,double b){ //定义双精度型函数 add。 double c; c = a + b; return c; } int main() {//函数重载。 cout执行 add(3,4) 时，调用 int add(int a,int b) 函数。 执行 add(3.111,4.222) 时，调用 double add(double a,double b) 函数。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/类和对象.html":{"url":"practice/chap1/类和对象.html","title":"类和对象","keywords":"","body":" 类和对象 面向对象程序设计的基本特点包括：抽象、封装、继承、多态。 抽象 抽象是指对具体问题或对象进行概括，抽出其公共性质并加以描述的过程。一般情况抽象分为数据抽象和行为抽象，其中数据抽象是指一个对象区别于另一个对象的特征，行为抽象是指某类对象的共同特征。 封装 封装是指将抽象得到的数据和行为相结合，隐藏对象属性和实现细节且仅对外提供公共访问方式的过程。 继承 继承是指通过代码复用在保持原有类特性的基础上对子类进行具体说明的过程，通俗来说继承就是精简重复代码的手段。 多态 多态是指一段程序能够处理多种类型对象的能力，函数重载就是实现多态的一种手段。在 C++ 语言中多态可分为强制多态、重载多态、类型参数化多态和包含多态。 类 类是 C++ 语言支持面向对象思想的重要机制，是实现封装的基本单元。 类的定义 类一般由类名、数据成员、函数成员三部分组成，定义类的基本形式为： class 类的名称 { public： 外部接口 protected： 保护性成员 private： 私有成员 } 其中 public、protected、private 表示访问控制属性，用于控制类成员的访问权限。特别的，没有分配控制属性的默认为 private 私有成员。 类成员访问控制 使用 public 关键字声明的公有成员可在类外访问，即公有类型成员定义了外部接口。例如新建 pubtest.cpp 文件，输入： #include using namespace std; class area //定义 area 类。 { public: //定义公有成员，外部可以访问。 double width; double length; }; int main() { area area1; //定义对象 area1。 double AREA; //定义双精度型变量 AREA。 area1.width=3; //外部访问公有成员，设置宽为 3。 area1.length=3.1; //外部访问公有成员，设置长为 3.1。 AREA=area1.width*area1.length; //计算面积。 cout 此程序可以分为相对独立的两个部分，一是对 area 类的定义，二是主函数 main()。area 类定义了两个双精度型的公有成员，主函数访问类的公有成员实现数字相乘。 使用 protected 关键字声明的受保护成员可在子类中访问。例如新建 protest.cpp 文件，输入： #include using namespace std; class area //定义 area 类。 { protected://定义受保护的成员。 double width; }; class squarearea:area //定义 squarearea 子类。 { public: //定义公有成员。 void setsquarewidth(double wid); //定义成员函数。 double getsquarewidth(void); }; //定义子类的成员函数。 void squarearea::setsquarewidth(double wid) { width=wid; //通过 squarearea 子类访问 area 类中受保护的成员 width。 } double squarearea::getsquarewidth(void) { return width; } //程序的主函数 。 int main() { squarearea square; //定义对象。 square.setsquarewidth(3.1); //设置宽度为 3.1。 cout 此程序可以分为相对独立的三个部分，一是对 area 类的定义，二是对 squarearea 子类及子类函数的定义，三是主函数 main()。对于 area 类中受保护的成员 width 可以通过子类进行访问。 使用 private 关键字声明的私有成员只能被本类的成员函数访问。例如新建 pritest.cpp 文件，输入： #include using namespace std; class area { public: //定义公有成员 double length; void setwidth(double wid); double getwidth(void); private://定义私有成员 double width; }; //定义公有成员函数 void area::setwidth(double wid) { width=wid; } double area::getwidth(void) { return width; } //主函数 int main() { area len1; //定义对象 area wid1; len1.length=3.1; //访问 area 类公有成员。 cout此程序可以分为相对独立的两个部分，一是 area 类及其公有成员函数的定义，二是主函数 main()。私有成员 width 只能先被类中成员函数访问，再通过相关的公共成员函数实现外部访问。若在类外部使用 area.width=3.2; 方式访问 area 类的私有成员 width，则会报错。 对象 在 C++ 语言中，对象是某类事物的实例。其声明形式为： 类名 对象名； 例如声明 area 类的对象 square： area square； 访问对象的成员 定义了类及其对象后，则可访问对象的成员。访问 数据成员 基本形式为： 对象名.成员名 例如访问 area 类的对象 square 的数据成员 width： square.width=3.2; 访问函数成员的基本形式为： 对象名.函数名(参数表) 例如访问 area 类的对象 square 的函数成员 setwidth(double wid)： square.setwidth(3.2); 类的成员函数 成员函数描述了类的行为。成员函数在类中只用说明其函数的返回类型、名字和参数表，而函数的具体实现在类外说明，其基本形式为： class 类名 { 函数的返回类型 函数名(参数列表) } 返回值类型 类名::函数名(参数列表) //特别的，在类外说明函数的具体实现时，需要使用类名限制成员函数，其形式为：类名::函数名(参数列表)。 { 函数体 } 例如在 area 类中有成员函数 void setwidth(double wid);： class area { ... void setwidth(double wid); ... } //在类外说明函数的具体实现 void area::setwidth(double wid) { 函数体 } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/数组-字符串和指针.html":{"url":"practice/chap1/数组-字符串和指针.html","title":"数组和字符串和指针","keywords":"","body":" 数组、字符串和指针 数组 数组用于存储一系列类型相同的元素。例如定义五个类型相同的变量，可以不用定义五个变量，只需要将五个值存到一个数组中即可。 数组的声明格式： type name[elements] //一维数组的声明格式。 其中 type 为数组类型，name 为数组名，elements 表示数组长度。数组长度就是数组最多可以存放的元素个数。 声明不同类型的数组： int a[5]; //包含五个元素的 int 数组。 float a[5]; //包含五个元素的 float 数组。 char a[5]; //包含五个元素的 char 数组。 初始化数组 默认情况下，数组中所有元素的值在声明数组时是未确定的。 若要在声明数组时，将数组中的元素初始化为特定的值，可以使用 {} 实现，例如初始化数组 int a[5]： int a[5] = {1,2,3,4,5} 初始化数组时，若填充元素不完整，则剩下元素的值默认为 0。例如： int a[5] = {1,2,3} 访问数组 访问数组的表达式为： name[index] 其中 name 为数组名称，index 为元素编号。name[index] 称为数组下标。 例如定义且初始化一个数组：int a[5] = {1,2,3,4,5}。可以得到 a[0]=1,a[1]=2,a[2]=3,a[3]=4,a[4]=5。 则 a[2] 可以访问数组中的元素 3。 新建 arr1.cpp 文件，输入： #include using namespace std; int main () { int a[5] = {1,2,3,4,5}; //初始化数组。 cout多维数组 C++ 中支持多维数组，多维数组是指二维及以上的数组，其表达式为： type name[index1][index2][index3]...[indexn] 其中 index 的数量决定了数组的维度，例如 type name[index1][index2] 表示的则是一个二维数组。 二维数组 可以将二维数组看成一张二维表。定义一个二维数组 a[3][5]： 二维数组 a[3][5] 可以表示成一张三行五列的二维表，其初始化顺序为：从左到右，从上到下。 新建 arr2.cpp 文件，输入： #include using namespace std; int main () { int a[3][5] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}; //初始化数组。 coutC-style字符串 C++ 支持起源于 C 语言的 C-style 字符串。 例如定义一个可以容纳 10 个 char 型字符的数组： char ch[10]; 此数组具有存储 10 个字符的能力，但是这个容量不需要完全使用，数组也可以容纳更短的长度。 按照惯例，字符表示的字符串由特殊字符 null 结尾，其字面值可以写为 \\0。 例如在数组 char ch[10] 中存入一个 Hello 字符串：char ch[10] = \"Hello\";。 注意：null 字符不用手动添加，C++ 在编译的时候会自动添加。 cstring 在 C++ 中有大量用于操作 C-style 字符串的函数，它们集成在头文件 中。其常见的函数： 函数 作用 strcpy(s1,s2) |复制字符串 s2 到 s1 strcat(s1,s2) |将字符串 s2 连接到 s1 末尾 strlen(s) |计算字符串 s 长度 strcmp(s1,s2) |比较字符串 s1 和 s2 的长度，相同为 0；s1 s2 为 1 strchr(s1,ch) |返回一个指针，指向 s1 中字符 ch 第一次出现的位置 strstr(s1,s2) |返回一个指针，指向 s1 中字符串 s2 第一次出现的位置 新建 str1.cpp 文件，输入： #include #include using namespace std; int main() { char str1[18] = \"Hello \"; char str2[11] = \"Shiyanlou!\"; strcat(str1,str2);//连接字符串。 cout字符串 初始化字符串 初始化字符串 str1： string str1(\"Hello\"); 上述将 str1 初始化为 Hello，其等效于： string str1 = \"Hello\"; 注意：string 不需要像数组一样指定元素个数，它会自动分配内存。 新建 str2.cpp 文件，输入： #include using namespace std; int main() { string str1 = \"Hello \"; string str2 = \"Shiyanlou!\"; str1.append(str2);//连接字符串。 cout其中 str1.append(str2); 将字符串 str2 连接到 str1 末尾，输出 Hello Shiyanlou! 在 C++ 中，string 还支持常规操作符，如： ==， #include using namespace std; int main() { string str1 = \"Hello \"; string str2 = \"Shiyanlou!\"; cout对于字符串来说，常规操作符 + 的功能为 连接。 指针 指针是 C++ 从 C 中继承的重要数据类型，它提供了一种较为直接的地址操作手段，使用指针可灵活实现动态内存的分配。 指针变量的声明 指针是一种数据类型，具有指针类型的变量称为 指针变量，它用于存放内存地址。在使用指针之前，需对指针进行声明，其一般形式为： type *pointer_name; 其中 type 表示所指对象的数据类型，即说明所指内存单元存放的数据类型；* 表示声明一个指针类型的变量；pointer_name 表示指针名。 声明三个数据类型不同的指针变量： int *p; //声明 int 型的指针变量 p。 float *p1; //声明 float 型的指针变量 p1。 char *p2; //声明 char 型的指针变量 p2。 值得注意的是，指针实际存放的是内存地址，不同类型的指针变量用于指向数据类型不同的变量或常量。 C++ 中提供了两个与地址相关的运算符： 和 & 。其中 称为 指针运算符，用于获取指针所指变量的值，例如 *p 表示指针 p 所指变量的值；& 称为 取地址运算符，用于获取一个对象的地址，例如有变量 i，则 &i 表示 i 的存储地址。 指针的赋值与使用 定义指针后我们仅得到了一个用于存储地址的指针变量，若要确定指针变量存放的内存地址，可以通过给指针赋值实现。其基本形式为： 在定义指针时为指针赋值：type *pointer_name=初始地址; 在定义指针后为指针赋值：type *pointer_name; pointer_name=初始地址; 其中 初始地址 为某个对象的内存地址，一般使用 &对象名 获取。 例如将指针 p 指向变量 po1 的地址，其中变量 po1 的值为 6： int po1=6; //定义 int 型变量 po1，赋值为 6。 int *p=&po1; //指针变量 p 指向变量 po1 的地址。 其等价于： int po1=6; //定义 int 型变量 po1，赋值为 6。 int *p; //定义指针变量 p p=&po1; //指针变量 p 指向变量 po1 的地址。 我们通过一个例子加深一下指针的定义和使用，新建 pointer1.cpp，输入： #include using namespace std; int main () { int po1=6; //定义 int 型变量 po1，赋值为 6。 int *p=&po1; //指针变量 p 指向变量 po1 的地址。 cout 其中 p 运用指针运算符 获取指针 p 所指变量的值；&p 运用取地址运算符 & 获取指针 p 的地址。 引用 引用是指对已存在的变量别名，我们可以使用引用名来指向对象。 引用与指针主要有三个区别： 可以通过 指针名=0 描述一个空指针，但不存在空引用。 指针可在任何时间进行初始化操作，而引用只能在定义时进行初始化操作。 指针变量指向内存的一个存储单元；而引用只不过是原变量的一个别名而已。 声明引用变量的基本格式为： type &引用名=被指对象名； & 在这里是标识作用，而非取地址运算符。 例如定义引用 x，它是整型变量 i 的引用： int &x=i; 我们通过 初始化时间 来区别一下指针和引用，新建 pointer2.cpp 文件，输入： #include using namespace std; int main () { int i=3; int j=4; int &x=i; //定义引用 x，它是整型变量 i 的引用。 int *s; //定义指针 s。 s=&j; //指针 s 指向整型变量 j 的地址。 cout 其中 int &x=i; 表示在 定义引用时 进行的初始化操作。s=&j; 表示在 定义指针后 进行的初始化操作。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:30:55 "},"practice/chap2/summary.html":{"url":"practice/chap2/summary.html","title":"智能指针","keywords":"","body":" Part 2 智能指针 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:38:10 "},"practice/chap2/2_1.html":{"url":"practice/chap2/2_1.html","title":"实现原理","keywords":"","body":" 实现原理 在C/C++的编程中，内存管理一直是一个盛产BUG的重灾区。C/C++内存管理严格要求编码人员在编码的过程中，申请出来的内存资源必须要记得归还；归还内存资源时必须要确保没有任何模块正在使用该内存。 这真是很令人头疼的问题啊： 第一，依赖于人要记得做的事，人总是有可能会忘记去做； 第二，就算在某个模块的实现中，实现者确实做了所有TA该记得做的事，但谁又能保证，后续该模块的维护者也能够有如此好的记性呢； 第三，当一个项目中模块多而关系复杂的时候，一个内存资源有可能被多个模块共同使用着，这时确定何时才能安全的释放内存资源，将是一个很困难的问题。 基于以上种种，很多基于C++的大型项目中，都会去实现一种称为智能指针的类，如android项目的轻量级指针类sp，C++STL里也有智能指针auto_ptr。 所谓的智能指针，首先它是一个指针，所以能指向内存资源；然后它区别于一般的指针，它是智能的，而所谓的智能是指它：1.能够自动的帮你释放内存，2.还能够知道什么时候释放内存才是安全的。 C++中智能指针的实现主要依赖于两个技术概念： 析构函数，对象被销毁时会被调用的一个函数，对于基于栈的对象而言，如果对象离开其作用域则对象会被自动销毁，而此时析构函数也自动会被调用。 引用计数技术，维护一个计数器用于追踪资源(如内存)的被引用数，当资源被引用时，计数器值加1，当资源被解引用时，计算器值减1。 操作符重载。 智能指针的大致实现原理就是在析构函数中，检查所引用对象的引用计数，如果引用计数为0，则真正释放该对象内存。 详细的实现原理，我们在实验的过程中慢慢去理解。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap2/2_2.html":{"url":"practice/chap2/2_2.html","title":"智能指针类","keywords":"","body":"智能指针类 定义智能指针类 首先，我们是以C++的类来表示指针这个概念，所以不管三七二十一，我们得先有个class： // 头文件:smartpionter.h // 定义智能指针类 class SmartPointer { public: // ....... ~SmartPointer(); // 从前面智能指针的实现原理中，我们知道必须要有个析构函数 private: void *mPointer; // 指向智能指针实际对应的资源对象 }; 先来观察一下，我们是怎么创建原生指针的： // 创建一个不知所指的指针 char *punknown ; // 创建空指针 char *pnull = NULL; // 创建字符串指针 const char *pstr = \"Hello world!\"; // 创建指向具体类的指针 SomeClass *pclass = new SomeClass(); // 从同类型指针创建指针 SomeClass *pclassother = pclass; 所以必须要求我们的智能指针类，也能满足对应的用法： // 创建一个不知所指的智能指针 SmartPointer spunknown; // 创建空智能指针 SmartPointer spnull = NULL; // 创建字符串的智能指针 SmartPointer spstr = \"Hello world!\"; // 创建指向具体类的智能指针 SmartPointer spclass = new SomeClass(); 创建构造函数 根据上述创建指针的使用场景，我们的智能指针类必须具备以下构造函数： 默认构造函数，创建一个不知所指的智能指针； 可以指定任何指针类型的参数的构造函数，创建指向具体内存资源或者NULL的智能指针； 因此我们的智能指针类，现在应是这样的： // 头文件:smartpionter.h // 定义智能指针类 class SmartPointer { public: // 构造函数 SmartPointer() ; // 默认构造函数 SmartPointer(void *p) ; // 可以指向任何类型 // 析构函数 ~SmartPointer(); // 从前面智能指针的实现原理中，我们知道必须要有个析构函数 private: void *mPointer; // 指向智能指针实际对应的内存资源 }; 上述实现暴露了一个问题，我们的智能指针类，没法表示其所指对象的类型，也就是说我们的智能指针没有类型。指针的类型是很重要的一个概念，它表示指针所指对象的类型信息。如char 字符型指针，代表其所指对象为字符，而SomeClass 类指针，代表其所指对象的是一个类SomeClass。而在我们目前的实现中，我们将创建指针时，传入SmartPointer的指针全部被转换为void *类型的指针，这会导致SmartPointer所指向的资源类型信息丢失。 定义为模版类 解决这个问题的方法，是将我们的 SmartPointer 类定义成模板类，并使用模板参数来指定智能指针所指资源对象的类型: // 头文件:smartpionter.h // 定义智能指针类 template // 将智能指针类定义成模板类 class SmartPointer { public: // 构造函数 SmartPointer():mPointer(NULL) {} // 默认构造函数 SmartPointer(T *p):mPointer(p) {} // 接收指定类型的指针参数 // 析构函数 ~SmartPointer(); private: T *mPointer; // 指向智能指针实际对应的内存资源，根据参数自动推导规则，定义内部资源指针类型 }; 于是，我们将这么使用智能指针: // 创建一个不知所指的智能指针 SmartPointer spunknown; // 创建空智能指针 SmartPointer spnull = NULL; // 创建指向具体类的智能指针 SmartPointer spclass = new SomeClass; // 创建字符串的智能指针 SmartPointer spstr = \"Hello world!\"; 在智能指针的原理篇中，我们介绍过，智能指针的一个优点是，能够帮助我们释放内存，其实现原理就是在智能指针的析构函数中去实现内存的释放动作。这样，智能指针类被销毁时(栈对象离开其作用域会被自动销毁)，其所指内存资源也将会被自动销毁： // 头文件:smartpionter.h template class SmartPointer { public: //... // 析构函数 ~SmartPointer() { // 实现内存资源自动销毁机制 if (mPointer) delete mPointer; } //... }; 实现智能指针版本1 实现代码(smartpointer.h)： /* * file name : smartpointer.h * desp : 智能指针版本v1 */ #ifndef __SMARTPOINTER_H__ #define __SMARTPOINTER_H__ template // 将智能指针类定义成模板类 class SmartPointer { public: // 默认构造函数 SmartPointer():mPointer(NULL) {std::cout (p)(mPointer)测试智能指针版本1 接下来，我们通过实例来验证一下目前的智能指针版本1： 测试代码(sptestcase1.cpp)： /* * file name : sptestcase1.cpp * desp : 智能指针测试代码 case1 测试智能指针的创建与销毁 */ #include #include \"smartpointer.h\" class SomeClass{ public: SomeClass(){std::cout spunknown; // 创建空智能指针 SmartPointer spnull = NULL; // 创建指向具体类的智能指针 SmartPointer spclass = new SomeClass; // 创建字符串的智能指针 SmartPointer spstr = \"Hello world!\"; } int main(void) { testcase1(); return 0; } 编译及执行： $ g++ -o sptestcase1 sptestcase1.cpp $ ./sptestcase1 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap2/2_3.html":{"url":"practice/chap2/2_3.html","title":"拷贝与复制","keywords":"","body":"拷贝与复制 指针的常见用法 下面我们来观察指针的使用中另外几种比较常见的用法： // 先创建一个空的智能指针,再给已创建好的智能指针赋值 SmartPointer spclass1 = NULL; spclass1 = new SomeClass; // 创建另一个智能指针，与先前的指针指向同一块内存资源 SmartPointer spclassother = spclass1; // 先创建智能指针,再用另一个智能指针给已创建好的智能指针赋值 SmartPointer spclass2 = new SomeClass; spclass2 = spclass1; 这几种用法转化为智能指针的实现需求，就是要求智能指针有拷贝构造函数和赋值操作符的实现，拷贝与赋值对于指针而言意味共享其所指的内存资源，对应于智能指针的实现就是mPointer成员指向同一块内存资源。 默认情况下C++编译器会为我们定义的类生成拷贝构造函数和赋值操作符的实现，但是对于我们的智能指针而言，使用系统默认为我们生成的赋值操作符的实现，是会有问题的。假设我们有以下代码段： { // 语句块 SmartPointer spclass1 = new SomeClass; //1 SmartPointer spclass2 = new SomeClass; //2 spclass2 = spclass1; //3 调用 赋值操作符 } 那么当该语句块执行完毕，我们的期望是，代码1和2处new出来的对象应该都要有智能指针自动去释放，但是如果使用系统默认为我们生成的赋值操作符的实现，1处new出来的对象将永远不会被释放，而2处new出来的对象会被释放两次。 因此我们需要自行实现赋值操作符， 而拷贝构造函数一般与赋值操作符总是出双入对的，所以我们也就顺带一起实现了。 定义构造函数和赋值操作符的函数原型 首先我们先定义一下拷贝构造函数和赋值操作符的函数原型： // 头文件：smartpointer.h template // 将智能指针类定义成模板类 class SmartPointer { public: // .... // 拷贝构造函数 SmartPointer(const SmartPointer &other); // 赋值操作符 SmartPointer &operator = (const SmartPointer &other); // .... }; 赋值操作符的实现，需要处理两个问题： 底层指针的释放问题 该问题就是造成我们需要自行实现赋值操作符的原因，我们的解决方案是在给底层指针赋新值前，先将原来的释放，即: if (mPointer) delete mPointer; mPointer = other.mPointer; 自我赋值的问题 所谓自我赋值，就是这样： SmartPointer spclass = new SomeClass; spclass = spclass; // 也许我们在心里会想，谁会写这么傻X的代码 ^^ 这种自我赋值， 会导致我们针对问题1的解决方案出现问题。自我赋值时mPointer和other.mPointer会指向同一块内存对象，因此按照上述针对问题1的解决方案，最终我们的智能指针将会指向一块被释放了的内存。 针对这种自我赋值现象，我们使用经典的解决方式，即if (this == &other) return *this;。 关于自我赋值的内容，详细可参考《effective c++》一书。 实现智能指针版本2 实现代码(smartpointer.h)： /* * file name : smartpointer.h * desp : 智能指针版本v2 */ #ifndef __SMARTPOINTER_H__ #define __SMARTPOINTER_H__ template // 将智能指针类定义成模板类 class SmartPointer { public: // 默认构造函数 SmartPointer():mPointer(NULL) {std::cout (p)(mPointer)(other.mPointer)(other.mPointer)测试智能指针版本2 测试代码(sptestcase2.cpp)： /* * file name : sptestcase2.cpp * desp : 智能指针测试代码 case2 测试智能指针的拷贝与赋值 */ #include #include \"smartpointer.h\" class SomeClass{ public: SomeClass(){std::cout spclass1 = new SomeClass; std::cout spclassother = spclass1; std::cout spclass2 = new SomeClass; std::cout 编译及执行： $ g++ -o sptestcase2 sptestcase2.cpp $ ./sptestcase2 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap2/2_4.html":{"url":"practice/chap2/2_4.html","title":"引用计数技术","keywords":"","body":" 引用计数技术 实现引用计数技术，最主要的一个问题是\"谁来负责存储这个引用计数\"。让智能指针来肩负这个责任是不现实的，因为有可能存在某个智能指针已经被销毁了，而其所指资源对象还继续有效的情况。因此这个引用计数需要存储在被引用的资源对象里。一言以蔽之，一个资源对象对应一个引用计数， 当其引用计数为0时，资源对象可以被销毁。 如何引入计数技术 我们以SomeClass类为例，来观察一下如何引入引用计数技术： class SomeClass{ public: /*构造函数，引用计数值初始化为0*/ SomeClass():mCount(0){std::cout 那么我们的智能指针必须这样实现： //头文件：smartpointer.h template // 将智能指针类定义成模板类 class SmartPointer { public: //...... // 接收不同对象类型的构造函数 SmartPointer(T *p):mPointer(p) { /*智能指针指向类T，引用计数加1*/ if (mPointer) mPointer->incRefCount(); } // 析构函数 ~SmartPointer(){ // 实现内存资源自动销毁机制 if (mPointer && mPointer->decRefCount()==0) delete mPointer; } // 拷贝构造函数 SmartPointer(const SmartPointer &other):mPointer(other.mPointer) { // 引用计数加1 if(mPointer) mPointer->incRefCount(); } // 赋值操作符 SmartPointer &operator = (const SmartPointer &other) { T *temp(other.mPointer); // 新指向对象，引用计数值加1 if (temp) temp->incRefCount(); // 原指向对象，引用计数值减1，如果减1后引用计数为0 销毁原资源对象 if (mPointer && mPointer->decRefCount()==0) delete mPointer; // 智能指针指向新资源对象 mPointer = temp; return *this; } //...... private: T *mPointer; // 指向智能指针实际对应的内存资源，根据参数自动推导规则，定义内部资源指针类型 }; 引入引用计数的智能指针，其实现主要需要更新以下几点： 接收不同对象类型的构造函数 这个构造函数实现，比较简单，直接将引用计数加1 即可。 析构函数 析构函数的实现，不能再直接做delete操作，而是需要先对引用计数减1，当引用计数为0时，才做delete操作。 拷贝构造函数 拷贝构造函数的实现，底层指针共享，然后将引用计数加1 即可。 赋值操作符 赋值操作的实现，稍微复杂一些，涉及到将新指向对象的引用计数加1，将原指向对象的引用计数减1，如果有需要还要销毁原指向对象。这里有一点值得注意的地方，我们新的赋值操作的实现，不再需要if (this == &other) return *this;语句处理自我赋值的情况，读者可自行分析一下我们新的赋值操作的实现为何不需要通过if语句去处理自我赋值的情况。 实现智能指针版本3 分析v3版本的智能指针实现，我们还可以看出，为了能够使用引用计数技术，我们的智能指针不能再像原生指针那样能用可以指向任意资源对象，我们的智能指针只能指向实现了存在方法incRefCount和方法decRefCount的资源类了。 一般按照面向对象的设计方法，我们会将管理引用计数的相关内容，抽象成一个基类，这样任何期望能够被智能指针引用的资源类，只要继承该类即可： // 头文件：smartpointer.h /*引用计数基类*/ class RefBase { public: RefBase() : mCount(0){ } void incRefCount(){ mCount++; } int decRefCount(){ return --mCount; } //! DEBUGGING ONLY: Get current ref count. int getRefCount(){ return mCount; } virtual ~RefBase(){}; private: int mCount; }; /*继承于引用计数基类的SomeClass类*/ class SomeClass: public RefBase{ public: SomeClass(){std::cout 我们将RefBase放入，智能指针所在头文件smartpointer.h中，得到我们引入了引用计数技术的智能指针v3版本： /* * file name : smartpointer.h * desp : 智能指针版本v3 */ #ifndef __SMARTPOINTER_H__ #define __SMARTPOINTER_H__ template // 将智能指针类定义成模板类 class SmartPointer { public: // 默认构造函数 SmartPointer():mPointer(NULL) {std::cout (p)incRefCount(); } // 析构函数 ~SmartPointer(){ std::cout (mPointer)decRefCount()==0) delete mPointer; } // 拷贝构造函数 SmartPointer(const SmartPointer &other):mPointer(other.mPointer) { std::cout (other.mPointer)incRefCount(); } // 赋值操作符 SmartPointer &operator = (const SmartPointer &other) { T *temp(other.mPointer); // 新指向对象，引用计数值加1 if (temp) temp->incRefCount(); // 原指向对象，引用计数值减1，如果减1后引用计数为0 销毁原资源对象 if (mPointer && mPointer->decRefCount()==0) delete mPointer; // 智能指针指向新资源对象 mPointer = temp; return *this; } private: T *mPointer; // 指向智能指针实际对应的内存资源，根据参数自动推导规则，定义内部资源指针类型 }; /*引用计数基类*/ class RefBase { public: RefBase() : mCount(0){ } void incRefCount(){ mCount++; } int decRefCount(){ return --mCount; } // 调试接口，返回对象当前引用计数 int getRefCount(){ return mCount; } virtual ~RefBase(){ } private: int mCount; }; #endif // __SMARTPOINTER_H__ 测试智能指针版本3 测试代码(sptestcase3.cpp)： /* * file name : sptestcase3.cpp * desp : 智能指针测试代码 case3 测试智能指针的引用计数功能 */ #include #include \"smartpointer.h\" /*继承于引用计数基类的SomeClass类*/ class SomeClass: public RefBase{ public: SomeClass(){std::cout spOuter = pSomeClass; std::cout getRefCount() spInner = spOuter; std::cout getRefCount() getRefCount() spOuter2 = new SomeClass(); spOuter = spOuter2;// 1处new出来的SomeClass将会被自动释放 } int main(void) { testcase3(); return 0; } 编译及执行： $ g++ -o sptestcase3 sptestcase3.cpp $ ./sptestcase3 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap2/2_5.html":{"url":"practice/chap2/2_5.html","title":"解引用和判空以及比较","keywords":"","body":" 解引用、判空、以及比较 在上一个实验中，我们介绍了引用计数，并且实现了基于引用计数的内存管理工具。但是，到目前为止，我们的智能指针仍然不够完美，我们期待能像使用原生指针一样来使用智能指针。幸运的是，C++ 为我们提供了操作符重载，下面我们将会介绍与操作符重载相关的知识，以及操作符重载在智能指针中的应用。 解引用 我们使用指针最终还是需要通过指针去访问其所指向的资源对象的数据及方法，这个过程称为指针的解引用过程。指针的解引用可以使用*运算符和->运算符， 具体使用看以下例子： /*增加了func方法的SomeClass类*/ class SomeClass: public RefBase{ public: SomeClass(){std::cout func(); copy 为了符合我们使用指针的习惯，我们的智能指针也必须能够满足上述两种解引用的方式。C++语言的运算符重载机制，为我们满足上述需求提供了技术支持。 所谓的运算符重载，说白了，就是我们将运算符当成一个函数，我们根据自身的需求重新实现该运算符的语义。 为了实现智能指针的解引用功能，我们需要重载*运算符和->运算符： template class SmartPointer { public: /*重载运算符* */ T& operator* () const; /*重载运算符-> */ T* operator-> () const; }; 在我们的智能指针类重载了运算符后，当我们这样使用智能指针时： (*SmartPointer).func(); SmartPointer->func(); copy 其实等价于： (*(SmartPointer.operator*())).func(); (SmartPointer.operator->())->func(); copy 也就是说，我们在重载*运算符时其返回的应该是智能指针所指的资源对象实体, 而->运算符则应该返回的是智能指针指针所指的资源对象的内存地址，既是我们的实现是这样的： // 重载*和-> 运算符 /*重载运算符* */ T& operator* () const {return *mPointer;}; /*重载运算符-> */ T* operator-> () const {return mPointer;}; 比较与判空 在使用指针的过程中，我们经常需要，对指针的有效性进行判断；有时需要比较两个指针是否指向通一块内存区域，大致的使用语法有以下几种： SmartPointer sp1, sp2; SomeClass *p; SmartPointer sp3; char *pp; //需求1 if (sp1) if (!sp1) //需求2 if (sp1==NULL) if (sp1!=NULL) if (sp1==p) // if (sp1==pp) ERROR //需求3 if (sp1==sp2) //if (sp1!=sp3) ERROR copy 针对这个需求1，我们的第一感觉就是重载转型至bool的运算符吧，即： operator bool() const { return mPointer != NULL; } 这样我们就能在对智能指针进行判空的时候，根据底层指针的判空结果，返回相应的测试值。 但是这么实现会有个问题： SmartPointer sp1; SmartPointer sp3; //不同类型的指针在比较时，会被转型成bool，然后进行比较，这在原生指针是不允许的！ if (sp1 == sp3) if (sp1 != sp3) 因此对于转型至bool的重载不是个明智的选择。 考虑到我们可以用以下语法达到与需求1一致的判断结果： if (sp1==NULL) if (sp1!=NULL) 因此，我们决定只通过重载==和!=运算符来满足智能指针判空与比较的需求。 观察需求2与需求3，==和!=运算符，都必须满足两种方式的比较： // 方式1 智能指针与原生指针的比较 if (sp1==NULL) if (sp1!=NULL) if (sp1==p) //方式2 智能指针与智能指针间的比较 if (sp1==sp2) 因此我们的==和!=运算符都是必须重载两个版本： // 重载== bool operator ==(const T* o) const { return mPointer == o; } bool operator ==(const SmartPointer& o) const { return mPointer == o.mPointer; } // 重载!= bool operator !=(const T* o) const { return mPointer != o; } bool operator !=(const SmartPointer& o) const { return mPointer != o.mPointer; } 观察上述的代码，发现我们可以用宏来简化代码的编写： #define COMPARE(_op_) \\ bool operator _op_ (const SmartPointer& o) const { \\ return mPointer _op_ o.mPointer; \\ } \\ bool operator _op_ (const T* o) const { \\ return mPointer _op_ o; \\ } // 重载== COMPARE(==) // 重载!= COMPARE(!=) 实现智能指针版本4 智能指针的v4版本: /* * file name : smartpointer.h * desp : 智能指针版本v4 */ #ifndef __SMARTPOINTER_H__ #define __SMARTPOINTER_H__ #define COMPARE(_op_) \\ bool operator _op_ (const SmartPointer& o) const { \\ return mPointer _op_ o.mPointer; \\ } \\ bool operator _op_ (const T* o) const { \\ return mPointer _op_ o; \\ } template // 将智能指针类定义成模板类 class SmartPointer { public: // 默认构造函数 SmartPointer():mPointer(NULL) {std::cout (p)incRefCount(); } // 析构函数 ~SmartPointer(){ std::cout (mPointer)decRefCount()==0) delete mPointer; } // 拷贝构造函数 SmartPointer(const SmartPointer &other):mPointer(other.mPointer) { std::cout (other.mPointer)incRefCount(); } // 赋值操作符 SmartPointer &operator = (const SmartPointer &other) { T *temp(other.mPointer); // 新指向对象，引用计数值加1 if (temp) temp->incRefCount(); // 原指向对象，引用计数值减1，如果减1后引用计数为0 销毁原资源对象 if (mPointer && mPointer->decRefCount()==0) delete mPointer; // 智能指针指向新资源对象 mPointer = temp; return *this; } // 重载*和-> 运算符 /*重载运算符* */ T& operator* () const {return *mPointer;} /*重载运算符-> */ T* operator-> () const {return mPointer;} // 判空与比较 COMPARE(==); COMPARE(!=); private: T *mPointer; // 指向智能指针实际对应的内存资源，根据参数自动推导规则，定义内部资源指针类型 }; /*引用计数基类*/ class RefBase { public: RefBase() : mCount(0){ } void incRefCount(){ mCount++; } int decRefCount(){ return --mCount; } // 调试接口，返回对象当前引用计数 int getRefCount() const { return mCount; } virtual ~RefBase(){}; private: int mCount; }; #endif // __SMARTPOINTER_H__ 测试智能指针版本4 测试代码(sptestcase4.cpp)： /* * file name : sptestcase4.cpp * desp : 智能指针测试代码 case4 测试智能指针的解引用、判空及比较功能 */ #include #include \"smartpointer.h\" /*继承于引用计数基类的SomeClass类*/ class SomeClass: public RefBase{ public: SomeClass(){std::cout spsomeclass = new SomeClass(); (*spsomeclass).func(); spsomeclass->func(); std::cout spsomeclass = psomeclass; SmartPointer spotherclass = new OtherClass(); SmartPointer spotherclass2 = spotherclass; if (spsomeclass == NULL) std::cout编译及执行： $ g++ -o sptestcase4 sptestcase4.cpp $ ./sptestcase4 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_0summary.html":{"url":"practice/chap3/3_0summary.html","title":"STL","keywords":"","body":" C++ STL “Standard Template Library”,STL 由算法，容器，迭代器，适配器，仿函数（函数对象），空间适配器六大部件组成 。 知识点： 模板编程 泛型编程 STL 常用组件 lambda 表达式 异常处理 内存处理 部分数据结构 部分算法 提示：本课程所有代码至少需要开启 -std=c++11 选项来支持 C++11 相关特性，在介绍 C++14 特性时的相关代码需要开启 -std=c++14 的编译选项，例如： g++ main.cpp -std=c++11 g++ main.cpp -std=c++14 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_1.html":{"url":"practice/chap3/3_1.html","title":"STL简介","keywords":"","body":" STL简介 容器 容器首先是一个模板类，在类中实现对数据的操作，而包含这样的类的实现就叫一个容器。STL 有许多这样的容器，它们包括：向量（vector），列表（list），队列（queue），双端队列（deque），优先队列（Priority queue），集合（set），多种集合（multiset），映射（map），多重映射（multimap）。 算法 数据结构加算法等于程序，如果说容器实现了数据结构的话，那么算法就是 STL 的灵魂 ，STL 的算法是一种通用的算法，并不依赖于特定的数据结构和对象 。 这样的好处是不用针对每种情况编写特定的代码，而是给出一种通用的做法，是代码复用的一种实现方法，模板编程则是泛型编程的基础。 迭代器 add（int &a ,int &b） ，它传入两个引用，然后执行加法操作，可以看到它依赖于 int 这个特定的类型，而且暴露了这个函数的内部结构不利于对底层的隔离和封装。 那么 STL 是怎么解决这个问题的呢？ 他们使用了迭代器（对指针的一种泛化）。 迭代器底层是由指针实现的，是容器和算法的桥梁。STL 里大多数容器都实现了自己的迭代器，我们可以使用迭代器来完成对容器的访问。后面我们会详细讲到迭代器的种类，性质，使用，实现。 适配器 数据结构不是独立的，部分数据结构是可以相互转换的。 比如栈和队列可以互相实现。 当我们需要一个碗的时候我们不一定重新制造，我们可以把瓶子的上部去掉。 同样的道理，当我们需要队列（queue）的时候，也可以用双端队列（deque）去实现。 而 queue 就叫做适配器。 STL 有三种基本容器 vector，deque，list。 有用基本容器扩展的适配器 queue，stack 等。 适配器主要有容器适配器，迭代器适配器，函数适配器，它们的作用范围不同，意思大致一致 仿函数 仿函数又叫做函数对象，其本质是类的对象，一种可回调机制，在类中重载了（）运算符，使对象在用（）时呈现出函数的特性，所以叫做仿函数。叫仿函数体现了它的作用，叫函数对象体现其本质，大家喜欢叫什么都可以。而为什么需要仿函数呢？因为 STL 没有也不可能将所有东西都包含到函数中，而程序是对现实的模拟，现实又是最复杂的，一个 sort（），你要 。如何协调呢？我们可以定义自己需要的仿函数，定制自己的操作 空间配置器 c++ 的一大魅力就是对底层的操作，你像一个魔法师一样，挥舞着魔杖操纵着底层的各种资源。当然一个不好，程序也崩给你看。而空间配置器就是 STL 自己的“内存池”。完成对内存的申请，释放，维护。配置器有两个部分：一级空间配置器，二级空间配置器。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_2.html":{"url":"practice/chap3/3_2.html","title":"template编程和迭代器粗解","keywords":"","body":" template编程和迭代器粗解 知识点 模板编程 基本语法 模板函数 类模板和成员模板 模板类中的静态成员 typename 和 class 迭代器 迭代器详解 迭代器种类和使用 模版编程 基本语法 模板编程是 STL 的基石，也是 c++11 的核心特性之一。模板是相对于编译器而言，顾名思义就是向编译器提供一个处理事务的模板，以后需要处理的东西，如果都是这个事务类型，那么统统用这个模板处理。 模板的基本语法如下： template template 告诉编译器，接下来是一个模板 ，typename 和 class 都是关键字，在这里二者可以互用没有区别。在 中 T 叫做模板形参，一旦模板被实例化，T 也会变成具体的类型。 模版函数 代码实例： template T add(const T lva ,const T rva) { T a ; a = lva + rva ; return a; } 这是一个模板函数的简单实例，所有模板函数在开始都需要 template 语句，以告诉编译器这是一个模板和参数等必要信息，当然里面的 T 可以取任意你喜欢的名字 ，模板参数个数也是任意更换的。 还要提醒的一点是：template 函数模板是支持默认参数的，T1 、T2 顺序在默认情况下是可以任意的，不用严格按照从右到左的顺序。 然后就是使用了，我们可以写出add(1,2) 这样的函数,也可以写出 add(2.5,4.6) 这样的函数，向 add 函数提供参数时，编译器会自动分析参数的类型，然后将所有用到 T 定义的换成相对性的类型，以上的两个函数在编译期间会生成 int add(const int lva ,const int rva) { int a ; a = lva + rva ; return a; } double add(const double lva ,const double rva) { double a ; a = lva + rva ; return a; } 这样的两个具体函数。如果我们使用add(1,2.0)是会报错的，编译器无法找到add(int,double)。 类模板和成员模板 c++11 不仅支持对函数的模板化，也支持对类的模板，下面来看基本的语法是怎样的： template class Myclass { T a; public: T add(const T lva ,const T rva); }; template T Myclass::add(const T lva, const T rva) { a = lva + rva; return a; } 这是一个简单并且典型的类模板，在程序中给出模板并不能使用它，还必须实例化，比如： Myclass A； //用 int 实例化一个类 A Myclass B； //用 double 实例化一个类 B 当程序编译到这里时就会按照我们给出的类型，声明两组类和两组类函数。注意，在这里我们一定要显式给出类型 T 。类模板不像是函数模板 ，函数模板会根据参数推断类型。 当然类模板也支持默认参数，但是类模板必须严格从右往左默认化。 成员模板 模板的使用范围是广泛的，不仅可以用作函数模板，类模板，还可以用作 class ，struct ，template class 的成员。而要实现 STL 这是我们必须掌握和使用的特性。我们先看一个简单的例子,用上面的类改编而来： template class Myclass { public: T a; template type_1 add(const type_1 lva ,const type_2 rva); }; template template type_1 Myclass::add(const type_1 lva, const type_2 rva) { a = lva + rva; return a; } 在类的声明中使用了一个嵌套的模板声明。且通过作用域运算符 :: 指出 add 是类的成员，需要注意的一点，有些编译器不支持模板成员，而有些编译器不支持在类外定义。我们默认大家的编译器都支持。模板如此强大，甚至允许我们在模板类中再建立模板类： template class Myclass { public: T a; template type_1 add(const type_1 lva ,const type_2 rva); template class Myclass_2; // 声明放在这里，具体定义放在类外进行。 Myclass_2 C; // 定义一个Myclass_2 类 A。使用 T 进行实例化 }; template template type_1 Myclass::add(const type_1 lva, const type_2 rva) { a = lva + rva; return a; } template template class Myclass::Myclass_2 { public: type_3 value; type_3 sub(const type_3 a , const type_3 b) {value = a - b;} }; 当然我们暂时还用不到这样复杂的东西，这里只是展现了模板的部分特性。 模板类中的静态成员 在类中定义的静态成员是存储在静态区中，被所有类对象共享，并不属于某一个类所有，同样的在模板类中的静态成员也不会被复制多份，而是被同类实例化的类对象共享，比如所有 int 和所有 double 的类对象，享有相互独立的静态变量。 也可以说是编译器生成了 int 和 double 两个版本的类定义 typename 和class typename和class是模板中经常使用的两个关键词 ，在模板定义的时候没有什么区别。以前用的是 class，后来 c++ 委员会加入了 typename。因为历史原因，两个是可以通用的。对有些程序员来说，在定义类模板的时候，常常使用 class 作为关键字，增加代码可读性。其它则用 typename，上面的代码大都遵循这样的标准，但是并无强制规定。但是如果二者没有差别，为什么还要加入 typename 呢？c++标准委员会不会增加无用的特性，让我们来看一个例子： class Myclass{ public: Myclass(); typedef int test; //定义类型别名 } template class Myclass2{ public: Myclass2(); T::test *a // 声明一个指向T::test类型的指针。 // typename T::test * a } 以上的代码没有全部写完，大家觉得编译器能够过吗？答案是不能,因为在 c++ 中，允许我们在类中定义一个类型别名，且使用的时候和类名访问类成员的方法一样。这样编译器在编译的时候就会产生二义性，它根本不知道这是一个类型还是别名，所以我们加上 typename 显式说明出来。当然如果这里没有二义性，比如Myclass ::test * a ,加上 typename 是会报错的。此外，在 class 的 STL 底层还有一个特性，用于保留模板参数，但是在 c++17 中已经舍弃，所以我们没有讲。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_3.html":{"url":"practice/chap3/3_3.html","title":"迭代器","keywords":"","body":" 迭代器 知识点 输出迭代器 输入迭代器 前向迭代器 双向迭代器 随机迭代器 迭代器辅助函数 迭代器详述 迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。迭代器基本分为五种，输入输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。 简单概括：迭代器是一种检查容器内元素并遍历元素的可带泛型数据类型。 下面，我们新建头文件 Iterator.h 是头文件，用来实现我们的迭代器，这里的代码需要引用到系统头文件 #include ，它主要用于定义一些类型。接下来我们定义 5 种迭代器的类型，将其写入 Iterator.h 文件中： struct input_iterator_tag{};//返回输入迭代器 struct output_iterator_tag{};//返回输出迭代器 struct forward_iterator_tag :public input_iterator_tag {};//返回前向迭代器 struct bidirectional_iterator_tag :public forward_iterator_tag {};//返回双向迭代器 struct random_access_iterator_tag :public bidirectional_iterator_tag {};//返回随机迭代器 输入迭代器 通过对输入迭代器解除引用，它将引用对象，而对象可能位于集合中。通常用于传递地址。 template struct input_iterator { typedef input_iterator_tag iterator_category;//返回类型 typedef T value_type;//所指对象类型 typedef Distance difference_type;//迭代器间距离类型 typedef T* pointer;//操作结果类型 typedef T& reference;//解引用操作结果类型 }; 输出迭代器 该类迭代器和输入迭代器极其相似，也只能单步向前迭代元素，不同的是该类迭代器对元素只有写的权力。通常用于返回地址。 struct output_iterator{ typedef output_iterator_tag iterator_category; typedef void value_type; typedef void difference_type; typedef void pointer; typedef void reference; }; 前向迭代器 前向迭代器可以在一个正确的区间中进行读写操作，它拥有输入迭代器的所有特性，和输出迭代器的部分特性，以及单步向前迭代元素的能力。通常用于遍历。 template struct forward_iterator{ typedef forward_iterator_tag iterator_category; typedef T value_type; typedef Distance difference_type; typedef T* pointer; typedef T& reference; }; 双向迭代器 该类迭代器是在前向迭代器的基础上提供了单步向后迭代元素的能力，前向迭代器的高级版。 template struct bidirectional_iterator{ typedef bidirectional_iterator_tag iterator_category; typedef T value_type; typedef Distance difference_type; typedef T* pointer; typedef T& reference; }; 随机迭代器 该类迭代器能完成上面所有迭代器的工作，它自己独有的特性就是可以像指针那样进行算术计算，而不是仅仅只有单步向前或向后迭代。 template struct random_access_iterator{ typedef random_access_iterator_tag iterator_category; typedef T value_type; typedef Distance difference_type; typedef T* pointer; typedef T& reference; }; 迭代器辅助函数 迭代器的实现，我们这里主要会使用到两个函数来辅助完成操作，分别是 advace 函数和 distance 函数。这两个函数是写到Algorithm.h文件中的。 advance 函数: 用于迭代器前移，增加迭代的位置。可用于定向访问到迭代器的某个变量。 template void _advance(InputIterator& it, Distance n, input_iterator_tag){ assert(n >= 0); while (n--){//当n大于0，迭代器前移n位 ++it; } } void advance(InputIterator& it, Distance n){ typedef typename iterator_traits::iterator_category iterator_category; _advance(it, n, iterator_category()); } distance 函数: 用于计算迭代器间距离 template typename iterator_traits::difference_type_distance(InputIterator first, InputIterator last, input_iterator_tag){ typename iterator_traits::difference_type dist = 0;//初始化距离 while (first++ != last){//当首地址不等于尾地址，距离增加 ++dist; } return dist;//返回迭代器间距离 } template typename iterator_traits::difference_type_distance(Iterator first, Iterator last){ typedef typename iterator_traits::iterator_category iterator_category; return _distance(first, last, iterator_category()); } 实例测试 完成上面迭代器的实现后，我们现在在 Test 目录下新建文件 iteratortest.cpp,用于测试 Iterator 的功能。这里的测试我们需要借助到 vector 容器。关于Vector 容器的内容，我们将在后面的实验中给大家讲解，这里我们直接使用 Vector.h的内容。该文件可以通过下载课程源码找到。 #include #include \"Iterator.h\" #include \"Vector.h\" int main() { mySTL::vector vec; for(int i = 0;i ::iterator it = vec.begin(); mySTL::vector::iterator end = vec.end(); std::coutOceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_4.html":{"url":"practice/chap3/3_4.html","title":" 函数对象（仿函数）","keywords":"","body":" 函数对象（仿函数） 知识点 函数对象概述 预定义函数对象 辅助函数对象 适配器 函数对象使用方法 函数对象概述 函数对象是重载函数调用操作符的类的对象。即函数对象是行为类似函数的对象，又称仿函数，是一个能被当做普通函数来调用的对象。 函数对象与函数指针相比，有两个优点：第一是编译器可以内联执行函数对象的调用；第二是函数对象内部可以保持状态。 STL 中的众多算法，非常依赖于函数对象处理容器的元素。所以 STL 预定义了许多函数对象、谓词和适配器。 预定义和辅助函数对象 首先在 include 目录下创建 Functional.h。 unary_function: 作为一元函数对象的基类，只定义了参数和返回值的类型 template struct unary_function { typedef T argument_type; typedef T result_type; }; binary_function:作为二元函数基类，只定义了参数和返回值的类型 template struct binary_function { typedef T first_argument_type; typedef T second_argument_type; typedef T result_type; }; less:用于返回较小值 template struct less{ typedef T first_argument_type; typedef T second_argument_type; typedef bool result_type; result_type operator()(const first_argument_type& x, const second_argument_type& y){ return x equal_to: 判断是否相等 template struct equal_to{ typedef T first_argument_type; typedef T second_argument_type; typedef bool result_type; result_type operator()(const first_argument_type& x, const second_argument_type& y){ return x == y; } }; identity: 验证同一性 template struct identity : public unary_function { const T& operator()(const T& x) const {return x;} //函数调用操作符 }; select1st: 返回键值，在 map 中会用到 template struct select1st : public unary_function { const typename T::first_type& operator()(const T& x) const {return x.first;} }; 适配器 函数对象适配器本质上任然是一个函数；函数对象适配器提供了对函数对象或者普通函数的操作，使其能够根据我们的需求来修改函数对象或者普通函数的功能。 使用函数对象适配器的步骤: （1）首先让自定义的函数对象 public 继承一个父类。这里有两个选择：binary_function 和 unary_function。如果有两个参数选择前者。 （2）定义一个函数对象作为参数传入函数对象适配器。常见的函数对象适配器有: 绑定适配器 bind1st bind2nd (bind1st 绑定第一个参数, bind2nd 绑定第二个参数) 取反适配器 not1 not2 (not1 作用于一元函数对象，not2 作用于二元函数对象) 普通函数适配器 ptr_fun 作用于类中方法的适配器 mem_fun mem_fun_ref （3）加 const 实例测试 #include #include \"Vector.h\" #include \"Functional.h\" using namespace std; class compare:public binary_function{//用于接收两个参数 public: bool operator()(int i, int num) const { return i > num; } }; class comparetonum:public unary_function{//用于接收一个参数 public: bool operator()(int i) const { return i > 5; } }; void print(int i,int j)//普通函数对象 { if (i > j){ cout vec; for (int i = 0; i ::iterator it = find_if(vec.begin(), vec.end(), bind2nd(compare(),6));//找出大于6的第一个数 if (it == vec.end()) { cout ::iterator rit = find_if(vec.begin(), vec.end(), not1(comparetonum())); //取反适配器的用法，找出小于5的第一个数 if (rit == vec.end()) { cout vec1; for (int i = 0; i 执行命令： g++ functionaltest.cpp -std=c++11 -o functionaltest -I ../include OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_5.html":{"url":"practice/chap3/3_5.html","title":"算法","keywords":"","body":" 算法 lambda表达式定制操作 泛型算法中的定制操作 很多算法都会比较输入序列中的元素以达到排序的效果，通过定制比较动作，可以控制算法按照编程者的意图工作。 这里我们用排序算法举例。 普通排序算法，这样的排序算法只能按照从小到大排序，很多时候是不适用的。 template void sort(RandomIterator first, RandomIterator last){ if (first >= last || first + 1 == last) return; if (last - first 排序算法的定制操作,普通排序算法只能由小到大排序，并不智能。二排序算法的定制操作，次函数多了一个类型 BinaryPredicate，可以用来定制规则（如从大到小），增加了实用性。 template void sort(RandomIterator first, RandomIterator last, BinaryPredicate pred){ if (first >= last || first + 1 == last) return; if (last - first 谓词 谓词相当于一个动作（将要干什么），比如有一个需求，希望从大到小排序，则可以先定义一个谓词（函数）。 bool comp(const int& v1,const int& v2) { return v1 > v2; } 将这个函数传递给 sort 算法，就可以按照从大到小排序。 sort(v.begin(),v.end(),comp); lambda 表达式 前面的例子中，定义了一个函数传递给 sort 算法。这个函数可以重复使用还好，如果只是使用一次的话就显得比较麻烦，而且浪费了空间。这种情况下就可以使用 lambda 表达式。lambda 表达式相较于谓词，它没有定义函数（没有函数名）。 sort(v.begin(),v.end(),[]comp(const int& v1,const int& v2){return v1 > v2;});//这种没有定义函数的指定动作（谓词）的方式就是lambda表达式。 STL算法 find: 利用底层元素的等于操作符,对指定范围内的元素与输入值进行比较,当匹配时,结束搜索,返回该元素的一个迭代器。用于查找。 函数原型: template InputIterator find(InputIterator first, InputIterator last, const T& val){ for (; first != last; ++first){ if (*first == val) break; } return first; } sort: 以升序重新排列指定范围内的元素,重载版本使用自定义的比较操作。用于排序。 函数原型: template void sort(RandomIterator first, RandomIterator last){ return sort(first, last, less::value_type>()); } template void sort(RandomIterator first, RandomIterator last, BinaryPredicate pred){ if (first >= last || first + 1 == last) return; if (last - first swap: 交换存储在两个对象中的值。 函数原型: template void pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp){ mySTL::swap(*first, *(last - 1)); if (last - first >= 2) mySTL::down(first, last - 2, first, comp); } up:上溯算法，用于从下向上遍历 template //heap上溯算法 static void up(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterator head, Compare comp){ if (first != last){ int index = last - head; auto parentIndex = (index - 1) / 2; for (auto cur = last; parentIndex >= 0 && cur != head; parentIndex = (index - 1) / 2){ auto parent = head + parentIndex;//get parent if (comp(*parent, *cur)) mySTL::swap(*parent, *cur); cur = parent; index = cur - head; } } } down:下降算法，用于从上向下遍历 template //heap下降算法 static void down(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterator head, Compare comp){ if (first != last){ auto index = first - head; auto leftChildIndex = index * 2 + 1; for (auto cur = first; leftChildIndex *child)//cur has a right child child = child + 1; if (comp(*cur, *child)) mySTL::swap(*cur, *child); cur = child; index = cur - head; } } } copy: 复制算法，常用于赋值 template<> inline char *copy(char *first, char *last, char *result){ auto dist = last - first; memcpy(result, first, sizeof(*first) * dist); return result + dist; } set算法 set 给出了四种算法，分别是交集，并集， 差集，对称差集。但是此处的 set 不同于数学中的集合。 数学中的集合允许元素以任意次数、任意次序出现，但此处的不允许元素重复出现，而且所有元素按序出现。这四种算法处理的结构也是有序的。 交集 set_intersection 交集用于求出两个不同集合中的相同元素。 template OutputIt set_intersection(InputIterator first1, InputIterator last1, InputIterator first2, InputIterator last2, OutputIterator d_first){ while (first1 != last1 && first2 != last2) { if (*first1 并集 set_union 将两个集合合并到一起，相同的元素只在并集中出现一次。 template OutputIt set_union(InputIterator first1, InputIterator last1, InputIterator first2, InputIterator last2, OutputIterator d_first) { for (; first1 != last1; ++d_first) { if (first2 == last2) return std::copy(first1, last1, d_first); if (*first2 差集 set_difference 在集合 1 中出现而没有在集合 2 出现的元素 template OutputIt set_difference(InputIterator first1, InputIterator last1, InputIterator first2, InputIterator last2, OutputIterator d_first) { while (first1 != last1) { if (first2 == last2) return std::copy(first1, last1, d_first); if (*first1 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_6.html":{"url":"practice/chap3/3_6.html","title":"基础容器之vector","keywords":"","body":" 基础容器之vector 知识点 vector基础 vector初始化 vector基本操作 vector成员函数 vector详解 vector介绍 vector 是 C++ 标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。vector 是向量类型，它可以容纳多种类型的数据，所以称之为容器。 vector类基础 为 vector 定义四个私有成员: start_:表示使用空间的头 finnish:表示使用空间的末尾 *endofStorage:表示可用空间的末尾 dataAllocator:表示分配空间 private: T *start_; T *finish_; T *endofStorage_; typedef Alloc dataAllocator; 同时我们还需要声明一些类型，以便于与系统类型进行区别。 public: typedef T value_type;//值类型 typedef T* iterator;//迭代器 typedef const T* const_iterator;//常量迭代器 typedef reverse_iterator_t reverse_iterator;//反向迭代器 typedef reverse_iterator_t const_reverse_iterator; typedef iterator pointer;//操作结果类型 typedef T& reference;//解引用操作结果类型 typedef const T& const_reference; typedef size_t size_type; typedef ptrdiff_t difference_type;//表示两个迭代器之间的距离 ,c++内置定义 typedef int ptrdiff_t; vector初始化 和任何一种类类型一样，vector 模板控制着定义和初始化向量的方法。下面我们就讲讲 vector 的初始化。 不带参数的构造函数初始化(默认值为 0) vector():start_(0), finish_(0), endOfStorage_(0){} 带参数的构造函数初始化 构造 n 个 0 template vector::vector(const size_type n){ allocateAndFillN(n, value_type());//调用成员函数，默认值为0 } 构造 n 个 value template vector::vector(const size_type n, const value_type& value){ allocateAndFillN(n, value);//调用成员函数 } 把 fist 到 last 的所有元素放进 vector ``` template template vector::vector(InputIterator first, InputIterator last){ //处理指针和数字间的区别的函数 vector_aux(first, last, typename std::is_integral::type());//需调用插入辅助函数 } template template void vector::vector_aux(Integer n, const value_type& value, std::true_type){ allocateAndFillN(n, value);//构造辅助函数 } - 拷贝赋值构造一个 vector template vector::vector(const vector& v){ allocateAndCopy(v.start, v.finish);//这里调用辅助成员函数完成 } - 赋值操作符 template vector& vector::operator = (const vector& v){ if (this != &v){ allocateAndCopy(v.start, v.finish); } return *this; } - 析构函数 template vector::~vector(){ destroyAndDeallocateAll(); } ### vector 常规操作（添加、删除、访问、插入） ##### 添加（添加到末尾） vector 有自己的添加元素的方法，就是把元素添加到 vector 容器的末尾。这里我们命名为 push_back()函数。我们需要考虑到空间问题，如果空间已满的情况下，需要申请更多的空间。 template void vector::push_back(const value_type& value){ insert(end(), value); } ##### 删除 删除需要根据具体情况来看，可以单纯只删除一个，也可以删除某指定元素或者某串元素，下面我们对这些问题具体分析。 - 尾部删除 尾部删除可以简单的执行删除操作。 template void vector::popback(){ --finish; dataAllocator::destroy(finish_);//辅助成员函数 } - 指定删除 简单的尾部删除肯定满足不了我们的编程需求，所以这里假设了指定位置删除。 (1)指定位置删除 template typename vector::iterator vector::erase(iterator position){ return erase(position, position + 1); } (2)指定范围删除 template typename vector::iterator vector::erase(iterator first, iterator last){ //尾部残留对象数 differencetype lenOfTail = end() - last; //删去的对象数目 difference_type lenOfRemoved = last - first; finish = finish_ - lenOfRemoved; for (; lenOfTail != 0; --lenOfTail){ auto temp = (last - lenOfRemoved); temp = (last++); } return (first); } ##### 访问 vector 的访问是比较简单的，只要掌握了数组的使用，就不难理解。 - 返回下标位置元素 reference operator{ //重载[],这样可以用a[n]进行访问元素 return *(begin() + i); } - 返回倒数第 i 个元素 const_reference operatorconst{ return *(cbegin() + i); } - 返回第一个元素 reference front(){ return *(begin()); } - 返回最后一个元素 reference back(){ return *(end() - 1); } - 返回第一个元素的指针 pointer data(){ return start_; } ##### 插入 单纯的尾部添加可能还需要我们进行排序之类的操作，这样就增加了不少的外部代码，所以我们有必要增加一个成员函数 insert，用于在指定位置插入元素。 - 单个插入 template typename vector::iterator vector::insert(iterator position, const value_type& val){ const auto index = position - begin(); insert(position, 1, val);//插入辅助函数 return begin() + index; } template template void vector::insertaux(iterator position, Integer n, const value_type& value, std::true_type){ assert(n != 0);//判断n是否为0 difference_type locationLeft = endOfStorage - finish_; // 可使用空间大小 difference_type locationNeed = n;//需要空间 if (locationLeft >= locationNeed){//剩余空间大于需求空间 auto tempPtr = end() - 1; for (; tempPtr - position >= 0; --tempPtr){//move the [position, finish_) back construct(tempPtr + locationNeed, *tempPtr); } mySTL::uninitialized_fill_n(position, n, value); finish_ += locationNeed; } else{ reallocateAndFillN(position, n, value); } } - 指定范围插入 template template void vector::insert(iterator position, InputIterator first, InputIterator last){ insert_aux(position, first, last, typename std::is_integral::type());//插入辅助函数 } void vector::insertaux(iterator position, InputIterator first,InputIterator last,std::false_type){ difference_type locationLeft = endOfStorage - finish_; // 计算剩余空间大小 difference_type locationNeed = distance(first, last);//计算全部空间大小 if (locationLeft >= locationNeed){//如果剩余空间满足需求，直接插入 if (finish_ - position > locationNeed){ mySTL::uninitialized_copy(finish_ - locationNeed, finish_, finish_); std::copy_backward(position, finish_ - locationNeed, finish_); std::copy(first, last, position); } else{//不满足，把指定位置后的元素先取出来，插入后在添加到末尾 iterator temp = mySTL::uninitialized_copy(first + (finish_ - position), last, finish_); mySTL::uninitialized_copy(position, finish_, temp); std::copy(first, first + (finish_ - position), position); } finish_ += locationNeed; } else{ reallocateAndCopy(position, first, last); } } ### vector 增长模型 我们可以把 vector 理解为动态数组，作为一个动态数组，vector 有一个指针指向一片连续的内存空间，但是这片空间不是无限的，当内存装不下数据时，系统会自动申请一片更大的空间把原来的数据拷贝过去，释放原来的内存空间。 vector 的内存非常重要，一旦内存重新配置，与之相关的所有指针、迭代器都会失效，而且配置内存非常耗时。 ### vector 成员函数 vector 是非常方便的，这离不开它的成员函数，vector 的许多操作都是通过成员函数完成的，包括添加删除。 ### 迭代器相关 - 返回头部迭代器 iterator begin(){ return (start); } const_iterator begin()const{ return (start); }//常量迭代器，只读属性 constiterator cbegin()const{ return (start); } - 返回尾部迭代器 iterator end(){ return (finish); } const_iterator end()const{ return (finish); } constiterator cend()const{ return (finish); } - 逆向，返回头部迭代器 reverseiterator rend(){ return reverse_iterator(start); } constreverse_iterator crend()const{ return const_reverse_iterator(start); } - 逆向，返回尾部 reverseiterator rbegin(){ return reverse_iterator(finish); } constreverse_iterator crbegin()const{ return const_reverse_iterator(finish); ### 访问元素相关 - 顺序访问 reference front(){ return (begin()); } //返回头部迭代器 reference back(){ return (end() - 1); }//返回最后一个元素迭代器 pointer data(){ return start_; }//返回头部指针 - 定向访问 reference operator{ return (begin() + i); }//返回第 i 个元素的迭代器 const_reference operatorconst{ return (cbegin() + i); }//返回第 i 个元素的迭代器，只读 ### 容量相关 - 返回元素个数 differencetype size() const{ return finish - start_; } - 返回容量大小 differencetype capacity() const{ return endOfStorage - start_; } - 判断容器是否为空 bool empty() const{ return start == finish; } - 重新定义容器大小 template void vector::resize(sizetype n, value_type val){ if (n + n, finish); finish = start + n; } else if (n > size() && n = mySTL::uninitializedfill_n(finish, lengthOfInsert, val); } else if (n > capacity()){ auto lengthOfInsert = n - size(); T newStart = dataAllocator::allocate(getNewCapacity(lengthOfInsert)); T newFinish = mySTL::uninitialized_copy(begin(), end(), newStart); newFinish = mySTL::uninitialized_fill_n(newFinish, lengthOfInsert, val); destroyAndDeallocateAll();//初始化 start_ = newStart; finish_ = newFinish; endOfStorage_ = start_ + n; } } - 重新分配存储区大小 template void vector::reserve(size_type n){//首先释放空间，然后初始化 if (n newStart = dataAllocator::allocate(n); T newFinish = mySTL::uninitialized_copy(begin(), end(), newStart); destroyAndDeallocateAll(); start_ = newStart; finish_ = newFinish; endOfStorage_ = start_ + n; } - 删除所有元素 void clear() { erase(begin(), end()); } - 释放内存 template void vector::clear(){ dataAllocator::destroy(start, finish); finish = start; } ### 辅助函数 - 赋值,用于构造插入元素等 template template void vector::reallocateAndCopy(iterator position, InputIterator first, InputIterator last){ difference_type newCapacity = getNewCapacity(last - first);//需要申请空间大小 T *newStart = dataAllocator::allocate(newCapacity);//申请空间 T *newEndOfStorage = newStart + newCapacity; T *newFinish = mySTL::uninitialized_copy(begin(), position, newStart);//把begin到position赋值给新地址的头 newFinish = mySTL::uninitialized_copy(first, last, newFinish);//插入需要插入的值到新地址的尾 newFinish = mySTL::uninitialized_copy(position, end(), newFinish);//剩下的元素拷贝过来 destroyAndDeallocateAll();//释放空间 start_ = newStart;//重新定义 finish_ = newFinish; endOfStorage_ = newEndOfStorage; } ### vector 使用算法 vector 的编写使用了 #include \"Algoritm.h\" 和 #include \"Allocator.h\" 中的泛函算法，具体包括: - 分配空间 pointer allocate (size_type n, allocator::const_pointer hint=0); - 填充元素 void construct(T p,const T val);插入元素 - 释放空间 void deallocate (pointer p, size_type n);释放空间 - 填充元素到目的区间 void uninitialized_fill(ForwardIt first, ForwardIt last, const T& value); - 复制填充元素到目的区间 uninitialized_copy( InputIterator first, InputIterator last, ForwardIterator result); - 在指定位置插入 count 个 元素 void uninitialized_fill_n( ForwardIt first, Size count, const T& value ); ### vector 实例测试 include \"Vector.h\" include include \"Algorithm.h\" int summing(mySTL::vector val) { int sum = 0; mySTL::vector::iterator ix = val.begin(); for (;ix != val.end(); ix++) sum += *ix;//求和 return sum; } void print(mySTL::vector val){ mySTL::vector::iterator ix = val.begin(); for (;ix != val.end(); ix++) std::cout int main(int argv,char *argc[]) { int sum; int input[5]; std::cout>input[i];//输入5个参数 } mySTL::vector val(input,input + 5); if(val.size() == 0)//判断a是否为空 { std::cout::iterator it = val.begin(); mySTL::advance(it,2); val.insert(it,2,3); print(val); std::cout::iterator beg = val.begin(); mySTL::vector::iterator end = val.end(); mySTL::sort(beg,end); print(val); return 0; } 在命令行中执行如下代码： g++ vectortest.cpp -std=c++11 -o vectortest -I ../include ``` OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_7.html":{"url":"practice/chap3/3_7.html","title":"基础容器之list","keywords":"","body":" 基础容器之list 知识点 list介绍 list构造 list成员函数 list迭代器 list基本操作 list 的介绍和性质 list 其实就是一个双向链表，在编程语言中 List 是 c++ 标准模板库中的一部分内容，可以简单视之为双向连结串行，以线性列的方式管理物件集合。list 的特色是在集合的任何位置增加或删除元素都很快，但是不支持随机存取。 list 是类库提供的众多容器（container）之一。list 以模板方式实现（即泛型），可以处理任意型别的变量，包括使用者自定义的资料型态。 list 的定义和赋值 首先在 include 目录下创建 List.h ，在 Detail 目录下创建 List.impl.h 用于封装。 封装对象，形成链表节点 list 的本质是链表，所以我们要赋予 list 链表的属性。在这里先定义一个结构体。 template struct node{ T data; node *prev; node *next; list *container; node(const T& d, node *p, node *n, list *c): data(d), prev(p), next(n), container(c){}//初始化节点 bool operator ==(const node& n){//比较重载 return data == n.data && prev == n.prev && next == n.next && container == n.container; } }; 定义 我们需要定义一些 list 的成员来表示 list 的节点以及头和尾。 typedef allocator> nodeAllocator;//空间分配器 typedef Detail::node *nodePtr;//节点 private: iterator head;//定义头和尾 iterator tail; 同时我们还需要声明一些类型，以便于与系统类型进行区别。 public: typedef T value_type;//值类型 typedef Detail::listIterator iterator;//迭代器 typedef Detail::listIterator const_iterator;//常量迭代器 typedef reverse_iterator_t reverse_iterator;//逆向迭代器 typedef T& reference;//解引用操作结果类型 typedef size_t size_type; 初始化 初始化需要用到很多重复的代码，所以我们写了一个构造辅助函数 ctorAux 用于辅助。 无参构造 template list::list(){ head.p = newNode();//添加一个节点 tail.p = head.p; } 带参构造 list 有 n 个值的结点 template list::list(size_type n, const value_type& val){ ctorAux(n, val, std::is_integral());//定义一个初始化辅助函数 } 用 [first,last] 区间构造 list template template list::list(InputIterator first, InputIterator last){ ctorAux(first, last, std::is_integral()); } 拷贝复制构造 template list::list(const list& l){ head.p = newNode();//添加一个节点 tail.p = head.p; for (auto node = l.head.p; node != l.tail.p; node = node->next) push_back(node->data); } 析构函数 template list::~list(){ for (; head != tail;){ auto temp = head++; nodeAllocator::destroy(temp.p);//释放节点，调用成员函数 nodeAllocator::deallocate(temp.p);//释放空间 } nodeAllocator::deallocate(tail.p); } 迭代器 所谓的迭代器就是赋予容器指针一样的功能，但是又比指针智能，接下来我们就实现这个功能。 构建一个迭代器，可以理解为一个结构或者一个类，迭代器拥有自己的成员以及重载了一些操作符。 template struct listIterator :public iterator{ template//这里不能使用class T，会报重复声明 friend class list; public: typedef node* nodePtr;//节点指针 nodePtr p; public: explicit listIterator(nodePtr ptr = nullptr) :p(ptr){}//初始化迭代器 //重载相关 listIterator& operator++(){//自增 p = p->next; return *this;} listIterator operator++(int){//左值自增 auto res = *this; ++*this; return res; } listIterator& operator --(){//自减 p = p->prev; return *this; } listIterator operator --(int){//左值自减 auto res = *this; --*this; return res; } T& operator *(){ return p->data; }//返回迭代器指向的值 T* operator ->(){ return &(operator*()); }//指向 template friend bool operator ==(const listIterator& lhs, const listIterator& rhs){//比较是否相等 return lhs.p == rhs.p; } template friend bool operator !=(const listIterator& lhs, const listIterator& rhs){ return !(lhs == rhs); } }; 基础成员函数 接下来，我们给大家介绍相关基础成员函数，主要是迭代器相关和容器相关以及辅助函数. 迭代器相关 返回头部 iterator begin(){ return head; } const_iterator begin()const{ auto temp = (list*const)this; return changeIteratorToConstIterator(temp->head); }//常量迭代器，只读属性 const_iterator rbegin()const{ return reverse_iterator(tail); } 返回尾部 iterator end(){ return tail; } const_iterator end()const{ auto temp = (list*const)this; return changeIteratorToConstIterator(temp->tail); } const_iterator rend()const{ return reverse_iterator(head); } 容器相关 返回元素个数 template typename list::size_type list::size()const{ size_type length = 0; for (auto h = head; h != tail; ++h) ++length; return length; } 链接,用于拼接两个 list template void list::splice(iterator position, list& x){//在位置position链接list x this->insert(position, x.begin(), x.end()); x.head.p = x.tail.p; } template void list::splice(iterator position, list& x, iterator first, iterator last){//在位置position 链接 list x的first 到 last区间元素 if (first.p == last.p) return; auto tailNode = last.p->prev; if (x.head.p == first.p){//判断是否从头开始 x.head.p = last.p; x.head.p->prev = nullptr; } else{//链接 first.p->prev->next = last.p; last.p->prev = first.p->prev; } if (position.p == head.p){//在头部链接 first.p->prev = nullptr; tailNode->next = head.p; head.p->prev = tailNode; head.p = first.p; } else{//在position位置插入 position.p->prev->next = first.p; first.p->prev = position.p->prev; tailNode->next = position.p; position.p->prev = tailNode; } } 清空容器 template void list::clear(){ erase(begin(), end());//成员函数删除 } 辅助函数 删除节点,释放节点空间 template void list::deleteNode(nodePtr p){ p->prev = p->next = nullptr; nodeAllocator::destroy(p); nodeAllocator::deallocate(p); } 构造辅助函数 template void list::ctorAux(size_type n, const value_type& val, std::true_type){ head.p = newNode();//添加一个节点 tail.p = head.p; while (n--)//当 n 不为 0，放入元素 push_back(val); } template template void list::ctorAux(InputIterator first, InputIterator last, std::false_type){ head.p = newNode();//添加一个节点 tail.p = head.p; for (; first != last; ++first)//插入 first 到 last 元素 push_back(*first); } list 基础操作 list 的基本操作包括插入，删除和遍历等，这些在实际运用中是经常用到的。 插入 头插 template void list::push_front(const value_type& val){ auto node = newNode(val); head.p->prev = node; node->next = head.p; head.p = node; } 尾插 template void list::push_back(const value_type& val){ auto node = newNode(val);//新节点添加到尾 (tail.p)->data = val; (tail.p)->next = node; node->prev = tail.p; tail.p = node; } 指定位置插入一个元素 template typename list::iterator list::insert(iterator position, const value_type& val){ if (position == begin()){//是否在头插入 push_front(val); return begin(); } else if (position == end()){//是否在尾插入 auto ret = position; push_back(val); return ret; } auto node = newNode(val);//插入节点 auto prev = position.p->prev; node->next = position.p; node->prev = prev; prev->next = node; position.p->prev = node; return iterator(node); } 指定位置插入 n 个元素 template void list::insert(iterator position, size_type n, const value_type& val){ insert_aux(position, n, val, typename std::is_integral::type());//调用插入辅助函数 } template void list::insert_aux(iterator position, size_type n, const T& val, std::true_type){ for (auto i = n; i != 0; --i){ position = insert(position, val); } } 指定范围插入 template template void list::insert(iterator position, InputIterator first, InputIterator last){ insert_aux(position, first, last, typename std::is_integral::type());//调用插入辅助函数 } template template void list::insert_aux(iterator position, InputIterator first, InputIterator last, std::false_type){ for (--last; first != last; --last){//逐个插入 position = insert(position, *last); } insert(position, *last); } 删除 头删 template void list::pop_front(){ auto oldNode = head.p;//定义一个替代节点 head.p = oldNode->next; head.p->prev = nullptr; deleteNode(oldNode);//释放节点 } 尾删 template void list::pop_back(){ auto newTail = tail.p->prev; newTail->next = nullptr; deleteNode(tail.p); tail.p = newTail; } 指定位置删除 template typename list::iterator list::erase(iterator position){ if (position == head){//判断是否需要头删 pop_front(); return head; } else{ auto prev = position.p->prev; prev->next = position.p->next; position.p->next->prev = prev; deleteNode(position.p); return iterator(prev->next); } } 指定范围删除 template typename list::iterator list::erase(iterator first, iterator last){ typename list::iterator res; for (; first != last;){ auto temp = first++; res = erase(temp);//逐个删除 } return res; } 访问 返回头部元素 reference front(){ return (head.p->data); } 返回尾部元素 reference back(){ return (tail.p->prev->data); } list 的重载运算符 重载操作符是具有特殊名称的函数：保留了 operator 后接需定义的操作符符号。接下来我们实现几个运算符重载，重载运算符可以简化一些操作。 比较运算符重载 template bool operator== (const list& lhs, const list& rhs){//判断两个list是否相等 auto node1 = lhs.head.p, node2 = rhs.head.p; for (; node1 != lhs.tail.p && node2 != rhs.tail.p; node1 = node1->next, node2 = node2->next){ if (node1->data != node2->data) break; } if (node1 == lhs.tail.p && node2 == rhs.tail.p) return true; return false; } template bool operator!= (const list& lhs, const list& rhs){ return !(lhs == rhs);//返回不等 } list 实例测试 #include #include \"List.h\" void print(mySTL::list temp){ mySTL::list::iterator it = temp.begin(); for(; it != temp.end();it++) std::cout val; val.push_back(1); val.push_back(4); val.push_back(7); std::cout val1(val); print(val1); std::cout::iterator ix = val.begin(); std::cout在命令行中执行如下代码： g++ listtest.cpp -std=c++11 -o listtest -I ../include OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_8.html":{"url":"practice/chap3/3_8.html","title":"基础容器之deque","keywords":"","body":" 基础容器之deque 知识点 deque性质 deque定义和初始化 deque基本操作 deque迭代器 deque 的介绍和性质 deque 即双端队列，全名：double-ended queue，是一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。 在实际使用中，还可以有输出受限的双端队列（即一个端点允许插入和删除，另一个端点只允许插入的双端队列）和输入受限的双端队列（即一个端点允许插入和删除，另一个端点只允许删除的双端队列）。而如果限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻的栈了。（百度百科） （1）优缺点：尽管双端队列看起来似乎比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用。 （2）和 vector 相比 相同点： 在中部插入和删除比较缓慢。 迭代器属于随机存取迭代器。 不同： deque 两端都可以快速的插入和删除。 deque 元素的存取和迭代器操作较慢。 deque 的内存是可以自动缩减的，当内存空间不再使用时会自动释放。 deque 迭代器需要在不同区块间跳转，所以它非一般指针。 deque 除了头尾两端，在任何地方安插或删除元素，都将导致指向 deque 元素的所有迭代器失效。 deque 使用不只一块内存，vector 使用一块连续内存。 （3）c++标准建议：vector 是应该在默认情况下使用的序列。如果大多数插入和删除操作发生在序列的头部或尾部时，应该选用 deque。 deque 的定义和赋值 定义 我们需要给 deque 定义一些参数与方法名称，方便调用,名称最好是便于自己理解的。 定义队列的成员参数 private: iterator beg_, end_;//头和尾 size_t mapSize_;//空间 T **map_;//map是一个连续的空间, 其每个元素都是一个指向缓冲区的指针 private: typedef Alloc dataAllocator;//空间分配器 enum class EBucksSize{BUCKSIZE = 64};//设置默认容器尺寸 public: typedef T value_type;//参数类型 typedef Detail::dq_iter iterator;//迭代器 typedef Detail::dq_iter const_iterator;//常量迭代器 typedef T& reference;//解引用操作类型 typedef const reference const_reference; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef Alloc allocator_type;//空间分配器 构造 无参构造 template deque::deque():mapSize_(0), map_(0){} 带参构造 构造 n 个 val template deque::deque(size_type n, const value_type& val){ deque(); deque_aux(n, val, typename std::is_integral::type());//构造辅助函数 } 构造范围[first,last]的值 template template deque::deque(InputIterator first, InputIterator last){ deque(); deque_aux(first, last, typename std::is_integral::type());//构造辅助函数 } deque 迭代器 迭代器是容器的最关键的部分，因此迭代器的设计也是比较复杂的，所以我们一步一步的讲。 定义一个迭代器类，我们需要在 include 目录下创建 Deque.ipml.h 文件，用于封装成员。 定义成员变量 private: template friend class ::mySTL::deque;//友元调用deque private: typedef const ::mySTL::deque* cntrPtr; size_t mapIndex_; T *cur_; cntrPtr container_; 构造相关 public: dq_iter() :mapIndex_(-1), cur_(0), container_(0){}//无参构造 dq_iter(size_t index, T *ptr, cntrPtr container)//传参构造 :mapIndex_(index), cur_(ptr), container_(container){} dq_iter(const dq_iter& it) //拷贝构造 :mapIndex_(it.mapIndex_), cur_(it.cur_), container_(it.container_){} 重载相关 (1)赋值重载 dq_iter& operator = (const dq_iter& it){ if (this != &it){//如果不等，则赋值 mapIndex_ = it.mapIndex_; cur_ = it.cur_; container_ = it.container_; } return *this; } (2)操作符重载 reference operator *(){ return *cur_; }//返回值 const reference operator *()const{ return *cur_; } pointer operator ->(){ return &(operator*()); }//返回地址 const pointer operator ->()const{ return &(operator*()); } (3)自加重载 template dq_iter& dq_iter::operator ++(){ if (cur_ != getBuckTail(mapIndex_))//+1后还在同一个桶里 ++cur_; else if (mapIndex_ + 1 mapSize_){//+1后还在同一个map里 ++mapIndex_; cur_ = getBuckHead(mapIndex_); } else{//+1后跳出了map mapIndex_ = container_->mapSize_; //cur_ = container_->map_[mapIndex_] + getBuckSize();//指向map_[mapSize_-1]的尾的下一个位置 cur_ = container_->map_[mapIndex_]; } return *this; } template dq_iter dq_iter::operator ++(int){//左值自加 auto res = *this; ++(*this); return res; } (4)自减重载 template dq_iter& dq_iter::operator --(){ if (cur_ != getBuckHead(mapIndex_))//当前不指向桶头 --cur_; else if (mapIndex_ - 1 >= 0){//-1后还在map里面 --mapIndex_; cur_ = getBuckTail(mapIndex_); } else{ mapIndex_ = 0; cur_ = container_->map_[mapIndex_];//指向map_[0]的头 } return *this; } template dq_iter dq_iter::operator --(int){//左值自减 auto res = *this; --(*this); return res; } (5)比较相关重载 template bool dq_iter::operator ==(const dq_iter& it)const{//重载 return ((mapIndex_ == it.mapIndex_) && (cur_ == it.cur_) && (container_ == it.container_)); } template bool dq_iter::operator !=(const dq_iter& it)const{ return !(*this == it); } (6)成员函数相关 private: T *getBuckTail(size_t mapIndex)const{//获取空间的尾部元素 return container_->map_[mapIndex] + (container_->getBuckSize() - 1); } T *getBuckHead(size_t mapIndex)const{//获取空间头部元素 return container_->map_[mapIndex]; } size_t getBuckSize()const; (7)友元函数重载 \"+\"重载，前进 n 位 public: template friend dq_iter operator + (const dq_iter& it, typename dq_iter::difference_type n){// n >= 0 dq_iter res(it); auto m = res.getBuckTail(res.mapIndex_) - res.cur_; if (n friend dq_iter operator + (typename dq_iter::difference_type n, const dq_iter& it){ return (it + n); } \"-\"重载，用于后退 n 位 template friend dq_iter operator - (const dq_iter& it, typename dq_iter::difference_type n){//n >= 0 dq_iter res(it); auto m = res.cur_ - res.getBuckHead(res.mapIndex_); if (n friend dq_iter operator - (typename dq_iter::difference_type n, const dq_iter& it){ return (it - n); } 计算迭代器间距离 template friend typename dq_iter::difference_type operator - (const dq_iter& it1, const dq_iter& it2){ if (it1.container_ == it2.container_ && it1.container_ == 0) return 0; return typename dq_iter::difference_type(it1.getBuckSize()) * (it1.mapIndex_ - it2.mapIndex_ - 1) + (it1.cur_ - it1.getBuckHead(it1.mapIndex_)) + (it2.getBuckTail(it2.mapIndex_) - it2.cur_) + 1; } deque 成员函数 成员函数是容器的特色，拥有自己的成员函数才能提高编程的效率，下面我们添加一些成员函数。 返回首部指针 iterator begin(){ return beg_; } iterator begin()const{ return beg_; }//返回值不可修改 返回尾部指针 iterator end(){ return end_; } iterator end()const{ return end_; }//返回值不可修改 返回元素个数 size_type size() const{ return end() - begin(); } 判断是否为空 bool empty() const{ return begin() == end(); } 返回首部元素 reference back(){ return *begin(); } 返回尾部元素 reference back(){ return *(end() - 1); } 清空队列 template void deque::clear(){ for (auto i = 0; i != mapSize_; ++i){ for (auto p = map_[i] + 0; !p && p != map_[i] + getBuckSize(); ++p) dataAllocator::destroy(p);//释放空间 } mapSize_ = 0;//初始化 beg_.mapIndex_ = end_.mapIndex_ = mapSize_ / 2; beg_.cur_ = end_.cur_ = map_[mapSize_ / 2]; } 交换队列元素 template void deque::swap(deque& x){ mySTL::swap(mapSize_, x.mapSize_); mySTL::swap(map_, x.map_); beg_.swap(x.beg_); end_.swap(x.end_); } 辅助函数，用于辅助构造或者成员函数 (1)构造辅助函数 template void deque::deque_aux(size_t n, const value_type& val, std::true_type){//插入n个val int i = 0; for (; i != n / 2; ++i) (*this).push_front(val); for (; i != n; ++i) (*this).push_back(val); } template template void deque::deque_aux(Iterator first, Iterator last, std::false_type){//插入区间[first,last]的值 difference_type mid = (last - first) / 2; for (auto it = first + mid; it != first - 1; --it) (*this).push_front(*it); for (auto it = first + mid + 1; it != last; ++it) (*this).push_back(*it); } (2)分配空间 template T *deque::getANewBuck(){ return dataAllocator::allocate(getBuckSize()); } template T** deque::getANewMap(const size_t size){ T **map = new T*[size]; for (int i = 0; i != size; ++i) map[i] = getANewBuck(); return map; } (3)申请空间和赋值 template void deque::reallocateAndCopy(){ auto newMapSize = getNewMapSize(mapSize_); T** newMap = getANewMap(newMapSize);//获取空间 size_t startIndex = newMapSize / 4;//增加1/4的空间 for (int i = 0; i + beg_.mapIndex_ != mapSize_; ++i) for (int j = 0; j != getBuckSize(); ++j)//把map 转移到 newmap newMap[startIndex + i][j] = map_[beg_.mapIndex_ + i][j]; size_t n = beg_.cur_ - map_[beg_.mapIndex_]; auto size = this->size(); auto b = beg_, e = end_; clear();//释放map mapSize_ = newMapSize;//newmap 赋值给 map map_ = newMap; beg_ = iterator(startIndex, newMap[startIndex] + n, this); end_ = beg_ + size; } deque 基本操作 插入 添加到尾部 template void deque::push_back(const value_type& val){ if (empty()){//如果空，初始化 init(); } else if (back_full()){//如果满了，申请空间 reallocateAndCopy(); } mySTL::construct(end_.cur_, val); ++end_; } 添加到头部 template void deque::push_front(const value_type& val){ if (empty()){ init(); } else if (front_full()){ reallocateAndCopy(); } --beg_; construct(beg_.cur_, val); } 删除 删除尾部 template void deque::pop_front(){ --end_;//尾部前移以为 dataAllocator::destroy(end_.cur_);//释放末尾空间 } 删除头部 template void deque::pop_back(){ dataAllocator::destroy(beg_.cur_); ++beg_; } 遍历 返回头部元素 template typename deque::iterator deque::begin(){ return beg_; } template typename deque::iterator deque::begin()const{ return beg_; } 返回尾部元素 template typename deque::iterator deque::end()const{ return end_; } template typename deque::iterator deque::end(){ return end_; } 实例测试 #include #include \"Deque.h\" void print(mySTL::deque temp){ mySTL::deque::iterator it = temp.begin(); for(; it != temp.end();it++) std::cout val; val.push_back(1); val.push_back(4); val.push_back(7); std::cout val1(val); print(val1); std::cout在命令行中执行如下代码： g++ dequetest.cpp -std=c++11 -o dequetest -I ../include OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:42:29 "},"practice/chap3/3_10.html":{"url":"practice/chap3/3_10.html","title":"容器适配器","keywords":"","body":" 容器适配器 知识点 bitset stack queue priority_queue bitset bitset 是 STL 的一部分，准确地说，bitset 是一个模板类，它的模板参数不是类型，而是整形的数，有了它我们可以像使用数组一样使用类。在 include 目录下创建 Bitset.h。 初始化 无参构造 bitset() try:head(0) { //计算分配的字节数，如SIZE 为10则分配2个字节就可以了，剩余6位。（16-10） // 以下同理可得 head = new UCHAR[get_pos(size()) + 1]; std::memset(head,0,get_pos(size()) + 1); // } catch(...){ #ifdef _DEBUG std::cerr 带参构造(无符号数) explicit bitset(ULONG val) // unsigned long 版本 try:head(0){ head = new UCHAR[get_pos(size()) + 1]; std::memset(head,0,get_pos(size()) + 1); for(size_type i = 0; i 带参构造(字符型) explicit bitset(const std::string& str,size_type pos = 0,size_type n = std::string::npos) try:head(0){ head = new UCHAR[get_pos(size()) + 1]; //分配字节数 std::memset(head,0,get_pos(size()) + 1); //清0 assert(n == std::string::npos || pos + n str.size()) n = str.size() - pos; for(size_type i = 0,j = pos + n; i = pos + 1; ){ assert(str[j-1] == '0' || str[j-1] == '1'); #ifdef NDEBUG if(str[j-1] != '0' && str[j-1] != '1') throw mySTL::invalid_argument_1(); //非法参数，抛出异常 #endif set(head,i++,str[--j] == '1'); } } catch(...){ #ifdef _DEBUG std::cerr 拷贝构造 bitset(const self& temp):head(0){ head = new UCHAR[get_pos(size()) + 1]; std::memcpy(head,temp.head,get_pos(size()) + 1); } 析构 ~bitset(){ delete [] head; } 成员函数 bitset 所需要的成员函数较多，这里不一一例举，讲解几个常用函数。更多内容请参考附件 Bitset.h。 重载 [], 以数组方式访问 const_reference operator [] (size_type pos) const { assert(pos count 返回 1 的个数 size_type count() const { size_type m_count = 0; for(size_type i = 0; i size 返回集合大小 size_type size() const { return SIZE; } test 测试某一位是否是 1 bool test(size_t pos) const{ assert(pos set 将一个 bit 设为 1 self& set(size_type pos, bool val = true){ assert(pos reset 将一个 bit 设为 0 self& reset(size_type pos){ assert(pos flip 翻转该 bit 的值（求反） self& flip(){ size_type pos = get_pos(size()); //获取所有地址 for(size_type i = 0; i 辅助成员函数 read: 判断 1 或 0,要和 self& read 区分开 bool read(void *ptr,size_type pos) { assert(ptr != 0); unsigned char *pointer = (unsigned char*)ptr; size_type subpos = (pos + 7)/ 8 - 1; size_type index = (pos + 7) % 8 + 1; char tmp_val = (pointer[subpos] >> (index - 1) ) & char(1) ; return tmp_val > 0; } set: 置 1，与 self& set 区分 void* set(void* ptr,size_type pos,bool val = true){ //一般性的函数，处理数组中单个值的单个bit的设定 assert(ptr != 0); unsigned char *pointer = (unsigned char*)ptr; size_type subpos = (pos + 7)/ 8 - 1; size_type index = (pos + 7) % 8 + 1; if(val) set_true(pointer[subpos],index); else set_false(pointer[subpos],index); return ptr; } get_pos: 获取字节 size_type get_pos(size_type pos) const // 从0开始 { // 举例说明，低位到高位假如有10位1000 0001 11 则最后一位getpos的结果为1, // 是第二个字节，getsub则是1 return pos / 8; } get_sub: 获取数的位置 size_type get_sub(size_type pos) const // 从0开始 { return pos % 8; } bitset实例测试 在 Test 目录下创建 bitsettest.cpp，测试一下代码。 #include #include \"Bitset.h\" int main(){ mySTL::bitset bit(0x0153cefa); for(int i = 0;i 在命令行中执行如下代码： g++ bitsettest.cpp -std=c++11 -o bitsettest -I ../include stack stack 类允许在底层数据结构的一端执行插入和删除操作（先入后出）。堆栈能够用任何序列容器实现：vector、list、deque。 首先在 include 目录下创建 Stack.h. 初始化 构造 explicit stack(const container_type& ctnr = container_type()) :container_(ctnr){} 成员函数 empty 判断是否为空 bool empty() const{ return container_.empty(); } size 返回元素个数 size_type size() const{ return container_.size(); } 返回栈顶 value_type& top(){ return (container_.back()); } const value_type& top() const{ return (container_.back()); } void push(const value_type& val){ container_.push_back(val); } 入栈 void push(const value_type& val){ container_.push_back(val); } 出栈 void pop(){ container_.pop_back(); } 交换 void swap(stack& x){ mySTL::swap(container_, x.container_); } stack实例测试 完成上面的构造后，我们在 Test 目录下创建 stacktest.cpp，来测试一下。 #include #include \"Stack.h\" void print(mySTL::stack temp){ while(!temp.empty()){ std::cout stc; stc.push(3); stc.push(4); stc.push(2); stc.push(5); stc.push(7); std::coutqueue queue 类允许在底层数据结构的末尾插入元素，也允许从前面插入元素（先入先出）。 队列能够用 STL 数据结构的 list 和 deque 实现，默认情况下是用 deque 实现的。 首先需要在 include 目录下创建 Queue.h. 初始化 无参构造 queue(){} 传参构造 explicit queue(const container_type& ctnr) :container_(ctnr){} 成员函数 empty: 判断是否为空 bool empty() const{ return container_.empty(); } size: 返回元素个数 size_type size() const{ return container_.size(); } front: 返回头部 reference& front(){ return container_.front(); } const_reference& front() const{ return container_.front(); } 返回尾部 reference& back(){ return container_.back(); } const_reference& back() const{ return container_.back(); } 进队 void push(const value_type& val){ container_.push_back(val); } 出队 void pop(){ container_.pop_front(); } 交换队列元素 void swap(queue& x){ container_.swap(x.container_); } queue实例测试 在 Test 目录下创建 queuetest.cpp,来测试一下功能。 #include #include \"Queue.h\" void print(mySTL::queue temp){ while(!temp.empty()){ std::cout stc; stc.push(3); stc.push(4); stc.push(2); stc.push(5); stc.push(7); std::cout在命令行中执行如下代码： g++ queuetest.cpp -std=c++11 -o queuetest -I ../include priority_queues 优先级队列 priority_queue 是允许用户以任意顺序将元素放入容器，但是取出元素时一定是从最高优先级的元素开始取出。默认值大的优先级高。 priority_queues 和 queue 非常相似，所以我们不要重新创建头文件，直接写在 Queue.h 中就可以。 初始化 无参构造,优先级以函数对象方式 explicit priority_queue(const Compare& comp = Compare(), const Container& ctnr = Container()) : container_(ctnr), compare_(comp){} 传参构造 template priority_queue(InputIterator first, InputIterator last, const Compare& comp = Compare(), const Container& ctnr = Container()) : container_(ctnr), compare_(comp){ container_.insert(container_.end(), first, last);//插入元素 mySTL::make_heap(container_.begin(), container_.end());//创建堆 } 成员函数 empty:判断是否为空 bool empty() const{ return container_.empty(); } size:返回元素个数 size_type size() const{ return container_.size(); } top:返回头 reference top() { return container_.front(); } push:进队 void push(const value_type& val){ container_.push_back(val); } pop:出队 void pop(){ container_.pop_front(); } swap+交换 void swap(queue& x){ container_.swap(x.container_); } priority_queuestest实例测试 完成了上述操作，我们在 Test 目录下创建 priority_queuestest.cpp,来测试。 #include #include \"Queue.h\" void print(mySTL::priority_queue temp){ //打印 while(!temp.empty()){ std::cout stc; //定义一个优先队列 stc.push(3); stc.push(4); stc.push(2); stc.push(5); stc.push(7); std::cout在命令行中执行如下代码： g++ priority_queuetest.cpp -std=c++11 -o priority_queuetest -I ../include OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_11.html":{"url":"practice/chap3/3_11.html","title":"容器之 set 和 multiset","keywords":"","body":" 容器之 set 和 multiset 知识点 关联容器介绍 两种容器的构造 成员函数 两种容器的基本操作 关联容器介绍 C++ 的容器类型可以分为顺序容器和关联容器两大类。顺序容器我们前面的使用已经介绍了 vector、list 和 deque，现在我们介绍一下关联容器。关联容器支持通过键值来高效的查找和读取元素，这是它和顺序容器最大的区别。两种基本的关联容器类型是 map 和 set,衍生类型有 multimap 和 multiset 下面给出四种类型差别： map 关联数组；元素通过键来存储和读取 set 大小可变的集合，支持通过键实现快速读取 multimap 支持同一个键多次出现的map类型 multiset 支持同一个键多次出现的set类型 本次实验主要讲述 set 和 multiset。 set set 的构造 因为 multiset 和 set 基本相似，所以我们这里只讲 set，在第六小节我们会讲 multiset 的个别区别，我们先在 include 目录选创建 Set.h。 成员变量 public: typedef Key key_type; //键值 typedef Key value_type; //数值 typedef Compare key_compare; //键值比较 typedef Compare value_compare; //数值比较 private: typedef RBtree, key_compare> RBtree_type; //利用红黑树传参 RBtree_type tree; //定义红黑树 public: typedef typename RBtree_type::const_iterator iterator; //迭代器 typedef typename RBtree_type::size_type size_type; typedef typename RBtree_type::iterator tree_iterator; 无参构造 set(){} 传参构造 set(const set& x):tree(x.tree){} 区间构造,把 first 到 last 去加元素传递给 set template set(InputIterator first,InputIterator last){ tree.insert_unique(first,last);} set基本操作 set 容器中的键值是 const，在获取 set 容器中的某个元素迭代器后，只能对其做读操作，而不能做写操作。 返回头部迭代器 iterator begin()const {return tree.begin();} 返回尾部迭代器 iterator end()const {return tree.end();} 判断是否为空 bool empty()const {return tree.empty();} 返回元素个数 size_type size()const {return tree.size();} 交换 set 元素 void swap(set& x) {tree.swap(x.tree);} 插入 通过 pair 插入一个值 pair insert(const value_type& x) //pair 类型定义在 utility.h 中 { pair p = tree.insert_unique(x); //set 插入使用 insert_unique return pair(p.first,p.second);//返回数值 } 插入某个区间的值 template void insert(InputIterator first,InputIterator last){ tree.insert_unique(first,last);//利用红黑树插入 } 删除 删除某个位置的值 void erase(iterator position){ tree.erase((tree_iterator&)position); } 删除某个确认的值 size_type erase(const key_type& x){ return tree.erase(x); } 清空 void clear() {tree.clear();} set迭代器相关 查找具体数值 iterator find(const key_type& x) { return tree.find(x);} 记数 size_type count(const key_type& x) { return tree.count(x);} 返回一个 iterator 从数组的 begin 位置到 end-1 位置二分查找第一个大于或等于 x 的数字 iterator lower_bound(const key_type& x) {return tree.lower_bound(x);} 从数组的 begin 位置到 end-1 位置二分查找第一个大于 num 的数字 iterator upper_bound(const key_type& x) {return tree.upper_bound(x);} 返回一对迭代器 返回 lower_bound 和 upper_bound pair equal_range(const key_type& x) {return tree.equal_range(x);} Multiset Multiset构造 在 include 目录下创建 Multiset.h 。multiset 和 set 是极其相似的，只有个别部分不同，这里就讲一下 不同的地方。 构造方式 set 使用的 insert_unique 函数，这样 set 的键值就不允许重复。 multiset 使用的 insert_equal 函数，这样允许 multiset 的键值重复。 插入方式 set 使用 pair insert(const value_type& x)返回的是键值 multiset 使用 iterator insert(const value_type& x) 返回的是迭代器 set实例测试 创建 settest.cpp #include #include \"Set.h\" int main(){ int i; int arr[6] = {4,2,7,1,9,8}; //定义一个数组 std::cout iset(arr,arr+6); //创建一个set容器 std::cout::iterator it; for(it = iset.begin ();it != iset.end ();it++) //打印set { std::cout在命令行中执行如下命令： g++ settest.cpp -std=c++11 -o settest -I ../include multiset实例测试 创建 multisettest.cpp。 #include #include \"Multiset.h\" int main(){ mySTL::multiset imultiset; //定义一个multiset imultiset.insert(1); //插入5个值 imultiset.insert(2); imultiset.insert(1); imultiset.insert(4); imultiset.insert(4); std::cout在命令行中执行如下命令： g++ multisettest.cpp -std=c++11 -o multisettest -I ../include OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_12.html":{"url":"practice/chap3/3_12.html","title":"map 和 multimap","keywords":"","body":" map 和 multimap 知识点 容器作用和介绍 容器的构造 成员函数 基本操作 作用和介绍 Map 是 STL 的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字 key 只能在 map 中出现一次，第二个可能称为该关键字的值 data）的数据处理能力，由于这个特性，它完全有可能在我们处理一对一数据的时候，在编程上提供快速通道。 和 set/multiset 类似，map/multimap key 不能改，但是 data 可以改,因此 map 仍然具有自动排序的功能。 map 的 key 必须独一无二,而 multimap 的 key 可以重复。 容器的构造 因为 multimap 和 map 基本相似，所以我们这里只讲 map，在第六小节我们会将 multimap 的个别区别，我们先在 include 目录创建 Map.h。 成员变量 public: typedef Key key_type; //键值 typedef Key value_type; //数值 typedef T mapped_type; //map 类型 typedef Compare key_compare; //键值比较 typedef Compare value_compare; //数值比较 private: typedef RBtree, key_compare> RBtree_type; //利用红黑树传参 RBtree_type tree; //定义红黑树 public: typedef typename RBtree_type::const_iterator iterator; //迭代器 typedef typename RBtree_type::size_type size_type; typedef typename RBtree_type::iterator tree_iterator; 无参构造 map(){} 传参构造 map(const map& x):tree(x.tree){} 区间构造,把 first 到 last 去加元素传递给 map template map(InputIterator first,InputIterator last){ tree.insert_unique(first,last);} 成员函数 返回头部迭代器 iterator begin()const {return tree.begin();} 返回尾部迭代器 iterator end()const {return tree.end();} 判断是否为空 bool empty()const {return tree.empty();} 返回元素个数 size_type size()const {return tree.size();} 交换 map 元素 void swap(map& x) {tree.swap(x.tree);} 访问符重载,允许下标访问 T& operator[](const key_type& k){ return (*((insert(value_type(k,T())).first))).second; } 清空 void clear() {tree.clear();} 基本操作 插入 通过 pair 插入一对数据 pair insert(const value_type& x){ return tree.insert_unique(x); } 插入某个区间的值 template void insert(InputIterator first,InputIterator last){ tree.insert_unique(first,last); } 删除 删除某个位置的值 void erase(iterator position){ tree.erase((tree_iterator&)position); } 删除某个确认的值 size_type erase(const key_type& x){ return tree.erase(x); } 查找 iterator find(const key_type& x) { return tree.find(x);}基本操作 插入 通过 pair 插入一对数据 pair insert(const value_type& x){ return tree.insert_unique(x); } 插入某个区间的值 template void insert(InputIterator first,InputIterator last){ tree.insert_unique(first,last); } 删除 删除某个位置的值 void erase(iterator position){ tree.erase((tree_iterator&)position); } 删除某个确认的值 size_type erase(const key_type& x){ return tree.erase(x); } 查找 iterator find(const key_type& x) { return tree.find(x);} Multimap 在 include 目录下创建 Multimap.h 。multimap 和 map 是极其相似的，只有个别部分不同，这里就讲一下 不同的地方。 构造方式 map 使用的 insert_unique 函数，这样 map 的键值就不允许重复。 multimap 使用的 insert_equal 函数，这样允许 multimap 的键值重复。 插入方式 map 使用 pair insert(const value_type& x) 返回的是键值和数据 multimap 使用 iterator insert(const value_type& x) 返回的是迭代器 map实例测试 首先在 Test 目录下创建 maptest.cpp #include #include \"Map.h\" int main(){ mySTL::map map; //定义一个map map.insert(mySTL::pair(\"zhangsan\",110)); //插入 map.insert(mySTL::pair(\"lisi\",120)); map.insert(mySTL::pair(\"wangwu\",130)); map.insert(mySTL::pair(\"mazi\",140)); const mySTL::pair value(std::string(\"pangdun\"),150);//定义一个pair map.insert(value); std::coutfirst secondsecondfirst second在命令行执行如下命令： g++ maptest.cpp -std=c++11 -o maptest -I ../include multimap实例测试 创建 multimap.cpp #include #include \"Multimap.h\" int main(){ mySTL::multimap mtmap; //定义一个multimap mtmap.insert(mySTL::pair(\"zhangsan\",110)); //插入键值和数值 mtmap.insert(mySTL::pair(\"lisi\",120)); mtmap.insert(mySTL::pair(\"wangwu\",130)); mtmap.insert(mySTL::pair(\"mazi\",140)); const mySTL::pair value(std::string(\"zhangsan\"),150);//定义一个pair mtmap.insert(value); //插入pair std::coutfirst secondsecondfirst secondOceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap3/3_13.html":{"url":"practice/chap3/3_13.html","title":"异常处理","keywords":"","body":" 异常处理 异常介绍 异常是程序在执行期间产生的问题，C++ 异常是指在程序运行时发生的特殊情况(如被零除情况或内存不足警告)。异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。 throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 举一个例子，将下面的代码写入 /home/shiyanlou/Code/exception.cpp 文件中： #include using namespace std; int division(int a,int b) { if(b == 0) throw \"除数不能为0\"; //抛出异常 return a/b; } int main() { int a,b; cout>a>>b; try// 保护代码 { cout语法 从上面的例子中我们不难看出异常操作的语法。 抛出异常: throw Exception 捕获异常: try { // 保护代码 }catch(...) { // 能处理任何异常的代码 } 常处理进阶 堆栈解退 当抛出了异常，但还没在特定的作用域中被捕获时，函数调用堆栈便被“解退”，并试图在下一个外层 try...catch 代码中捕获这个异常。解退函数调用堆栈意味着抛出未捕获异常的那个函数将终止，这个函数中的所有局部变量都将销毁，控制会返回到原先调用这个函数的语句。 实例, 将下面的代码写入 /home/shiyanlou/Code/test.cpp 文件中： #include using namespace std; void fun3() { cout 迷失 异常什么时候会迷失方向呢？ 意外异常：如果是在带异常规范的函数中引发的，则必须与规范列表里的某个异常匹配，若没有匹配的，则为意外异常，默认情况下，会导致程序异常终止 未捕获异常：如果不是在函数中引发的（或者函数没有异常规范），则它必须被捕获。如果没被捕获（没有 try 块或没有匹配的 catch 块），则为未捕获异常。默认情况下，将导致程序异常终止 #include #include #include using namespace std; int main() { int c; logic_error a(\"logic_error\"); //定义一个逻辑异常 range_error b(\"runtime_error\"); //定义一个作用域异常 try { cout>c; switch(c) { case 1: throw a; break; default: cout 局限性 全局对象在程序开始运行前进行构造，如果构造函数抛出异常，将永远无法捕获，析构也是如此，因为它们在程序结束后才会被调用，这些异常只有操作系统才可以捕获，应用程序没有办法。 对于局部对象，异常处理机制是所有从 try 到 throw 语句之间构造起来的局部对象的析构函数将被自动调用，然后清退栈堆（就像 main 函数退出那样），如果一直回溯到 main 函数后还是没有匹配到 catch 块，那么系统会调用 terminate() 终止整个程序，在这种情况下就不能保证局部对象会被正确的销毁了。 实现自己的异常处理 想要实现自己的异常处理函数库，需要派生基类 exception，然后自己定义虚函数 what()。 将下面的代码写入 /home/shiyanlou/Code/test2.cpp 文件中： #include #include using namespace std; class myexception : public exception //自定义一个异常类 { public: myexception(){} const char* what() { return \"There has an exception\"; } }; int division(int a,int b) { if(b == 0) throw myexception(); //抛出异常 return a/b; } int main() { int a,b; cout>a>>b; try// 保护代码 { coutOceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_0summary.html":{"url":"practice/chap4/4_0summary.html","title":"C++11&14","keywords":"","body":" C++11&14 C++ 算是一个用户群体比较大的语言了，从 C++ 98 到 C++ 11 经历了长达十年多之久的积累，C++ 14 则是作为对 C++ 11 的重要补充和优化，所有这些新标准中扩充的特性，给 C++ 这门语言注入了新的活力。 那些还在坚持使用 传统 C++ （本教程把 C++ 98 及其之前的 C++ 特性均称之为传统 C++）而未接触过 C++ 11 / 14 的 C++ 程序员在见到诸如 Lambda 表达式这类全新特性时，甚至会流露出『学的不是同一门语言』的惊叹之情。 C++ 1x （本教程中指 C++ 11 / 14, 甚至 C++ 17） 为传统 C++ 注入的大量特性使得整个 C++ 变得更加像一门现代化的语言。C++ 1x 不仅仅增强了 C++ 语言自身的可用性，auto 关键字语义的修改使得我们更加有信心来操控极度复杂的模板类型。同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python/Swift/... ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等。 C++ 1x 为自身的标准库增加了非常多的工具和方法，诸如在语言层面上提供了 std::thread 支持了并发编程，在不同平台上不再依赖于系统底层的 API，实现了语言层面的跨平台支持；std::regex提供了完整的正则表达式支持等等。 C++ 98 已经被实践证明了是一种非常成功的『范型』，而 C++ 1x 的出现，则进一步推动这种范型，让 C++ 成为系统程序设计和库开发更好的语言。 提示 提示：本课程所有代码至少需要开启 -std=c++11 选项来支持 C++ 11 相关特性，在介绍 C++ 14 特性时的相关代码需要开启 -std=c++14 的编译选项，例如： $ g++ main.cpp -std=c++11 $ g++ main.cpp -std=c++14 推荐所有代码均使用 -std=c++14 选项进行编译。 Part 1 C++11/14 简介 概述 教程目录 被弃用的特性 与 C 的兼容性 Part 2 语言可用性的强化 nullptr 与 constexpr 类型推导 auto decltype 尾返回类型、auto 与 decltype 配合 区间迭代 基于范围的 for 循环 初始化列表 std::initializer_list 统一初始化语法 模板增强 外部模板 尖括号 > 类型别名模板 变长参数模板 面向对象增强 委托构造 继承构造 显式虚函数重载 override final 显式禁用默认函数 强类型枚举 Part 3 语言运行期的强化 lambda 表达式 lambda 表达式基础 值捕获 引用捕获 隐式捕获 表达式捕获 泛型 lambda 函数对象包装器 std::function std::bind/std::placeholder 右值引用 左值、右值的纯右值、将亡值、右值 右值引用和左值引用 移动语义 完美转发 Part4 对标准库的扩充: 新增容器 std::array std::forward_list std::unordered_set std::unordered_map std::tuple 基本操作 运行期索引 合并与迭代 Part 5 对标准库的扩充: 智能指针和引用计数 引用计数 std::shared_ptr std::make_shared std::unique_ptr std::weak_ptr Part 6 对标准库的扩充: 正则表达式库 正则表达式简介 普通字符 特殊字符 限定符 std::regex 及其相关 std::regex std::regex_match std::match_results Part 7 对标准库的扩充: 语言级线程支持 std::thread std::mutex std::unique_lock std::future std::packaged_task std::condition_variable Part 8 其他杂项 新类型 long long int noexcept 的修饰和操作 字面量 原始字符串字面量 自定义字面量 Part 9 扩展主题: C++17 简介 主要入选特性 非类型模板参数的 auto std::variant<> 结构化绑定(Structured bindings) 变量声明的强化 未入选特性 Concepts 从 C++ 11 开始，被弃用的主要特性： 注意：弃用不等于废弃，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，这些特性其实会『永久』保留。 弃用的特性（1）：如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。** 弃用的特性（2）：不再允许字符串字面值常量赋值给一个 char 。如果需要用字符串字面值常量赋值和初始化一个 char ，应该使用 const char * 或者 auto。 char *str = \"hello world!\"; // 将出现弃用警告 弃用的特性（3）：C++98 异常说明、 unexpected_handler、set_unexpected() 等相关特性被弃用，应该使用 noexcept。** 弃用的特性（4）：auto_ptr 被弃用，应使用 unique_ptr。 弃用的特性（5）：register 关键字被弃用。 弃用的特性（6）：bool 类型的 ++ 操作被弃用。 弃用的特性（7）：C 语言风格的类型转换被弃用，应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换。 还有一些其他诸如参数绑定（C++11 提供了 std::bind 和 std::function）、export 等特性也均被弃用。前面提到的这些特性如果你从未使用或者听说过，也请不要尝试去了解他们，应该向新标准靠拢，直接学习新特性。毕竟，技术是向前发展的。 与 C 的兼容性 出于一些不可抗力、历史原因，我们不得不在 C++ 中使用一些 C 语言代码（甚至古老的 C 语言代码），例如 Linux 系统调用。在 C++11 出现之前，大部分人当谈及 『C 与 C++ 的区别是什么』时，普遍除了回答面向对象的类特性、泛型编程的模板特性外，就没有其他的看法了，甚至直接回答『差不多』，也是大有人在。下面的韦恩图大致上回答了 C 和 C++ 相关的兼容情况： 从现在开始，你的脑子里应该树立 『C++ 不是 C 的一个超集』 这个观念（而且从一开始就不是）。 在编写 C++ 时，也应该尽可能的避免使用诸如 void* 之类的程序风格。而在不得不使用 C 时，应该注意使用 extern \"C\" 这种特性，将 C 语言的代码与 C++ 代码进行分离编译，再统一链接这种做法，例如： 头文件 foo.h // foo.h #ifdef __cplusplus extern \"C\" { #endif int add(int x, int y); #ifdef __cplusplus } #endif 源文件 foo.c // foo.c int add(int x, int y) { return x+y; } 源文件 main.cpp // main.cpp #include \"foo.h\" int main() { add(1, 2); return 0; } 应先使用 gcc 编译 C 语言的代码： gcc -c foo.c 编译出 foo.o 文件，再使用 g++ 将 C++代码和 .o 文件链接起来（或者都编译为 .o 再统一链接）： g++ main.cpp foo.o -o main OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_1.html":{"url":"practice/chap4/4_1.html","title":"语言可用性的强化","keywords":"","body":" 语言可用性的强化 nullptr 与 constexpr （1）nullptr nullptr 出现的目的是为了替代 NULL。在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。 C++ 不允许直接将 void 隐式转换到其他类型，但如果 NULL 被定义为 ((void)0)，那么当编译 char *ch = NULL; 时，NULL 只好被定义为 0。而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱，考虑： void foo(char *); void foo(int); 对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。 为了解决这个问题，C++ 11 引入了 nullptr 关键字，专门用来区分空指针、0。nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。 你可以尝试使用 g++ 编译下面的代码： #include void foo(char *); void foo(int); int main() { if(NULL == (void *)0) std::cout 将输出： NULL == 0 call foo(int) call foo(char*) 当我们加上注释中的 foo(NULL) 将编译无法通过： foo.cpp: In function ‘int main()’: foo.cpp:10:13: error: call of overloaded ‘foo(NULL)’ is ambiguous foo(NULL); // 编译无法通过 ^ foo.cpp:2:6: note: candidate: void foo(char*) void foo(char *); ^ foo.cpp:3:6: note: candidate: void foo(int) void foo(int); 所以，当需要使用 NULL 时候，请养成直接使用 nullptr 的习惯。 （2）constexpr C++ 本身已经具备了常数表达式的概念，比如 1+2、3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。 一个非常显著的例子就是在数组的定义阶段： #define LEN 10 int len_foo() { return 5; } int main() { char arr_1[10]; char arr_2[LEN]; int len = 5; char arr_3[len+5]; // 非法 const int len_2 = 10; char arr_4[len_2+5]; // 合法 char arr_5[len_foo()+5]; // 非法 return 0; } 在 C++11 之前，可以在常量表达式中使用的变量必须被声明为 const，在上面代码中，len_2 被定义成了常量，因此 len_2+5 是一个常量表达式，所以能够合法的分配一个数组； 而对于 arr_5 来说，C++98 之前的编译器无法得知 len_foo() 在运行期实际上是返回一个常数，这也就导致了非法的产生。 C++ 11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译器会成为常数，这个关键字明确的告诉编译器应该去验证 len_foo 在编译器就应该是一个常数。 此外，constexpr 的函数可以使用递归： constexpr int fibonacci(const int n) { return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2); } 从 C++ 14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句，但 C++ 11 中是不可以的。例如下面的代码在 C++ 11 的标准下是不能够通过编译的： constexpr int fibonacci(const int n) { if(n == 1) return 1; if(n == 2) return 1; return fibonacci(n-1)+fibonacci(n-2); } 类型推导 在传统 C 和 C++中，参数的类型都必须明确定义，这其实对我们快速进行编码没有任何帮助，尤其是当我们面对一大堆复杂的模板类型时，必须明确的指出变量的类型才能进行后续的编码，这不仅拖慢我们的开发效率，也让代码变得又臭又长。 C++ 11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。 （1）auto auto 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 register 并存。在传统 C++ 中，如果一个变量没有声明为 register 变量，将自动被视为一个 auto 变量。而随着 register 被弃用，对 auto 的语义变更也就非常自然了。 使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。在以前我们需要这样来书写一个迭代器： for(vector::const_iterator itr = vec.cbegin(); itr != vec.cend(); ++itr) 而有了 auto 之后可以： // 由于 cbegin() 将返回 vector::const_iterator // 所以 itr 也应该是 vector::const_iterator 类型 for(auto itr = vec.cbegin(); itr != vec.cend(); ++itr); 一些其他的常见用法： auto i = 5; // i 被推导为 int auto arr = new auto(10) // arr 被推导为 int * 注意：auto 不能用于函数传参，因此下面的做法是无法通过编译的（考虑重载的问题，我们应该使用模板）： int add(auto x, auto y); 此外，auto 还不能用于推导数组类型： #include int main() { auto i = 5; int arr[10] = {0}; auto auto_arr = arr; auto auto_arr2[10] = arr; return 0; } （2）decltype decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。 它的用法和 sizeof 很相似： decltype(表达式) 在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。 有时候，我们可能需要计算某个表达式的类型，例如： auto x = 1; auto y = 2; decltype(x+y) z; // z 是一个 int 型的 （3）尾返回类型、auto 与 decltype 配合 你可能会思考，auto 能不能用于推导函数的返回类型。考虑这样一个例子加法函数的例子，在传统 C++ 中我们必须这么写： template R add(T x, U y) { return x+y } typename 和 class 在模板中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的 这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 add() 这个函数会做什么样的操作，获得一个什么样的返回类型。 在 C++11 中这个问题得到解决。虽然你可能马上回反应出来使用 decltype 推导 x+y 的类型，写出这样的代码： decltype(x+y) add(T x, U y); 但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定义。为了解决这个问题，C++ 11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键字将返回类型后置： template auto add(T x, U y) -> decltype(x+y) { return x+y; } 令人欣慰的是从 C++ 14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法： template auto add(T x, U y) { return x+y; } 区间迭代 区间迭代是指基于范围的 for 循环。 终于，C++ 11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句： int array[] = {1,2,3,4,5}; for(auto &x : array) { std::cout 最常用的 std::vector 遍历将从原来的样子： std::vector arr(5, 100); for(std::vector::iterator i = arr.begin(); i != arr.end(); ++i) { std::cout 变得非常的简单： // & 启用了引用, 如果没有则对 arr 中的元素只能读取不能修改 for(auto &i : arr) { std::cout 初始化列表 初始化是一个非常重要的语言特性，最常见的就是对对象进行初始化。在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、POD （plain old data，没有构造、析构和虚函数的类或结构体）类型都可以使用 {} 进行初始化，也就是我们所说的初始化列表。而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 () 进行。这些不同方法都针对各自对象，不能通用。 int arr[3] = {1,2,3}; // 列表初始化 class Foo { private: int value; public: Foo(int) {} }; Foo foo(1); // 普通构造初始化 为了解决这个问题，C++11 首先把初始化列表的概念绑定到了类型上，并将其称之为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如： #include class Magic { public: Magic(std::initializer_list list) {} }; Magic magic = {1,2,3,4,5}; std::vector v = {1, 2, 3, 4}; 这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。 初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如： void func(std::initializer_list list) { return; } func({1,2,3}); 其次，C++11 提供了统一的语法来初始化任意的对象，例如： struct A { int a; float b; }; struct B { B(int _a, float _b): a(_a), b(_b) {} private: int a; float b; }; A a {1, 1.1}; // 统一的初始化语法 B b {2, 2.2}; 模板增强 （1）外部模板 传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。 C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化： template class std::vector; // 强行实例化 extern template class std::vector; // 不在该编译文件中实例化模板 （2）尖括号 \">\" 在传统 C++ 的编译器中，>>一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码： std::vector> wow; 这在传统 C++ 编译器下是不能够被编译的，而 C++ 11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。 （3）类型别名模板 在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：模板是用来产生类型的。在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如： template class SuckType { public: T a; U b; SuckType():a(value),b(value){} }; template typedef SuckType, U, 1> NewType; // 不合法 C++ 11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效： 通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。 typedef int (*process)(void *); // 定义了一个返回类型为 int，参数为 void* 的函数指针类型，名字叫做 process using process = int(*)(void *); // 同上, 更加直观 template using NewType = SuckType; // 合法 （4）默认模板参数 我们可能定义了一个加法函数： template auto add(T x, U y) -> decltype(x+y) { return x+y } 但在使用时发现，要使用 add，就必须每次都指定其模板参数的类型。 在 C++11 中提供了一种便利，可以指定模板的默认参数： template auto add(T x, U y) -> decltype(x+y) { return x+y; } （5）变长参数模板 模板一直是 C++ 所独有的黑魔法（一起念：Dark Magic）之一。在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。 template class Magic; 模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义： class Magic, std::map>> darkMagic; 既然是任意形式，所以个数为 0 的模板参数也是可以的：class Magic<> nothing;。 如果不希望产生的模板参数个数为 0，可以手动的定义至少一个模板参数： template class Magic; 变长参数模板也能被直接调整到到模板函数上。传统 C 中的 printf 函数，虽然也能达成不定个数的形参的调用，但其并非类别安全。而 C++11 除了能定义类别安全的变长参数函数外，还可以使类似 printf 的函数能自然地处理非自带类别的对象。除了在模板参数中能使用 ... 表示不定长模板参数外，函数参数也使用同样的表示法代表不定长参数，这也就为我们简单编写变长参数函数提供了便捷的手段，例如： template void printf(const std::string &str, Args... args); 那么我们定义了变长的模板参数，如何对参数进行解包呢？ 首先，我们可以使用 sizeof... 来计算参数的个数，： template void magic(Args... args) { std::cout 我们可以传递任意个参数给 magic 函数： magic(); // 输出0 magic(1); // 输出1 magic(1, \"\"); // 输出2 其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法： 递归模板函数 递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归的向函数传递模板参数，进而达到递归遍历所有模板参数的目的： #include template void printf(T value) { std::cout void printf(T value, Args... args) { std::cout 初始化列表展开 这个方法需要之后介绍的知识，读者可以简单阅读以下，将这个代码段保存，在后面的内容了解过了之后再回过头来阅读此处方法会大有收获。 递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。 这里介绍一种使用初始化列表展开的黑魔法： // 编译这个代码需要开启 -std=c++14 // 因为版本原因，实验环境中的 g++ 尚不支持此特性，此处可以使用 clang++ 替代 g++ template auto print(T value, Args... args) { std::cout {([&] { std::cout 在这个代码中，额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性（下一节中将提到），而 std::initializer_list 也是 C++11 新引入的容器（以后会介绍到）。 通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。唯一不美观的地方在于如果不使用 return 编译器会给出未使用的变量作为警告。 事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 std::bind 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。 面向对象增强 （1）委托构造 C++ 11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的： class Base { public: int value1; int value2; Base() { value1 = 1; } Base(int value) : Base() { // 委托 Base() 构造函数 value2 = 2; } }; int main() { Base b(2); std::cout （2）继承构造 在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++ 11 利用关键字 using 引入了继承构造函数的概念： class Base { public: int value1; int value2; Base() { value1 = 1; } Base(int value) : Base() { // 委托 Base() 构造函数 value2 = 2; } }; class Subclass : public Base { public: using Base::Base; // 继承构造 }; int main() { Subclass s(3); std::cout （3）显式虚函数重载 在传统 C++ 中，经常容易发生意外重载虚函数的事情。例如： struct Base { virtual void foo(); }; struct SubClass: Base { void foo(); }; SubClass::foo 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。 C++ 11 引入了 override 和 final 这两个关键字来防止上述情形的发生。 （4）override 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译： struct Base { virtual void foo(int); }; struct SubClass: Base { virtual void foo(int) override; // 合法 virtual void foo(float) override; // 非法, 父类没有此虚函数 }; （5）final final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。 struct Base { virtual void foo() final; }; struct SubClass1 final: Base { }; // 合法 struct SubClass2 : SubClass1 { }; // 非法, SubClass 已 final struct SubClass3: Base { void foo(); // 非法, foo 已 final }; （6）显式禁用默认函数 在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、复制构造、赋值算符以及析构函数。另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。当程序员有需要时，可以重载这部分函数。 这就引发了一些需求：无法精确控制默认函数的生成行为。例如禁止类的拷贝时，必须将赋值构造函数与赋值算符声明为 private。尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。 并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。若用户定义了任何构造函数，编译器将不再生成默认构造函数，但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。 C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数。例如： class Magic { public: Magic() = default; // 显式声明使用编译器生成的构造 Magic& operator=(const Magic&) = delete; // 显式声明拒绝编译器生成构造 Magic(int magic_number); } 强类型枚举 在传统 C++ 中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），甚至枚举类型的枚举值名字不能相同，这不是我们希望看到的结果。 C++ 11 引入了枚举类（enumaration class），并使用 enum class 的语法进行声明： enum class new_enum : unsigned int { value1, value2, value3 = 100, value4 = 100 }; copy 这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较，更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较： if (new_enum::value3 == new_enum::value4) { // 会输出 std::cout 而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 #include template std::ostream& operator::value, std::ostream>::type& stream, const T& e) { return stream ::type>(e); } 这时，下面的代码将能够被编译： std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_2.html":{"url":"practice/chap4/4_2.html","title":"语言运行期的强化","keywords":"","body":" 语言运行期的强化 Lambda 表达式 Lambda 表达式是 C++ 11 中最重要的新特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多，所以匿名函数几乎是现代编程语言的标配。 （1）Lambda 表达式基础 Lambda 表达式的基本语法如下： [捕获列表](参数列表) mutable(可选) 异常属性 -> 返回类型 { // 函数体 } [ caputrue ] ( params ) opt -> ret { body; }; 上面的语法规则除了 [捕获列表] 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去，返回值使用了一个 -> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。 所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种： 值捕获 与参数传值类似，值捕获的前期是变量可以拷贝，不同之处则在于，被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝： void learn_lambda_func_1() { int value_1 = 1; auto copy_value_1 = [value_1] { return value_1; }; value_1 = 100; auto stored_value_1 = copy_value_1(); // 这时, stored_value_1 == 1, 而 value_1 == 100. // 因为 copy_value_1 在创建时就保存了一份 value_1 的拷贝 cout 引用捕获 与引用传参类似，引用捕获保存的是引用，值会发生变化。 void learn_lambda_func_2() { int value_2 = 1; auto copy_value_2 = [&value_2] { return value_2; }; value_2 = 100; auto stored_value_2 = copy_value_2(); // 这时, stored_value_2 == 100, value_1 == 100. // 因为 copy_value_2 保存的是引用 cout 隐式捕获 手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 & 或 = 向编译器声明采用 引用捕获或者值捕获. 总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是： [] 空捕获列表 [name1, name2, ...] 捕获一系列变量 [&] 引用捕获, 让编译器自行推导捕获列表 [=] 值捕获, 让编译器执行推导应用列表 表达式捕获（C++ 14） 这部分内容需要了解后面马上要提到的右值引用以及智能指针 上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。 C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的： #include #include void learn_lambda_func_3(){ auto important = std::make_unique(1); auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -> int { return x+y+v1+(*v2); }; std::cout 在上面的代码中，important 是一个独占指针，是不能够被捕获到的，这时候我们需要将其转移为右值，在表达式中初始化。 （2）泛型 Lambda (C++ 14) 上一节中我们提到了 auto 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。这就为我们造成了一定程度上的麻烦：参数表不能够泛化，必须明确参数表类型。 幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型： void learn_lambda_func_4(){ auto generic = [](auto x, auto y) { return x+y; }; std::cout 函数对象包装器 这部分内容虽然属于标准库的一部分，但是从本质上来看，它却增强了 C++ 语言运行时的能力，这部分内容也相当重要，所以放到这里来进行介绍。 （1）std::function Lambda 表达式的本质是一个函数对象，当 Lambda 表达式的捕获列表为空时，Lambda 表达式还能够作为一个函数指针进行传递，例如： #include using foo = void(int); // 定义函数指针, using 的使用见上一节中的别名语法 void functional(foo f) { f(1); } int main() { auto f = [](int value) { std::cout 上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数指针传递进行调用，而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型，统一称之为可调用类型。而这种类型，便是通过 std::function 引入的。 C++11 std::function 是一种通用、多态的函数封装，它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，它也是对 C++中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的），换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。例如： #include #include int foo(int para) { return para; } int main() { // std::function 包装了一个返回值为 int, 参数为 int 的函数 std::function func = foo; int important = 10; std::function func2 = [&](int value) -> int { return 1+value+important; }; std::cout （2）std::bind/std::placeholder 而 std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。例如： int foo(int a, int b, int c) { ; } int main() { // 将参数1,2绑定到函数 foo 上，但是使用 std::placeholders::_1 来对第一个参数进行占位 auto bindFoo = std::bind(foo, std::placeholders::_1, 1,2); // 这时调用 bindFoo 时，只需要提供第一个参数即可 bindFoo(1); } 提示：注意 auto 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型，但是我们却可以通过 auto 的使用来规避这一问题的出现。 右值引用 右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大量的历史遗留问题，消除了诸如 std::vector、std::string 之类的额外开销，也才使得函数对象容器 std::function 成为了可能。 （1）左值、右值的纯右值、将亡值、右值 要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。 左值(lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说，左值是表达式（不一定是赋值表达式）后依然存在的持久对象。 右值(rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。 而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。 纯右值(prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 10, true；要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。 将亡值(xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++中，纯右值和右值是统一个概念），也就是即将被销毁、却能够被移动的值。 将亡值可能稍有些难以理解，我们来看这样的代码： std::vector foo() { std::vector temp = {1, 2, 3, 4}; return temp; } std::vector v = foo(); 在这样的代码中，函数 foo 的返回值 temp 在内部创建然后被赋值给 v，然而 v 获得这个对象时，会将整个 temp 拷贝一份，然后把 temp 销毁，如果这个 temp 非常大，这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。在最后一行中，v 是左值、foo() 返回的值就是右值（也是纯右值）。 但是，v 可以被别的变量捕获到，而 foo() 产生的那个返回值作为一个临时值，一旦被 v 复制后，将立即被销毁，无法获取、也不能修改。 将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动。 （2）右值引用和左值引用 需要拿到一个将亡值，就需要用到右值引用的申明：T &&，其中 T 是类型。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。 C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象，例如： #include #include void reference(std::string& str) { std::cout 注意：rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。 （3）移动语义 传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、再把原来的东西全部销毁，这是非常反人类的一件事情。 传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据移动，浪费时间和空间。右值引用的出现恰好就解决了这两个概念的混淆问题，例如： #include class A { public: int *pointer; A() :pointer(new int(1)) { std::cout 在上面的代码中： 首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出； 函数返回后，产生一个将亡值，被 A 的移动构造（A(A&&)）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。 从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子： #include // std::cout #include // std::move #include // std::vector #include // std::string int main() { std::string str = \"Hello world.\"; std::vector v; // 将使用 push_back(const T&), 即产生拷贝行为 v.push_back(str); // 将输出 \"str: Hello world.\" std::cout （4）完美转发 前面我们提到了，一个声明的右值引用其实是一个左值。这就为我们进行参数转发（传递）造成了问题： void reference(int& v) { std::cout void pass(T&& v) { std::cout 对于 pass(1) 来说，虽然传递的是右值，但由于 v 是一个引用，所以同时也是左值。因此 reference(v) 会调用 reference(int&)，输出『左值』。而对于pass(v)而言，v是一个左值，为什么会成功传递给 pass(T&&) 呢？ 这是基于引用坍缩规则的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用，但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用，既能左引用，又能右引用。但是却遵循如下规则： 函数形参类型 实参参数类型 推导后函数形参类型 T& |左引用 |T& T& |右引用 |T& T&& |左引用 |T& T&& |右引用 |T&& 因此，模板函数中使用 T&& 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。更准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型。这才使得 v 作为左值的成功传递。 完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候，保持原来的参数类型（左引用保持左引用，右引用保持右引用）。为了解决这个问题，我们应该使用 std::forward 来进行参数的转发（传递）： #include #include void reference(int& v) { std::cout void pass(T&& v) { std::cout (v)); } int main() { std::cout 输出结果为： 传递右值: 普通传参:左值引用 std::move 传参:右值引用 std::forward 传参:右值引用 传递左值: 普通传参:左值引用 std::move 传参:右值引用 std::forward 传参:左值引用 无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发，所以 std::move 总会接受到一个左值，从而转发调用了reference(int&&) 输出右值引用。 唯独 std::forward 即没有造成任何多余的拷贝，同时完美转发(传递)了函数的实参给了内部调用的其他函数。 这里 std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值，std::forward 也只是单纯的将参数做了一个类型的转换，从是实现来看，std::forward(v) 和 static_cast(v) 是完全一样的。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_3.html":{"url":"practice/chap4/4_3.html","title":"对标准库的扩充：新增容器","keywords":"","body":" 对标准库的扩充：新增容器 std::array 和 std::forward_list （1）std::array 看到这个容器的时候肯定会出现这样的问题： 为什么要引入 std::array 而不是直接使用 std::vector？ 已经有了传统数组，为什么要用 std::array? 先回答第一个问题，std::vecotr 太强大了，以至于我们没有必要为了去敲碎一个鸡蛋而用一个钉锤。使用 std::array 保存在栈内存中，相比堆内存中的 std::vector，我们就能够灵活的访问这里面的元素，从而获得更高的性能；同时正式由于其堆内存存储的特性，有些时候我们还需要自己负责释放这些资源。 而第二个问题就更加简单，使用std::array能够让代码变得更加现代，且封装了一些操作函数，同时还能够友好的使用标准库中的容器算法等等，比如 std::sort。 std::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array 很简单，只需指定其类型和大小即可： std::array arr= {1,2,3,4}; int len = 4; std::array arr = {1,2,3,4}; // 非法, 数组大小参数必须是常量表达式 当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法： void foo(int *p, int len) { return; } std::array arr = {1,2,3,4}; // C 风格接口传参 // foo(arr, arr.size()); // 非法, 无法隐式转换 foo(&arr[0], arr.size()); foo(arr.data(), arr.size()); // 使用 `std::sort` std::sort(arr.begin(), arr.end()); （2）std::forward_list std::forward_list 是一个列表容器，使用方法和 std::list 基本类似，因此我们就不花费篇幅进行介绍了。 需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。 无序容器 我们已经熟知了传统 C++ 中的有序容器 std::map/std::set，这些容器内部通过红黑树进行实现，插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。 C++11 引入了两组无序容器：std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。 它们的用法和原有的 std::map/std::multimap/std::set/set::multiset 基本类似，由于这些容器我们已经很熟悉了，便不一一举例，我们直接来比较一下std::map和std::multimap： #include #include #include #include int main() { // 两组结构按同样的顺序初始化 std::unordered_map u = { {1, \"1\"}, {3, \"3\"}, {2, \"2\"} }; std::map v = { {1, \"1\"}, {3, \"3\"}, {2, \"2\"} }; // 分别对两种容器进行遍历 std::cout 最终的输出结果为： std::unordered_map Key:[2] Value:[2] Key:[3] Value:[3] Key:[1] Value:[1] std::map Key:[1] Value:[1] Key:[2] Value:[2] Key:[3] Value:[3] 元组 std::tuple 了解过 Python 的程序员应该知道元组的概念，纵观传统 C++ 中的容器，除了 std::pair 外，似乎没有现成的结构能够用来存放不同类型的数据（通常我们会自己定义结构）。但 std::pair 的缺陷是显而易见的，只能保存两个元素。 （1）元组基本操作 关于元组的使用有三个核心的函数： std::make_tuple: 构造元组 std::get: 获得元组某个位置的值 std::tie: 元组拆包 #include #include auto get_student(int id) { // 返回类型被推断为 std::tuple if (id == 0) return std::make_tuple(3.8, 'A', \"张三\"); if (id == 1) return std::make_tuple(2.9, 'C', \"李四\"); if (id == 2) return std::make_tuple(1.7, 'D', \"王五\"); return std::make_tuple(0.0, 'D', \"null\"); // 如果只写 0 会出现推断错误, 编译失败 } int main() { auto student = get_student(0); std::cout (student) (student) (student) std::get 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象： std::tuple t(\"123\", 4.5, 6.7, 8); std::cout (t) (t) (t) （2）运行期索引 如果你仔细思考一下可能就会发现上面代码的问题，std::get<> 依赖一个编译期的常量，所以下面的方式是不合法的： int index = 1; std::get(t); 那么要怎么处理？答案是，标准库做不到。这里介绍一个使用 boost::variant 配合变长模板参数的黑魔法： 提示：使用 boost 只是暂时性的解决方案，variant 已在 C++17 中被纳入标准库 std::variant，见扩展主题它的讨论。http://en.cppreference.com/w/cpp/utility/variant #include template boost::variant _tuple_index(size_t i, const std::tuple& tpl) { if (i == n) return std::get(tpl); else if (n == sizeof...(T) - 1) throw std::out_of_range(\"越界.\"); else return _tuple_index(i, tpl); } template boost::variant tuple_index(size_t i, const std::tuple& tpl) { return _tuple_index(i, tpl); } 这样我们就能： int i = 1; std::cout （3）元组合并与遍历 还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现： auto new_tuple = std::tuple_cat(get_student(1), std::move(t)); 马上就能够发现，应该如何快速遍历一个元组？但是我们刚才介绍了如何在运行期通过非常数索引一个 tuple 那么遍历就变得简单了，首先我们需要知道一个元组的长度，可以： template auto tuple_len(T &tpl) { return std::tuple_size::value; } 这样就能够对元组进行迭代了： // 迭代 for(int i = 0; i != tuple_len(new_tuple); ++i) // 运行期索引 std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_4.html":{"url":"practice/chap4/4_4.html","title":"对标准库的扩充: 智能指针和引用计数","keywords":"","body":" 对标准库的扩充: 智能指针和引用计数 RAII 与引用计数 了解 Objective-C/Swift 的程序员应该知道引用计数的概念。引用计数这种计数是为了防止内存泄露而产生的。基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。 在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。 凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 new 和 delete 去『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。这些智能指针就包括 std::shared_ptr/std::unique_ptr/std::weak_ptr，使用它们需要包含头文件 。 注意：引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待，更能够清晰明确的表明资源的生命周期。 std::shared_ptr std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式调用 delete，当引用计数变为零的时候就会将对象自动删除。 但还不够，因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。 std::make_shared 就能够用来消除显示的使用 new，所以std::make_shared 会分配创建传入参数中的对象，并返回这个对象类型的std::shared_ptr指针。例如： #include #include void foo(std::shared_ptr i) { (*i)++; } int main() { // auto pointer = new int(10); // 非法, 不允许直接赋值 // 构造了一个 std::shared_ptr auto pointer = std::make_shared(10); foo(pointer); std::cout std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数，并通过get_count()来查看一个对象的引用计数。例如： auto pointer = std::make_shared(10); auto pointer2 = pointer; // 引用计数+1 auto pointer3 = pointer; // 引用计数+1 int *p = pointer.get(); // 这样不会增加引用计数 std::cout std::unique_ptr std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证了代码的安全： std::unique_ptr pointer = std::make_unique(10); // make_unique 从 C++14 引入 std::unique_ptr pointer2 = pointer; // 非法 make_unique 并不复杂，C++11 没有提供 std::make_unique，可以自行实现： template std::unique_ptr make_unique( Args&& ...args ) { return std::unique_ptr( new T( std::forward(args)... ) ); } 至于为什么没有提供，C++ 标准委员会主席 Herb Sutter 在他的博客中提到原因是因为『被他们忘记了』。 既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr，例如： #include #include struct Foo { Foo() { std::cout p1(std::make_unique()); // p1 不空, 输出 if (p1) p1->foo(); { std::unique_ptr p2(std::move(p1)); // p2 不空, 输出 f(*p2); // p2 不空, 输出 if(p2) p2->foo(); // p1 为空, 无输出 if(p1) p1->foo(); p1 = std::move(p2); // p2 为空, 无输出 if(p2) p2->foo(); std::cout foo(); // Foo 的实例会在离开作用域时被销毁 } std::weak_ptr 如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。看下面这个例子： #include #include class A; class B; class A { public: std::shared_ptr pointer; ~A() { std::cout pointer; ~B() { std::cout a = std::make_shared(); std::shared_ptr b = std::make_shared(); a->pointer = b; b->pointer = a; return 0; } 运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，这使得 a,b 的引用计数均变为了 2，而离开作用域时，a,b 智能指针被析构，却智能造成这块区域的引用计数减一，这样就导致了 a,b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露 解决这个问题的办法就是使用弱引用指针 std::weak_ptr，std::weak_ptr是一种弱引用（相比较而言 std::shared_ptr 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的释放 std::weak_ptr 没有 * 运算符和 -> 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 std::shared_ptr 是否存在，expired() 方法在资源未被释放时，会返回 true，否则返回 false。 正确的代码如下： #include #include class A; class B; class A { public: // A 或 B 中至少有一个使用 weak_ptr std::weak_ptr pointer; ~A() { std::cout pointer; ~B() { std::cout a = std::make_shared(); std::shared_ptr b = std::make_shared(); a->pointer = b; b->pointer = a; return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_5.html":{"url":"practice/chap4/4_5.html","title":"对标准库的扩充: 正则表达式","keywords":"","body":" 对标准库的扩充: 正则表达式 正则表达式简介 正则表达式不是 C++ 语言的一部分，这里仅做简单的介绍。 正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求： 检查一个串是否包含某种形式的子串； 将匹配的子串替换； 从某个串中取出符合条件的子串。 正则表达式是由普通字符（例如 a 到 z）以及特殊字符组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 （1）普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 （2）特殊字符 特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表： 特别字符 描述 $ |匹配输入字符串的结尾位置。 (,) |标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。 |匹配前面的子表达式零次或多次。 |匹配前面的子表达式一次或多次。 . |匹配除换行符 \\n 之外的任何单字符。 [ |标记一个中括号表达式的开始。 ? |匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。 \\ |将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， n 匹配字符 n。 \\n |匹配换行符。序列 \\ 匹配 '\\' 字符，而 ( 则匹配 '(' 字符。 ^ |匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。 { |标记限定符表达式的开始。 | |指明两项之间的一个选择。 （3）限定符 限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表： 字符 描述 |匹配前面的子表达式零次或多次。例如，foo 能匹配 fo 以及 foooo。 等价于{0,}。 |匹配前面的子表达式一次或多次。例如，foo+ 能匹配 foo 以及 foooo，但不能匹配 fo。+ 等价于 {1,}。 ? |匹配前面的子表达式零次或一次。例如，Your(s)? 可以匹配 Your 或 Yours 中的Your 。? 等价于 {0,1}。 {n} |n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 for 中的 o，但是能匹配 foo 中的两个 o。 {n,} |n 是一个非负整数。至少匹配 n 次。例如，o{2,} 不能匹配 for 中的 o，但能匹配 foooooo 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。 {n,m} |m 和 n 均为非负整数，其中 n 小于等于 m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 foooooo 中的前三个 o。o{0,1} 等价于 o?。注意，在逗号和两个数之间不能有空格。 有了这三张表，我们通常就能够读懂几乎所有的正则表达式了。 std::regex 及其相关 对字符串内容进行匹配的最常见手段就是使用正则表达式。可惜在传统 C++ 中正则表达式一直没有得到语言层面的支持，没有纳入标准库，而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时，使用正则表达式也是工业界最为成熟的普遍做法。 一般的解决方案就是使用 boost 的正则表达式库。而 C++11 正式将正则表达式的的处理方法纳入标准库的行列，从语言级上提供了标准的支持，不再依赖第三方。 C++11 提供的正则表达式库操作 std::string 对象，模式 std::regex (本质是 std::basic_regex)进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch （本质是 std::match_results 对象）。 我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式 [a-z]+.txt: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多次，因此 [a-z]+ 能够匹配一个小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字符，而 . 则表示匹配字符 .，最后的 txt 表示严格匹配 txt 则三个字母。因此这个正则表达式的所要匹配的内容就是由纯小写字母组成的文本文件。 std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是传入std::string 以及一个 \u001bstd::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。例如： #include #include #include int main() { std::string fnames[] = {\"foo.txt\", \"bar.txt\", \"test\", \"a0.txt\", \"AAA.txt\"}; // 在 C++ 中 `\\` 会被作为字符串内的转义符，为使 `\\.` 作为正则表达式传递进去生效，需要对 `\\` 进行二次转义，从而有 `\\\\.` std::regex txt_regex(\"[a-z]+\\\\.txt\"); for (const auto &fname: fnames) std::cout 另一种常用的形式就是依次传入 std::string/std::smatch/std::regex 三个参数，其中 std::smatch 的本质其实是 std::match_results，在标准库中， std::smatch 被定义为了 std::match_results，也就是一个子串迭代器类型的 match_results。使用 std::smatch 可以方便的对匹配的结果进行获取，例如： std::regex base_regex(\"([a-z]+)\\\\.txt\"); std::smatch base_match; for(const auto &fname: fnames) { if (std::regex_match(fname, base_match, base_regex)) { // sub_match 的第一个元素匹配整个字符串 // sub_match 的第二个元素匹配了第一个括号表达式 if (base_match.size() == 2) { std::string base = base_match[1].str(); std::cout 以上两个代码段的输出结果为： foo.txt: 1 bar.txt: 1 test: 0 a0.txt: 0 AAA.txt: 0 sub-match[0]: foo.txt foo.txt sub-match[1]: foo sub-match[0]: bar.txt bar.txt sub-match[1]: bar OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_6.html":{"url":"practice/chap4/4_6.html","title":"对标准库的扩充: 语言级线程支持","keywords":"","body":" 对标准库的扩充: 语言级线程支持 std::thread std::thread 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含头文件，它提供了很多基本的线程操作，例如get_id()来获取所创建线程的线程 ID，例如使用 join() 来加入一个线程等等，例如： #include #include void foo() { std::cout std::mutex, std::unique_lock 我们在操作系统的相关知识中已经了解过了有关并发技术的基本知识，mutex 就是其中的核心之一。C++11 引入了 mutex 相关的类，其所有相关的函数都放在 头文件中。 std::mutex 是 C++11 中最基本的 mutex 类，通过实例化 std::mutex 可以创建互斥量，而通过其成员函数 lock() 可以仅此能上锁，unlock() 可以进行解锁。但是在在实际编写代码的过程中，最好不去直接调用成员函数，因为调用成员函数就需要在每个临界区的出口处调用 unlock()，当然，还包括异常。这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类std::lock_gurad。RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。 在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如： void some_operation(const std::string &message) { static std::mutex mutex; std::lock_guard lock(mutex); // ...操作 // 当离开这个作用域的时候，互斥锁会被析构，同时unlock互斥锁 // 因此这个函数内部的可以认为是临界区 } 由于 C++保证了所有栈对象在声明周期结束时会被销毁，所以这样的代码也是异常安全的。无论 some_operation() 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 unlock()。 而 std::unique_lock 则相对于 std::lock_guard 出现的，std::unique_lock 更加灵活，std::unique_lock 的对象会以独占所有权（没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权）的方式管理 mutex 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 std::unique_lock。例如： #include #include #include std::mutex mtx; void block_area() { std::unique_lock lock(mtx); //...临界区 } int main() { std::thread thd1(block_area); thd1.join(); return 0; } std::future, std::packaged_task std::future 则是提供了一个访问异步操作结果的途径，这句话很不好理解。为了理解这个特性，我们需要先理解一下在 C++ 11 之前的多线程行为。 试想，如果我们的主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务，并返回我一个结果。而这时候，线程 A 可能正在忙其他的事情，无暇顾及 B 的结果，所以我们会很自然的希望能够在某个特定的时间获得线程 B 的结果。 在 C++11 的 std::future 被引入之前，通常的做法是：创建一个线程 A，在线程 A 里启动任务 B，当准备完毕后发送一个事件，并将结果保存在全局变量中。而主函数线程 A 里正在做其他的事情，当需要结果的时候，调用一个线程等待函数来获得执行的结果。 而 C++11 提供的 std::future 简化了这个流程，可以用来获取异步任务的结果。自然地，我们很容易能够想象到把它作为一种简单的线程同步手段。 此外，std::packaged_task 可以用来封装任何可以调用的目标，从而用于实现异步的调用。例如： #include #include #include int main() { // 将一个返回值为7的 lambda 表达式封装到 task 中 // std::packaged_task 的模板参数为要封装函数的类型 std::packaged_task task([](){return 7;}); // 获得 task 的 future std::future result = task.get_future(); // 在一个线程中执行 task std::thread(std::move(task)).detach(); std::cout 在封装好要调用的目标后，可以使用 get_future() 来获得一个 std::future 对象，以便之后事实线程同步。 std::condition_variable std::condition_variable 是为了解决死锁而生的。当互斥操作不够用而引入的。比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，condition_variable 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。std::condition_variable的 notify_one() 用于唤醒一个线程；notify_all() 则是通知所有线程。下面是一个生产者和消费者模型的例子： #include #include #include #include #include #include int main() { // 生产者数量 std::queue produced_nums; // 互斥锁 std::mutex m; // 条件变量 std::condition_variable cond_var; // 结束标志 bool done = false; // 通知标志 bool notified = false; // 生产者线程 std::thread producer([&]() { for (int i = 0; i lock(m); std::cout lock(m); while (!done) { while (!notified) { // 循环避免虚假唤醒 cond_var.wait(lock); } while (!produced_nums.empty()) { std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_7.html":{"url":"practice/chap4/4_7.html","title":"其他杂项","keywords":"","body":" 其他杂项 新类型 long long int long long int 并不是 C++11 最先引入的，其实早在 C99，long long int 就已经被纳入 C 标准中，所以大部分的编译器早已支持。C++11 的工作则是正式把它纳入标准库，规定了一个 long long int 类型至少具备 64 位的比特数。 noexcept 的修饰和操作 C++ 相比于 C 的一大优势就在于 C++ 本身就定义了一套完整的异常处理机制。然而在 C++11 之前，几乎没有人去使用在函数名后书写异常声明表达式，从 C++11 开始，这套机制被弃用，所以我们不去讨论也不去介绍以前这套机制是如何工作如何使用，你更不应该主动去了解它。 C++11 将异常的声明简化为以下两种情况： 函数可能抛出任何异常 函数不能抛出任何异常 并使用 noexcept 对这两种行为进行限制，例如： void may_throw(); // 可能抛出异常 void no_throw() noexcept; // 不可能抛出异常 使用 noexcept 修饰过的函数如果抛出异常，编译器会使用 std::terminate() 来立即终止程序运行。 noexcept 还能用作操作符，用于操作一个表达式，当表达式无异常时，返回 true，否则返回 false。 #include void may_throw() { throw true; } auto non_block_throw = []{ may_throw(); }; void no_throw() noexcept { return; } auto block_throw = []() noexcept { no_throw(); }; int main() { std::cout noexcept 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发。例如： try { may_throw(); } catch (...) { std::cout 最终输出为： 捕获异常, 来自 my_throw() 捕获异常, 来自 non_block_throw() 字面量 原始字符串字面量 传统 C++ 里面要编写一个充满特殊字符的字符串其实是非常痛苦的一件事情，比如一个包含 HTML 本体的字符串需要添加大量的转义符，例如一个 Windows 上的文件路径经常会：C:\\What\\The\\Fxxk。 C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 R 来修饰这个字符串，同时，将原始字符串使用括号包裹，例如： #include #include int main() { std::string str = R\"(C:\\\\What\\\\The\\\\Fxxk)\"; std::cout 自定义字面量 C++11 引进了自定义字面量的能力，通过重载双引号后缀运算符实现： // 字符串字面量自定义必须设置如下的参数列表 std::string operator\"\" _wow1(const char *wow1, size_t len) { return std::string(wow1)+\"woooooooooow, amazing\"; } std::string operator\"\" _wow2 (unsigned long long i) { return std::to_string(i)+\"woooooooooow, amazing\"; } int main() { auto str = \"abc\"_wow1; auto num = 1_wow2; std::cout 自定义字面量支持四种字面量： 整型字面量：重载时必须使用 unsigned long long、const char *、模板字面量算符参数，在上面的代码中使用的是前者； 浮点型字面量：重载时必须使用 long double、const char *、模板字面量算符； 字符串字面量：必须使用 (const char *, size_t) 形式的参数表； 字符字面量：参数只能是 char, wchar_t, char16_t, char32_t 这几种类型。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:45:53 "},"practice/chap5/5_0summary.html":{"url":"practice/chap5/5_0summary.html","title":"C++ 实现高性能 RTTI 库","keywords":"","body":" C++ 实现高性能 RTTI 库 RTTI 是运行时类型识别的英文缩写，C++ 本身提供了运行时类型识别的运算符 dynamic_cast 和 typeid，然而 dynamic_cast 的效率其实并不理想，需要牺牲一定性能。本项目将手动实现一个高性能 RTTI 库。 项目涉及的知识点 运行时类型识别 dynamic_cast, typeid 显式类型转换 static_cast, const_cast, reinterpret_cast OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap5/5_1.html":{"url":"practice/chap5/5_1.html","title":"基础知识：运行时类型识别","keywords":"","body":" 基础知识：运行时类型识别 编译器运行时类型识别 C++ 提供了虚函数的特性，这导致了多态的存在，对于多态性的对象，程序编译时就可能出现无法确定对象的类型的情况。当类中含有虚函数时，基类指针就能够指向任何派生类的对象，这就导致了我们无法知道基类指针指向的到底是哪个对象的情况。所以类的类型就需要在运行时候利用运行时类型标识，RTTI 应运而生。 RTTI，Run Time Type Identification，通过运行时类型识别程序能够使用基类指针或引用检查这些指针或引用的对象。RTTI 提供了两个操作符，分别是： typeid：用于返回指针和引用所指的实际类型。 dynamic_cast: 将基类类型的指针或引用，安全地转换为派生类的指针或引用。 来看一个例子： #include struct V { virtual void f() {}; }; struct A : virtual V {}; struct B : virtual V { B(V* v, A* a) { // 在构造时进行转换 dynamic_cast(v); // 明确定义的: v 的类型为 V*, V 是 B 的基类, 结果为 B* dynamic_cast(a); // 未定义行为: a 的类型为 A*, A 不是 B 的基类 } }; struct D : A, B { D() : B((A*)this, this) { } }; struct Base { virtual ~Base() {} }; struct Derived: Base { virtual void name() {} }; int main() { D d; // 派生类对象 A& a = d; // upcast D& new_d = dynamic_cast(a); // downcast B& new_b = dynamic_cast(a); // sidecast Base* b1 = new Base; if(Derived* d = dynamic_cast(b1)) { std::cout name(); // 安全调用 } Base* b2 = new Derived; if(Derived* d = dynamic_cast(b2)) { std::cout name(); // 安全调用 } delete b1; delete b2; } 上面的代码只会输出 b2 到 d 的 downcast。 首先我们定义了一个 D 类型的派生类对象，D 派生自 A 和 B。然后用一个 A 类型的引用去应用了一个 D 类型的对象，这就是典型的 upcast。 而如果我们将 A 类型的引用使用 dynamic_cast 转换为其子类对象的引用，这就是典型的 downcast。 而如果我们把一个引用 D 类对象的父类 A 引用转换为 D 类对象的另一个父类 B 的引用，这就是 sidecast。 接着，b1 是一个基类指针，指向了一个基类的对象，如果我们把它在运行时视为一个子类对象，而去调用子类对象的方法，这是不安全的调用，因此从 b1 到 d 的 downcast 是不会成功的。 而对于 b2 来说，b2 也是一个基类指针，但其指向的是一个派生类的对象，我们是能够通过 dynamic_cast 安全的将其转换成一个派生类指针，从而成功调用派生类的方法。 C++ 的显式类型转换 C++ 的显式类型转换除了 dynamic_cast 外，还有 static_cast, const_cast, reinterpret_cast。 static_cast 能够将任何具有明确定义的类型转换，只要不包含底层 const，都可以使用 static_cast，由于是静态类型转换，也就没有了运行时类型转换来保证转换的安全性。而 const_cast 只能改变对象的底层 const 性质，不能改变表达式运算对象的类型，可以用于增加或者移除对象的 const 属性。但值得注意的是，通过 const_cast 移除的 const 属性对象的写值行为是未定义的。 例如： int *num; const int *const_num; void* p = &num; int *static_cast_num = static_cast(p); int *static_cast_num2 = static_cast(const_num); // 错误, 无法转换 const 类型 int *const_cast_num = const_cast(const_num); // 使用 const_cast_num 的写值行为是未定义的 reinterpret_cast 则能够对对象的位模式提供低层次上的重新解释。举个例子： struct A { int a; }; struct B { int b; }; struct C : A, B {}; C c; std::cout (&c) (&c) 对于上面的代码来说，我们 C 结构继承自 A, B。当我们把对象 c 的地址使用 reinterpret_cast 转型成 B 时候，会直接将整块内存单元重新解释，所以其地址与 c 的地址相同，但是 static_cast 会为父类指针计算偏移量，将含有 a,b 的 c 转换为 B 而指向 b，导致最终输出的地址不同。最后的一个 C 风格的强制类型转换的结果与 static_cast 结果类似。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap5/5_2.html":{"url":"practice/chap5/5_2.html","title":"RTTI 库的设计与实现","keywords":"","body":" RTTI 库的设计与实现 设计 首先，我们定义一个 rtti 类用于模拟运行时类型识别，并使用 std::array 定义 inherChainID 和 inherChainPtr 来最终实现 RTTI 特性。 然后再定义 rttiport 模板来作为实际的 rtti 特性接口，需要使用 rtti 特性的类都必须要继承自此类。在这个类中，使用私有对象 id 来表示类型。而静态方法 type() 来获取对象的类型。在 /home/shiyanlou/ 目录下新建 rtti.hpp 文件： #ifndef RTTI_h #define RTTI_h #include // std::intptr_t #include // std::array #if !defined(RTTI_CHAIN_MAX_SIZE) #define RTTI_CHAIN_MAX_SIZE 32 #endif namespace rttilib { // rtti 类用于模拟运行时类型识别, 该类是 rttiport 模板类的基类 // 该类被设计成协议, 所以不能直接创建此类型的对象, 应该继承后使用 class rtti { protected: std::array inherChainID; std::array inherChainPtr; int inherChainCounter; rtti() { // TODO: } public: virtual ~rtti() {}nullptr inline void* getPtrKindOf(std::intptr_t type) { // TODO: } inline bool isKindOf(std::intptr_t type) { // TODO: } }; template class rttiport: public virtual rtti { private: static std::intptr_t id; public: static std::intptr_t type(); protected: rttiport() { // TODO: } virtual ~rttiport() {} }; template std::intptr_t rttiport::id(0); template std::intptr_t rttiport::type() { // TODO } } //namespace rttilib #endif /* RTTI_h */ 实现 首先实现 rtti 类的构造函数，我们将存储的 inherChainID 和 inherChainPtr 分别进行初始化： rtti() : inherChainCounter(-1) { for(auto& id : inherChainID) id = -1; for(auto& ptr: inherChainPtr) ptr = 0; } 而后实现 getPtrKindOf 和 isKindOf： // 检测示例是否为 type 所表示的类型 // type: 对象类型的 ID, 使用 intptr_t 表示 // return: 指向实例的 void* 指针, 若实例没有对应的 type 则返回 nullptr inline void* getPtrKindOf(std::intptr_t type) { for(int i = 0; i 对于实际提供 RTTI 特性的构造函数 rttiport 来说： rttiport() { // 每继承一次, ChainCounter 就增加 1 inherChainCounter++; // 并在 inherChainID 中保存类型 id inherChainID[inherChainCounter] = type(); inherChainPtr[inherChainCounter] = static_cast(this); //将其转换到 T* } 其中，它的类型通过其成员 id 进行表示获取： std::intptr_t rttiport::type() { // 此处我们要把 id 的地址的位模式进行重新解释，所以使用 reinterpret_cast return reinterpret_cast(&id); } 功能补全 我们提供了一个实例方法 isKinfOf 来为对象提供类型检查的特性，为此我们使用模板类解决了类对象的类型识别问题，但是如果我们要进行类型转换，暂时还没有任何办法。所以，我们可以在 rttilib 名称空间中提供一个 cast 函数： // rtti.hpp // 将 to 指向对象在运行时转换为 T 类型 template static T* cast(rtti* to) { if(to == nullptr) return nullptr; return static_cast(to->getPtrKindOf(rttiport::type())); } 同时，为了方便起见，我们还可以重新提供一个更加简便的类型检查函数： // rtti.hpp // 提供另一种检查 obj 指向的对象是否为 T 类型的对象 template static bool is(rtti *obj) { if(obj == nullptr) return false; return obj->getPtrKindOf(rttiport::type()) != nullptr; } 性能测试 下面我们来测试我们编写的 RTTI 库，首先来测试库的正确性，我们在 /home/shiyanlou/ 目录下创建 main.cpp 文件并在其中写入下面的函数： // main.cpp #include #include \"rtti.hpp\" using namespace rttilib; using namespace std; // 定义好下面用于测试库的对象及其复杂的继承关系 class A: public rttiport {}; class B: public rttiport {}; class C: public rttiport {}; class D: public rttiport {}; class E: public rttiport {}; class AB: public virtual A, public virtual B, public rttiport {}; class CD: public virtual C, public virtual D, public rttiport {}; class AB_CD: public virtual AB, public virtual CD, public rttiport {}; class AB_CD_E: public virtual AB, public virtual CD, public virtual E, public rttiport {}; void test_useage() { std::cout.setf(std::ios::boolalpha); // 定义对象 AB_CD_E, 该对象继承自 AB,CD,E, 其中 AB 和 CD 分别继承自 A,B 和 C,D AB_CD_E* obj1 = new AB_CD_E(); // 使用 `isKindOf` 方法来判断 AB_CD_E 对象是否是 A 类型的对象, true cout isKindOf(rttiport::type()) (obj1) isKindOf(rttiport::type()) (obj1) isKindOf(rttiport::type()) isKindOf(rttiport::type()) isKindOf(rttiport::type()) isKindOf(rttiport::type()) isKindOf(rttiport::type()) isKindOf(rttiport::type()) 同样，为了测试库的性能，我们可以写出下面的测试函数 test_speed，并在主函数中使用它： // main.cpp #include #include #include void test_speed() { std::time_t rttilib_t = 0; std::time_t dyncast_t = 0; const int times = 10; const int size = 80000; for (int a = 0; a > vec; for (int i = 0; i ()); std::time_t t = clock(); for (int i = 0; i (vec[i].get()); rttilib_t += clock()-t; t = clock(); for (int i = 0; i (vec[i].get()); dyncast_t += clock()-t; vec.clear(); } std::cout 在上面的代码中，我们编写的 RTTI 库在 80000*5 次运行时类型转换下的性能要两倍快于编译器提供的 dynamic_cast；同时类型识别的结果也符合我们的预期 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap6/6_0summary.html":{"url":"practice/chap6/6_0summary.html","title":"Makefile基础入门","keywords":"","body":" Makefile基础入门 Makefile 是一种描述工程编译、链接的文件。在一个庞大的项目或工程中，往往存在非常复杂的编译和链接流程，而 Makefile 文件可以描述哪些源文件在何时需要编译，如何编译这些源文件，甚至可以调用 shell 和其它的工具来执行更加复杂的项目构建流程。一旦 Makefile 文件构建完毕，用户只需要使用 GNU make 工具读入 Makefile 即可完成整个工程的编译和链接流程，极大提高了项目开发和测试的效率。 本系列的实验主要是让大家学习 Makefile 的基本规则。在正式讲述 make 工具的使用方式和 Makefile 书写规则之前，本次实验先介绍一些简单的前导知识，这也是 GNU make 官方手册中采用的教学模式。本次实验用于演示 GNU GCC 编译和链接的基本方法，通过编译、链接、静态链接、动态链接让用户学习和理解 GCC 的使用方式。另一方面，用户也将在实验过程中体验手动编译链接的效率，从而理解自动编译的在项目工程管理中的重要性。 编写基本代码 对代码进行编译，链接，并执行查看效果 添加代码扩展功能，并进行静态链接 添加代码扩展功能,并进行动态链接 使用静态+动态的混合链接 http://labfile.oss.aliyuncs.com/courses/849/make_example-master.zip OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap6/6_1.html":{"url":"practice/chap6/6_1.html","title":"Makefile 基础规则","keywords":"","body":" Makefile 基础规则一 makefile作为工程管理文件可以提供工程下各个源代码的编译、链接规则。 GNU make 工具可以读入makefile并解析其中的规则，并自动对工程进行编译链接，提高项目开发的效率。 action： makefile基本规则。 makefile时间戳检验测试。 验证makefile依赖文件的执行顺序。 变量，PHONY和“-”功能测试。 makefile文件命名规则。 编写一段程序的makefile文件。 知识点 makefile 的基本编译规则 make 更新目标的依据 makefile 目标依赖的执行顺序 makefile 变量的赋值与使用 .PHONY 的作用 “-” 的作用 make 搜寻 makefile的命名规则 编写一段程序的 makefile 文件 小型计算程序说明 现在我们已经掌握了makefile的基本规则，可以尝试自己写一个makefile进行工程管理。 在make_example/chapter0目录下有一段简单的计算器示例程序，现在要为它建立一个makefile文件。 切换到chapter0目录，查看目录下的文件： cd ../chapter0 ls 终端打印： add_minus.c add_minus.h main.c multi_div.c multi_div.h readme.md v1.0.patch v2.0.patch v3.0.patch 简单介绍一下程序的需求： add_minus.c要求被编译成静态链接库libadd_minus.a。 multi_div.c要求被编译成动态链接库libmulti_div.so。 main.c是主要的源文件，会调用上述两个代码文件中的API，main.c要求被编译为main.o。 将main.o libadd_minus.a libmulti_div.so链接成可执行文件 main。 每次编译前要清除上次编译时产生的文件。 打上补丁 v3.0 并增加库文件路径，export环境变量LD_LIBRARY_PATH为当前路径： patch -p2 makefile文件示例 # this is a chapter0 makefile .PHONY:all clean depen depen=clean main.o add_minus.o libadd_minus.a libmulti_div.so all:$(depen) -gcc -o main main.o -L./ -ladd_minus -lmulti_div main.o:main.c gcc -c main.c add_minus.o: gcc -c add_minus.c libadd_minus.a:add_minus.o ar rc libadd_minus.a add_minus.o libmulti_div.so: gcc multi_div.c -fPIC -shared -o libmulti_div.so clean: -rm $(depen) OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap6/6_3.html":{"url":"practice/chap6/6_3.html","title":"关于makefile","keywords":"","body":" 关于makefile makefile 简介 makefile就是一个简单的文本文件，它基本上就是由一条条的规则构成。下面，我们就来看一下makefile里的最基本的语法单元，规则。一条makefile的规则构成如下： target:prerequisites command1 command2 ..... commandN target：规则的目标，可以简单理解为这条规则存在的目的是什么。通常是程序中间或者最后需要生成的文件名，也可以不对应具体的文件，而仅仅就是个概念上的规则目标。 prerequisites：规则的依赖列表，可以简单的理解为要达到本条规则的目标所需要的先决条件是什么。可以是文件名，也可以是其他规则的目标； command：规则的命令，可以简单的理解为当目标所需要的先决条件的满足了之后，需要执行什么动作来达成规则的目标。规则的命令其实就是shell命令。一条规则中可以有多行命令，特别注意：每行命令都必须以tab键开始！ # 最简单的makefile文件 all: echo \"Hello world!\" #注意：每行命令都必须以tab键开始！ 这个简单的makefile文件，只有一条规则，规则的目标是all，没有任何依赖(规则不可以没有目标但是可以没有依赖)，以及一条命令(其实规则也是可以不需要任何命令的)。怎么用这个makefile呢？ make 的工作机理 那make工具又到底是如何工作的呢？解释make的工作机理，需分别回答以下3个问题： make命令如何使用 ； make从哪读取makefile； make如何解析执行makefile文件的规则。 make命令的基本使用范式如下： make [ -f makefile ] [ options ] ... [ targets ] ... 使用make命令的最简单的方式主要有以下四种形式： 简单粗暴，不带任何参数，直接执行make： $ make 指定makefile文件： $ make -f 指定 makefile 目标： $ make 到指定目录下执行make： $ make -C 在执行make的时候，我们可以带上-f 参数，来指定make命令从哪里读取makefile文件；而如果我们不显式指定，则make就会在当前目录下依次查找名字为GNUmakefile, makefile,和 Makefile的文件来作为其makefile文件。 在读取完makefile的内容后，make工具并不是逐条去执行makefile里的规则，而是以某条规则为突破口，多米诺骨牌效应式的去执行makefile里的规则。而这条作为突破口的规则的目标，称为终极目标 ，我们可以在执行make时以参数的形式指定终极目标，从而执行作为突破口的规则，如果我们不显式指定终极目标，make一般情况下将选择makefile的第一条规则的目标作为终极目标。 make解析makefile的流程如下： 假设有mekefile内容如下： 终极目标：依赖A 依赖B 依赖C 终极目标命令 依赖A：子依赖A1 子依赖A2 依赖A命令 依赖B：子依赖B1 子依赖B2 依赖B命令 依赖C：子依赖C1 子依赖C2 依赖C命令 过程一，以终极目标为树根，解析出整颗依赖树： 过程二，对整颗依赖树以从底到上，从左到右的顺序，解析执行每一条规则： OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap6/6_4.html":{"url":"practice/chap6/6_4.html","title":"丰富我们的 makefile 语法工具箱","keywords":"","body":"丰富我们的 makefile 语法工具箱 变量的定义 makefile中的变量，与C语言中的宏类似，它为一个文本字符串（变量的值，其类型只能是字符串类型）提供了一个名字(变量名)。 变量定义的基本格式： 变量名 赋值符 变量值 变量名指的就是该变量的名字，是不包括“:”、“#”、“=”、前置空白和尾空白的任何字符串。需要注意的是，尽管在GNU make中没有对变量的命名有其它的限制，但定义一个包含除字母、数字和下划线以外的变量的做法也是不可取的，因为除字母、数字和下划线以外的其它字符可能会在以后的make版本中被赋予特殊含义，并且这样命名的变量对于一些shell来说不能作为环境变量使用。变量名是大小写敏感的。变量“foo”、“Foo”和“FOO”指的是三个不同的变量。Makefile传统做法是变量名是全采用大写的方式。推荐的做法是在对于内部定义定义的一般变量（例如：目标文件列表objects）使用小写方式，而对于一些参数列表（例如：编译选项CFLAGS）采用大写方式。 变量值，指的是变量所代表的内容，可以是一个文件名列表、编译选项列表、程序运行的选项参数列表、搜索源文件的目录列表、编译输出的目录列表和所有我们能够想到的事物。变量的值，其本质就是一个字符串。 赋值符，有= 、 := 、 ?=和 +=四种格式，其中= 和 := 为基本定义类型， ?=和 +=为基于=的扩展定义类型。 一个在makefile中定义变量的例子： objects = program.o foo.o utils.o 2.4.2 变量的引用 当我们定义了一个变量之后，我们就可以在makfile中的目标、依赖、命令中引用我们的变量；而所谓的变量引用，就是在引用变量名的地方，用变量所代表的内容，执行一个严格的文本替换过程(该过程也称为变量被展开的过程 )，替换掉变量的名字。 变量的引用有以下几种方式： ${变量名} $（变量名） $单字符变量名 ，变量名仅包含一个字符，如$@ 、$^等 一个在makefile中引用变量的例子： ```变量定义 objects = program.o foo.o utils.o program : $(objects) #在依赖中引用变量 gcc -o program ${objects} #在命令中引用变量 $(objects) : defs.h #在目标中引用变量 ### 变量的分类与赋值 根据变量定义时所使用的赋值操作符的不同，可以将变量分成两种类型(或者说是两种风格)： 递归展开式变量和直接展开式变量； >使用赋值操作符= 、 += 和 ?=定义的变量都是递归展开式变量，使用赋值操作符 :=定义的变量为直接展开式变量 。 >两种变量类型的的最根本区别在于：变量值的求值时机，递归式变量的求值时机在于变量被引用时，直接展开式的求值时机在于变量被定义时。 我们来编写makefile 文件 /home/shiyanlou/Code/makefile_sample/variabletype.mk： foo1 = $(bar) #递归展开式变量 foo2 := $(bar) #直接展开式变量 bar = $(ugh) ugh = Huh? all: echo \"foo1 is $(foo1), foo2 is $(foo2)\" 然后，使用 $ make -f variabletype.mk 执行variabletype.mk 由于变量foo1的变量值是在执行echo命令时才求的值，所以foo1的值被递归的展开为Huh?； 而变量foo2的变量值在定义时就被求值了，此时由于变量bar的值为空，因此foo2的值也为空。 注意：使用递归展开式的变量定义，可能会由于出现变量的递归定义而导致make陷入到无限的变量展开过程中，最终使make执行失败 += 和 ?=是基于=扩展而来的两种变量赋值操作符； += 称为追加赋值操作符，它实现对于一个已经存在定义的变量进行追加赋值，如下例子： bar = foo1bar += foo2 #追加赋值，bar的值将为 foo1 foo2 all: echo $(bar) ?=称为条件赋值的赋值操作符，被称为条件赋值为：只有此变量在之前没有赋值的情况下才会对这个变量进行赋值。看一下例子： bar1 = foo1 bar1 ?= foo2 # bar1 的值还是foo1 bar2 ?= foo2 # bar2 的值为foo2 all: echo \"bar1 is $(bar1), bar2 is $(bar2)\" ### 特殊的变量 在makefile 中用户除了可以自定义变量外，还可以使用make工具为我们提供的一些特殊的变量及用法。 - 自动化变量 所谓自动化变量，就是在每条规则中，make自动为我们提供的用于指定规则各个组成部分的变量，一般情况下常用的有以下几个自动化变量： >$@ -- 代表规则中的目标文件名 >$$^ -- 代表规则中所有依赖文件的列表，文件名用空格分割 看例子，编写makefile 文件 /home/shiyanlou/Code/makefile_sample/auto_var.mk： all: first second third echo \"$$@ = $@\" echo \"$$ first second third: 这里有几点需要说明一下： >1. $字符在makefile中有特殊用途，因此如果要取消其特殊用途当成一个普通字符传递给echo命令执行，需要使用$$ >2. $@在bash shell中也有特殊用途，因此如果希望echo命令在bash中正常输出$@， 需要加上\\字符 >3. 该makefile的最后一行first second third: 看起来有点奇怪，这是一条没有依赖和命令的多目标规则，读者可自行将它删除看有什么效果，并思考原因。 ### 变量的替换引用 变量的分类与赋值 对于一个已经定义的变量，可以使用“替换引用”将其值使用指定的字符（字符串）进行替换。格式为$(VAR:A=B)或者${VAR:A=B}，意思是，将变量“VAR”所表示的值中所有字符串“A”结尾的字符替换为“B”的字。“结尾”的含义是空格之前（变量值的多个字以空格分开）。而对于变量其它部分的“A”字符不进行替换。例如： sources := a.c b.c c.c d.d objects := $(sources:.c=.o) all: echo \"objects = $(objects)\" 在这个定义中，变量“objects”的值就为“a.c b.c c.c d.d”。使用变量的替换引用将变量“sources”以空格分开的值中的所有的字的尾字符“o”替换为“c”，其他部分不变，注意这里的d.d并不会被替换。 使用变量改进我们complicated项目的makefile(v1.2)： 描述：complicated 项目 makefile文件 版本：v1.2 修改记录： 1. 为complicated项目makefile添加注释 2. 使用变量改进我们complicated项目的makefile 定义可执行文件变量 executbale := complicated 定义源文件列表变量 sources := main.c complicated.c 使用变量的引用替换，定义object文件列表 objects := $(sources:.c=.o) 定义编译命令变量 CC := gcc 终极目标规则，生成complicated可执行文件 $(executbale): $(objects) 使用自动化变量改造我们的编译命令 $(CC) -o $@ $^ 子规则1, main.o的生成规则 main.o: main.c $(CC) -o $@ -c $ 子规则2，complicated.o的生成规则 complicated.o: complicated.c $(CC) -o $@ -c $ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"basic/summary.html":{"url":"basic/summary.html","title":"C++基础知识补充","keywords":"","body":"基础知识 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 10:51:22 "},"basic/chap1/SUMMARY_01.html":{"url":"basic/chap1/SUMMARY_01.html","title":"从C过渡到C++","keywords":"","body":"Part 1 从C过渡到C++ 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 14:41:53 "},"basic/chap1/内联函数.html":{"url":"basic/chap1/内联函数.html","title":"内联函数","keywords":"","body":"内联函数 通过“内存膨胀”，空间换时间，提高程序的运行速度 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用 如下风格的函数Foo 不能成为内联函数： inline void Foo(int x, int y); // inline 仅与函数声明放在一起 void Foo(int x, int y) { } 而如下风格的函数Foo 则成为内联函数： void Foo(int x, int y); inline void Foo(int x, int y) // inline 与函数定义体放在一起 { } 所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。 一般地，用户可以阅读函数的声明，但是看不到函数的定义。 尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。 inline只适合涵数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数(自己内部还调用自己的函数)。 以下情况不宜使用内联： （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 16:42:35 "},"basic/chap1/函数重载.html":{"url":"basic/chap1/函数重载.html","title":"函数重载","keywords":"","body":"函数重载 在同一个项目中定义的函数名字可以重复 函数名一致 参数列表不同 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 16:44:37 "},"basic/chap1/函数参数缺省.html":{"url":"basic/chap1/函数参数缺省.html","title":"函数参数缺省","keywords":"","body":"函数参数缺省 定义函数的时候可以让最右边的连续若干个参数有缺省值，在调用函数的时候，如果不写相应位置的参数，则调用的参数就为缺省值。 形参，从后往前给，必须倒着，譬如先c,后b,再后a 例如：void fun(int a, int b = 1, int c = 2) { cout 在调用时，如果参数b和c的参数没有给出，则默认为缺省值。 函数缺省参数的作用在于提高程序的可扩充性。 比如某个以及写好的函数需要添加新的参数，而原先调用函数的的那些语句未必需要新增加的参数，为了避免对原来所有调用该函数的地方进行修改，就可以使用函数缺省参数了。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 17:01:27 "},"basic/chap1/引用.html":{"url":"basic/chap1/引用.html","title":"引用","keywords":"","body":"引用 引用基础 引用的概念 引用是一个变量的“别名”，对应的是同一段内存，也就意味这可以通过引用来修改被引用变量的值； 引用的基础语法： Type & name = var； int b = 1; int &a = b; 引用基础使用 引用的定义时必须进行初始化； //test5.cpp #include using namespace std; struct Teacher { int age_ = 31; int &a; //error 引用没有初始化； float &b; //error 引用没有初始化； }; int main() { int a = 10; // int & b; // error, 引用没有初始化； //Teacher my_teacher; } 基础类型的引用； //test1.cpp #include using namespace std; int main() { int a = 10; int &b = a; // 必须进行初始化； b = 11; // 使用引用可以修改被引用变量的值； cout 自定义类型的引用； //test2.cpp #include using namespace std; struct Teacher { int age_ = 30; float height_ = 174.5; }; int main() { Teacher my_teacher; Teacher &one_teacher = my_teacher; one_teacher.age_ = 31; std::cout 引用不能改变目标（在定义时确认了引用对象后，不能再修改引用对象） //test4.cpp #include using namespace std; int main() { int a = 10; int c = 11; int &b = a; // 必须进行初始化； b = c; // b 并没有指向c, 它还是a的别名，但a的值变成了与c一样； cout 引用做函数参数 引用作为函数的参数可以不进行初始化； //test3.cpp #include using namespace std; struct Teacher { int age_ = 30; float height_ = 174.5; }; void MyFun(Teacher &OneTeacher) { OneTeacher.height_ = 185.9; } int main() { Teacher my_teacher; MyFun(my_teacher); std::cout 引用的本质 引用的实质 从基础类型的引用来看，引用规定定义时必须进行初始化，这一点与const变量的定义要求很像，且通过引用可以直接修改被引用变量中的值，所以带有指针的属性； 引用的本质： const类型的指针；（编译器实现） 本身所占地址空间与指针一样（跟系统和编译器有关）； //test7.cpp #include using namespace std; struct Teacher { int age_ = 30; // 8个字节 float height_ = 174.5; // 4字节 double weight_ = 70.0; //8字节 int &a; // 未初始化，仅仅用来试验内存占用大小，与指针占用大小一样 }; void MyFun(Teacher &OneTeacher) { OneTeacher.height_ = 185.9; } int main() { /* 基础数据类型 */ int a = 11; int &b = a; // 等价于： int *const b = &a; // b是一个int类型的指针，指针本身不能变，指针内所指内容可以变； b = 12; // 等价于 （*b) = 12; /* 引用本身占4个字节 */ int *pt = NULL; cout 引用的意义 是指针的一种封装和简化，提升了代码的可读性和安全性； 引用难点 引用作为函数的返回值 （1）返回基础数据类型的引用 若返回的是一个临时变量，不能作为其他引用的初始值，不能当做左值使用；（在有些编译器中，返回临时变量的引用，既不能当左值，又不能当右值）； //test8.cpp #include using namespace std; /* 返回临时变量的引用 */ int& MyFun1() { int var = 10; return var; } int main() { int a = 0; // a = MyFun1(); // error // int &b = MyFun1(); //error } 若返回的是一个静态变量或者全局变量，可以作为其他引用的初始值，既可以作为左值，也可以作为右值； //test9.cpp #include using namespace std; int global_var1 = 8; int global_var2 = 77; int& MyFun1() { return global_var1; } int& MyFun2() { return global_var2; } int& MyFun3() { static int c = 4; return c; } int main() { /* 返回引用作为右值 */ int a = MyFun1(); cout 思考： 本质返回的就是一个地址，关键是这个地址里面的数会不会变化； 当返回的是函数内部的临时变量时，函数运行完内存就销毁，所以不能作为左值； 承接的时候，需要结合返回的地址和接受的地址综合考虑，函数运行完，返回的是这个地址的副本，如果用值去接，能接到值，如果用地址（含引用）去接，那么接到的有可能就是值（跟编译器相关） （2）返回自定义类型的引用（类） 【todo】 涉及拷贝构造函数和运算符重载，后续填坑； 常引用 常引用：不能通过引用去修改被引用的变量； //test10.cpp #include using namespace std; int main() { int a = 11; const int &b = a; //b = 12; //error ，不能通过常引用去修改被引用对象； a = 13; // 原变量还是可以修改的 } 常引用的初始化，可以用字面量进行初始化，也可以使用变量进行初始化； 非const引用，不能使用字面量进行初始化； const引用使用字面量进行初始化时，c++中const本身应该放到符号表中，没有分配内存空间，但当看到&操作符时， C++编译器会单独分配一个内存空间用于存放字面量； //test11.cpp #include using namespace std; int main() { int a = 11; const int &b = a; // 通过变量进行初始化； const int &c = 12; // 通过值进行初始化； // int &d = 13; //error, 非const引用不能使用字面量进行初始化； } 指针与引用 引用 指针 必须初始化 可以不初始化 不能为空（NULL） 可以为空（NULL） 不能更换目标 可以更换目标 引用与指针的性能基本一致； 引用不能为NULL，但指针可以为NULL，所以指针使用前必须检查是否为NULL，指针不用； OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 17:11:10 "},"basic/chap1/引用与取址的区分.html":{"url":"basic/chap1/引用与取址的区分.html","title":"引用与取址的区别","keywords":"","body":"引用和取址的区别 引用在赋值=的左边，而取地址在赋值的右边，比如 int a=3； int &b=a； //引用 int *p=&a; //取地址 和类（或函数定义处）在一起的是引用， 和变量在一起的是取址。 举例同样如上，还有下例： int function(int &i) { } //和类型在一起的是引用 对于vector，上面2条同样适合 vector vec1(10,1); //initialize vec1: 10 elements, every element's value is 1 vector &vec2 = vec1; // vec2 is reference to vec1 vector *vec3 = &vec2; //vec3 is addresss of vec1 and vec2 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 02:20:03 "},"basic/chap1/指针和引用的区别.html":{"url":"basic/chap1/指针和引用的区别.html","title":"指针与引用的区别","keywords":"","body":"指针和引用的区别 指针和引用的区别： 首先，引用不可以为空，但指针可以为空。前面也说过了引用是对象的别名，引用为空——对象都不存在，怎么可能有别名！故定义一个引用的时候，必须初始化。因此如果你有一个变量是用于指向另一个对象，但是它可能为空，这时你应该使用指针；如果变量总是指向一个对象，i.e.，你的设计不允许变量为空，这时你应该使用引用。而声明指针是可以不指向任何对象，也正是因为这个原因，使用指针之前必须做判空操作，而引用就不必。 其次，引用不可以改变指向，对一个对象\"至死不渝\"；但是指针可以改变指向，而指向其它对象。说明：虽然引用不可以改变指向，但是可以改变初始化对象的内容。例如就++操作而言，对引用的操作直接反应到所指向的对象，而不是改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容。 再次，引用的大小是所指向的变量的大小，因为引用只是一个别名而已；指针是指针本身的大小，4个字节 最后，引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。const 指针虽然不能改变指向，但仍然存在空指针，并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针） 总之，一句话归纳为：指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名，引用不改变指向。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 17:18:29 "},"basic/chap1/命名空间.html":{"url":"basic/chap1/命名空间.html","title":"命名空间","keywords":"","body":"命名空间 命名空间的概述 在c++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等。工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namespace（命名空间/名字空间/名称空间），可以更好地控制标识符的作用域。 命名空间的定义 //定义一个名字为A的命名空间（变量、函数） namespace A { int a = 100; } namespace B { int a = 200; } void test02() { //A::a a是属于A中 cout 命名空间只能全局范围内定义 命名空间可以嵌套 namespace A { int a = 1000; namespace B { int a = 2000; } } void test03() { cout命名空间是开放的，即可以随时把新的成员加入已有的命名空间中(常用) namespace A { int a = 100; int b = 200; } //将c添加到已有的命名空间A中 namespace A { int c = 300; } void test04() { cout命名空间 可以存放 变量 和 函数 namespace A { int a=100;//变量 void func()//函数 { cout命名空间中的函数 可以在“命名空间”外 定义 namespace A { int a=100;//变量 void func(); } void A::func()//成员函数 在外部定义的时候 记得加作用域 { //访问命名空间的数据不用加作用域 cout无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接（了解） namespace{ int a = 10; void func(){ cout给命名空间 取个别名（了解） namespace veryLongName{ int a = 10; void func(){ cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 03:49:11 "},"basic/chap1/new和delete.html":{"url":"basic/chap1/new和delete.html","title":"new和delete","keywords":"","body":"new和delete new作用类似malloc delete作用类似free malloc/free 和 new/delete的区别 malloc和free是函数，new和delete是操作符 malloc申请的空间不会初始化，new可以初始化 malloc申请空间时需要手动计算空间大小并传递，new不需要 malloc的返回值为void*，使用时必须强转来接收，new不需要 malloc申请失败时返回NULL，new申请失败会抛异常 申请自定义类型的对象时，malloc/free不会调用构造函数和析构函数，而new会申请空间后调用构造函数，delete会调用析构函数后再释放空间 new 1、类型指针 指针变量名 = new 类型 2、类型指针 指针变量名 = new 类型(初始值) 3、类型指针 指针变量名 = new 类型[元素个数] delete 1、delete 指针变量名 2、delete[] 指针变量名 new去申请对象会先申请对象的空间并调用对象的构造函数完成对象的初始化；delete会先去完成对象的资源清理，再将对象所占的空间释放掉。 但是要注意，如果没有默认构造函数，我们必须在new一个对象时后面要加小括号给予初始值进行初始化。没有默认构造函数，我们也不能申请连续的多个空间。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 11:23:30 "},"basic/chap1/cin和cout.html":{"url":"basic/chap1/cin和cout.html","title":"cin和cout","keywords":"","body":"cin和cout cin类似scanf cout类似printf OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 11:21:49 "},"basic/chap2/summary_02.html":{"url":"basic/chap2/summary_02.html","title":"面向对象的思想","keywords":"","body":"Part 2 面向对象的思想 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 14:43:04 "},"basic/chap2/面向过程与面向对象.html":{"url":"basic/chap2/面向过程与面向对象.html","title":"面向过程与面向对象","keywords":"","body":"面向过程与面向对象 面向过程 提出问题 --- 分析问题 --- 处理问题 大问题 --- 小问题 面向对象 面向对象的程序设计 是面向过程的继承和发展 可理解为： 现实世界是由对象组成的 对象在程序中抽象为两部分：属性【数据】、行为【函数】 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 14:59:34 "},"basic/chap2/类与对象.html":{"url":"basic/chap2/类与对象.html","title":"类与对象","keywords":"","body":"类与对象 类是一种用户自定义的数据类型（函数、数据） 类是 具有相同属性 和行为的 对象 的集合 类是对象的抽象， 对象是类的具体 对象： 通过使用类 类型定义的变量 定义类 class 类名 { // 默认是私有的 // 成员： 1数据 2函数 private: // 私有 ，在类的内部访问 public: // 公有 ， 在类的内部和外部都能访问 protected: // 被保护 ，在类的内部访问，在类的子类能访问 }; 定义对象 类名 对象名; 类名 指针名; C++中class 与 struct 可以用class定义类， 也可以用struct定义类(一般不建议用)，struct还可以定义结构体 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 15:20:53 "},"basic/chap3/summary_03.html":{"url":"basic/chap3/summary_03.html","title":"构造函数与析构函数","keywords":"","body":"Part 3 构造函数与析构函数 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 15:19:09 "},"basic/chap3/构造函数.html":{"url":"basic/chap3/构造函数.html","title":"构造函数","keywords":"","body":"构造函数 普通构造函数 是一个特殊的成员函数 主要用户来在创建对象的时候，初始化对象 为对象的成员变量 赋 初始值 构造函数 和 类名相同 构造函数没有返回值类型， 也没有返回值 构造函数可以重载，需满足函数重载的条件 在创建一个新的对象是，会自动调用构造函数 如果一个类中没有显式的给出构造函数， 系统会自动生成一个构造函数 有时数据成员必须初始化，但又不能在构造函数中赋值 可以使用 成员初始化列表 的方式给数据成员赋值 const ，修饰变量时，使其改变性质变成常量 class test { private: /* data */ int value; public: test(/* args */); ~test(); const int id = 0; // id变成常量 const int td = 0; // id变成常量 test(int v, int n); void set_value(int v); // 设置私有变量 int get_value(); // 获取私有变量 int num; }; test::test(/* args */) { } test::test(int v, int n) : id(v), td(n) // 使用成员函数列表给 成员赋值 { num = n; value = v; } test::~test() { } void test::set_value(int v) { } int test::get_value() { } int main() { test _t; // 创造对象时候，自动调用构造函数test() test _t1(1, 2); // 创建对象时候，自动调用构造函数 test(int v, int n) test *p = new test; // 无参构造test类型的指针 test *p1 = new test(1, 2); // 有参构造test类型的指针 return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 15:54:30 "},"basic/chap3/析构函数.html":{"url":"basic/chap3/析构函数.html","title":"析构函数","keywords":"","body":"析构函数 是一种特殊的函数 对象生命周期结束的时候，进行清理的函数 系统可以自动调用析构函数-- 在对象生命周期结束时， 会自动调用析构函数 不是因为调用析构而结束生命周期， 而是因为生命周期结束而调用析构 函数名与类名相同， 在前面加一个 ~ 没有返回值类型和返回值， 也没有参数 没有写，则系统会自动生成 析构函数可以主动通过 对象调用 析构函数必须是公有属性下 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 16:12:55 "},"basic/chap3/拷贝构造函数.html":{"url":"basic/chap3/拷贝构造函数.html","title":"拷贝构造函数","keywords":"","body":"拷贝构造函数 一种特殊的构造函数 通过拷贝构造函数完成一个复制的过程 特殊： 第一个参数是本类 的 对象 的引用 先是构造函数，才可能是拷贝构造函数 没写，但系统会生成， 将成员意义对应赋值 可以自定义 先构造出来的后析构 调用的时机 使用一个对象 给 另一个对象进行初始化 使用 一个对象 构造另一个对象 函数的参数是 类的对象 函数的返回值是 类的对象 浅拷贝 与 深拷贝 浅拷贝： 默认都是前拷贝， 属于无脑抄袭 深拷贝： 需根据自己实际情况实现， 属于改抄的地方抄， 不改抄的地方要修修改改 如何防止默认拷贝的发生？ 声明一个私有的拷贝构造函数，但不对其进行定义【防止低保，且不实现， 主动让程序报错，有备而来】 #include class testcpoy { private: /* data */ public: int m_age; int m_weight; float m_spped; int *p; public: testcpoy(/* args */); ~testcpoy(); testcpoy(int age, int weight, float spped); testcpoy(testcpoy &obj); // 拷贝构造函数，第一个参数是 本类型的对象的 引用 testcpoy(testcpoy &obj, int i); // 拷贝构造函数，第一个参数是 本类型的对象的 引用 testcpoy(testcpoy &obj, int i, int j); // 拷贝构造函数，都一个参数是 本类型的对象的 引用 }; testcpoy::testcpoy(/* args */) { // 无参数构造 p = NULL; } testcpoy::~testcpoy() { // 析构 } testcpoy::testcpoy(int age, int weight, float spped) { // 有参数构造 p = new int[10]; } testcpoy::testcpoy(testcpoy &obj) { // 拷贝构造 p = new int(10); for (size_t i = 0; i OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 03:02:15 "},"basic/chap4/summary_04.html":{"url":"basic/chap4/summary_04.html","title":"特殊情况","keywords":"","body":"Part 3 特殊情况 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 08:04:49 "},"basic/chap4/this指针.html":{"url":"basic/chap4/this指针.html","title":"this指针","keywords":"","body":"this指针 系统自动生成， 且是隐藏的，但可以使用 this指针， 不是对象的一部分， 作用域在类内部 类的普通函数 访问类的普通成员时， this指针总是指向 调用者对象 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 03:11:25 "},"basic/chap4/static成员.html":{"url":"basic/chap4/static成员.html","title":"static成员","keywords":"","body":"static成员 声明成员时，加上static关键字 静态成员分为：静态数据成员 + 静态函数成员 静态数据成员： 所有该类生成的对象， 都共用这些静态数据成员 静态成员函数： 函数里不能访问 类 内 的 普通成员， 且没有this指针 class test { private: /* data */ public: test(/* args */); ~test(); static int num; // 静态数据成员 ，不能在构造函数中初始化， 也不能在成员参数初始化列表 初始化 static void fun_1(); // 静态成员函数 }; int test::num = 0; // 可以这样初始化 test::test(/* args */) { } test::~test() { } void test::fun_1() { } int main() { int a = test::num; // 属于类，可以用类名调用 test::fun_1(); // 属于类，可以用类名调用 return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 03:57:31 "},"basic/chap4/单例模式.html":{"url":"basic/chap4/单例模式.html","title":"单例模式","keywords":"","body":"单例模式 一种设计模式， 创建一个 只能 实例化一个对象的类 通过对构造函数进行限制 设置为私有 #include class testSingleInstance { private: /* data */ testSingleInstance(/* args */); testSingleInstance(const testSingleInstance &obj); static testSingleInstance *p_instance; public: ~testSingleInstance(); static testSingleInstance *getInstance(); }; testSingleInstance *testSingleInstance::p_instance = NULL; testSingleInstance::testSingleInstance(/* args */) { } testSingleInstance::testSingleInstance(const testSingleInstance &obj) { } testSingleInstance::~testSingleInstance() { } testSingleInstance *testSingleInstance::getInstance() { if (p_instance == NULL) { p_instance = new testSingleInstance; } return p_instance; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 04:05:56 "},"basic/chap4/const成员.html":{"url":"basic/chap4/const成员.html","title":"const成员","keywords":"","body":"const成员 在声明成员时 加上const 关键字 常量成员分为： 常量数据成员 和 常量成员函数 常量数据成员： 常量成员函数： 不能修改类的任何普通数据成员 ，但可以修改 静态数据成员 常量对象： 常对象的普通数据成员都不能修改,但可以修改 静态数据成员 常对象 只能调用 静态成员函数， 不能调用普通成员函数 class testConst { private: /* data */ public: testConst(/* args */); testConst(int v); ~testConst(); int num; const int val; // 常量数据成员 ，使用成员初始化列表 void func_1(); void func_2() const; // 常量成员函数 }; testConst::testConst(/* args */) : val(10) // 使用成员初始化列表给值 { } testConst::testConst(int v) : val(v) // 使用成员初始化列表给值 { } testConst::~testConst() { } void testConst::func_1() { } void testConst::func_2() const // 类的外面 实现 常量成员函数时， const 是属于函数的一部分名不能省略 { } int main() { return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 05:21:21 "},"basic/chap4/友元关系.html":{"url":"basic/chap4/友元关系.html","title":"友元关系","keywords":"","body":"友元关系 类的特性之一是封装， 友元是打破封装的 手段 友元分为：友元函数、友元类, 【友元是单方向的，且不存在传递关系，且不继承】 友元函数： 友元类 ：可以创建友元对象 class testfriend { private: /* data */ friend void test_friend_1(testfriend obj); // testfriend 把test_friend_1 函数当作朋友， 友元函数, 把test_friend_1 函数就可以调用testfriend类的私有数据 friend class B; // testfriend B 类当作朋友， 友元类, 则B类 就可以调用testfriend类的私有数据 public: testfriend(/* args */); ~testfriend(); }; testfriend::testfriend(/* args */) { } testfriend::~testfriend() { } void test_friend_1(testfriend obj) { } class B { public: void test(testfriend obj); }; void B::test(testfriend obj){ } int main() { return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 08:02:06 "},"basic/chap5/summary_05.html":{"url":"basic/chap5/summary_05.html","title":"继承与派生","keywords":"","body":"Part 5 继承与派生 不影响到原来的类， 不该原来类的代码， 实现对功能的扩展 在原有类的基础上快递增加新的功能 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 09:10:54 "},"basic/chap5/继承和派生介绍.html":{"url":"basic/chap5/继承和派生介绍.html","title":"继承和派生介绍","keywords":"","body":"继承和派生 继承概念： 基于已有的类，创建新类的方式。【可以继承自一个，或 多个类】 A ====> B A：父类【基类】：原来的类， B：子类【派生类】：新创建的类 描述的是 类与类之间的关系 继承和派生： 实际是同一个过程，在不同角度的称呼 子类视角： 继承 ”自父亲“ 父类视角： 派生 “给孩子” 继承种类： 单继承：一个父类 多继承：多个父类 继承： 继承是 子类继承 父类的全部成员 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 08:20:54 "},"basic/chap5/继承方式.html":{"url":"basic/chap5/继承方式.html","title":"继承方式","keywords":"","body":"继承方式 单继承 /** * 单继承 * */ // 父类 class A { }; // 子类 // class 子类名称 : 继承权限 父类名 class B : public A { }; 多继承 /** * 多继承 * */ // 父类 class AA { }; class BB { }; // 子类 // class 子类名称 : 继承权限 父类名1, 继承权限 父类名2, ... ,继承权限 父类名N // 继承权限： // 公有继承 public // 私有继承 private // 保护继承 protected class CC : public AA, public BB { }; 继承权限 ||公有继承 public|私有继承 private|保护继承 protected| |public|public|privtae|protected| |private|不可访问|不可访问|不可访问| |protected|protected|private|protected| 多级继承（A -> B ->C） 继承权限，只需要关注最近的 父类结果， 直接分析最近父子类 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 08:28:28 "},"basic/chap5/父子关系.html":{"url":"basic/chap5/父子关系.html","title":"父子关系","keywords":"","body":"父子关系 派生类的构成 构造和析构不从父类继承，其他的都会继承 父类对象 不能给 子类对象赋值， 但 子类对象 可以给父类对象赋值 父类指针 可以指向 子类对象 ， 但 子类指针 不能 指向父类对象 派生类的构造析构顺序 子类如果要调用父类的带参构造，可以放在成员初始化列表中 父类先构造，之后子类构造 先构造的后析构 #include class A { public: A(); ~A(); int val; int num; }; A::A() { num = 10; } A::~A() { } class B : public A { public: B(); ~B(); int num; }; B::B() { num = 20; } B::~B() { } int main() { B b; std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 08:59:52 "},"basic/chap5/菱形继承.html":{"url":"basic/chap5/菱形继承.html","title":"菱形继承","keywords":"","body":"菱形继承 A ->A1 ; A -> A2; A1,A2 ->AA 同时从A 继承出来的 数据成员，怎么访问 方法一： 通过类名:: 成员名 方法二： 虚继承， class A1 : virtual public A ; class A2 : virtual public A ; 如果A1、A2有重复继承则最终只保留一份A的数据成员 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 09:09:13 "},"basic/chap6/summary_06.html":{"url":"basic/chap6/summary_06.html","title":"多态","keywords":"","body":"Part 6 多态 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:40:50 "},"basic/chap6/联编.html":{"url":"basic/chap6/联编.html","title":"联编","keywords":"","body":"联编 联编：就是将模块或者函数合并在一起生成可执行代码的处理过程，同时对每个模块或者函数调用分配内存地址，并且对外部访问也分配正确的内存地址，它是计算机程序彼此关联的过程。 按照联编所进行的阶段不同，可分为两种不同的联编方法：静态联编和动态联编。 静态联编：指在编译阶段就将函数实现和函数调用关联起来，因此静态联编也叫早绑定， 在编译阶段就必须了解所有的函数或模块执行所需要检测的信息，它对函数的选择是基于指向对象的指针（或者引用）的类型 C语言中，所有的联编都是静态联编,并且任何一种编译器都支持静态联编。 动态联编：指在程序执行的时候才将函数实现和函数调用关联，因此也叫运行时绑定或者晚绑定， 动态联编对函数的选择不是基于指针或者引用，而是基于对象类型，不同的对象类型将做出不同的编译结果 C++中一般情况下联编也是静态联编，但是一旦涉及到多态和虚拟函数就必须要使用动态联编了 实现动态联编的条件 在一个类里，且需要有虚函数， 且该类为父类，且被继承 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 12:39:08 "},"basic/chap6/多态.html":{"url":"basic/chap6/多态.html","title":"多态","keywords":"","body":"多态 多态的概念 意味着调用成员函数时，会根据 调用函数的 对象[主体]的类型 来执行不同的函数。 【主体】->调用函数 子类不会继承父类的 虚函数表 通过类的继承和虚函数，实现多态 虚函数成员的父类 同名函数成员的子类 指针： 父类类型的指针，指向父类 或 子类对象 #include class Fa { private: /* data */ public: Fa(/* args */); virtual ~Fa(); // 父类 虚析构 virtual void test_func(); // 声明虚函数 }; Fa::Fa(/* args */) { } Fa::~Fa() { } void Fa::test_func() { std::cout test_func(); // 根据指针 指向的类型，进行调用对应的函数，动态联编 p = &son; p->test_func(); p = &son1; p->test_func(); delete p; p = NULL; return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 12:39:06 "},"basic/chap6/纯虚函数.html":{"url":"basic/chap6/纯虚函数.html","title":"纯虚函数","keywords":"","body":"纯虚函数 纯虚函数：没有函数体的虚函数 virtual 函数类型 函数名() = 0; 纯虚函数， 当前类不做实现， 由他的子类去实现 只要包含纯虚函数的类，被称为 抽象类 不允许用来 定义对象， 但可以用来定义指针 class testvirtual { private: /* data */ public: testvirtual(/* args */); virtual ~testvirtual(); virtual void test_func() = 0; // 纯虚函数， 当前类不做实现， 由他的子类去实现 }; testvirtual::testvirtual(/* args */) { } testvirtual::~testvirtual() { } class son : public testvirtual { private: /* data */ public: son(/* args */); ~son(); void test_func(); }; son::son(/* args */) { } son::~son() { } void son::test_func() { } int main() { testvirtual *p; son son1; p = &son1; p->test_func(); return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 12:49:01 "},"basic/chap6/final.html":{"url":"basic/chap6/final.html","title":"final","keywords":"","body":"final 权限掠夺者 掠夺函数权限：阻止重写 掠夺类的权限：阻止派生 class testfinal { private: /* data */ public: testfinal(/* args */); ~testfinal(); virtual void test() ; }; testfinal::testfinal(/* args */) { } testfinal::~testfinal() { } class son : public testfinal { private: /* data */ public: son(/* args */); ~son(); void test() final; }; son::son(/* args */) { } son::~son() { } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:01:24 "},"basic/chap7/summary_07.html":{"url":"basic/chap7/summary_07.html","title":"运算符重载","keywords":"","body":"Part 7 运算符重载 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:02:48 "},"basic/chap7/基础语法.html":{"url":"basic/chap7/基础语法.html","title":"基础语法","keywords":"","body":"基础语法 重载的概念 在同一作用域中的某个函数和运算符指定多个定义，分别称为【函数重载】和【运算符重载】。 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。 当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策 重载函数 在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。 #include using namespace std; class printData { public: void print(int i) { cout 重载运算符 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 #include using namespace std; class Box { public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box& b) { Box box; box.length = this->length + b.length; box.breadth = this->breadth + b.breadth; box.height = this->height + b.height; return box; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; // 程序的主函数 int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:21:18 "},"basic/chap7/规则详解.html":{"url":"basic/chap7/规则详解.html","title":"规则详解","keywords":"","body":"规则详解 一个类两个对象之间成员进行运算必须重新定义，让编译器在遇到对象运算时能按我们要求的进行运算，这就是运算符重载的意义，即重定义运算符，【运算符重载就是为类对象服务的】 可重载运算符 和不可能重载运算符 运算符重载函数， 不能有默认的参数 运算符重载函数 可以做为类的 成员函数， 可以作为全局函数 下面是可重载的运算符列表 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)， (大于)，=(大于等于) 逻辑运算符 ||(逻辑或)，&&(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&(取地址) 自增自减运算符 ++(自增)，--(自减) 位运算符 | (按位或)，& (按位与)，~(按位取反)，^(按位异或),，>(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &=, |=, ^=, >= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，->(成员访问)，,(逗号)，[](下标) 下面是不可重载的运算符列表： . ：成员访问运算符 .*, ->* ：成员指针访问运算符 :: ：域运算符 sizeof ：长度运算符 ?: ：条件运算符 # ： 预处理符号 箭头运算符 -> 下标运算符[] 赋值运算符= 函数调用运算符() ; 只能以成员函数的形式重载 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:28:29 "},"basic/chap7/重载<< 与 >>.html":{"url":"basic/chap7/重载<< 与 >>.html","title":"重载<<与>>","keywords":"","body":"重载> 重载输出和输入 作为友元函数重载 istream :输入 ostream :输出 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:38:54 "},"basic/chap8/summary_08.html":{"url":"basic/chap8/summary_08.html","title":"模板","keywords":"","body":"Part 8 模版 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 10:51:20 "},"basic/chap8/函数模板.html":{"url":"basic/chap8/函数模板.html","title":"函数模板","keywords":"","body":"函数模板 通过函数模板 定义模板函数 /** * 通过函数模板 定义模板函数 * template * 返回值类型 函数名(形参列表){ * 函数体 * } */ 函数模板 与 普通函数对比 都可以重载 如果两个同名函数且同参数个数（模板 与普通）同时存在， 会先先访问普通函数 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 14:47:28 "},"basic/chap8/类模板.html":{"url":"basic/chap8/类模板.html","title":"类模板","keywords":"","body":"类模板 类模板形式 /** * template * class 模板类名{ * 成员 * } * * 类型参数列表: * **/ 类模板当做函数参数 template // 将类型当作模板 template // 直接将类作为模板 template // 将类型当作模板 void test_func1(testclassTemplate &obj) { obj.showData(); } template // 直接将类作为模板 void test_func2(TTT1 &obj) { obj.showData(); } testclassTemplate data1(1, 2); data1.showData(); testclassTemplate data2('qwe', 21); data2.showData(); test_func(data1); test_func1(data1); test_func2>(data2); 模板类的继承 ``` /** 模板类的继承 */ template class Father { public: F_type num; }; template class Son : public Father { public: S_type1 val; }; include /** template class 模板类名{ 成员 } * 类型参数列表: */ template class testclassTemplate { private: / data / T1 name; T2 age; public: testclassTemplate(T1 i, T2 j) : name(i), age(j){}; ~testclassTemplate(); // get /set T1 getName() { return name; } T2 getAge() { return age; } void setName(T1 i) { name = i; } void setAge(T2 j) { age = j; } void showData(); }; template void testclassTemplate::showData() { std::cout testclassTemplate::~testclassTemplate() { } void test_func(testclassTemplate &obj) { obj.showData(); } template // 将类型当作模板 void test_func1(testclassTemplate &obj) { obj.showData(); } template // 直接将类作为模板 void test_func2(TTT1 &obj) { obj.showData(); } int main() { testclassTemplate data1(1, 2); data1.showData(); testclassTemplate data2('qwe', 21); data2.showData(); test_func(data1); test_func1(data1); test_func2>(data2); return 0; } ``` OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 07:46:22 "},"basic/chap8/模板和友元.html":{"url":"basic/chap8/模板和友元.html","title":"模板和友元","keywords":"","body":"模板和友元 #include template class A { private: /* data */ T m_a; friend void show(A &obj) { } // 模板类的友元函数 public: A(T t = 0) : m_a(t) {} ~A() {} }; template int main() { A obja; show(obja); } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 07:57:30 "},"basic/chap9/summary_09.html":{"url":"basic/chap9/summary_09.html","title":"补充知识点","keywords":"","body":"Part 9 补充知识点 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 07:59:06 "},"basic/chap9/异常处理机制.html":{"url":"basic/chap9/异常处理机制.html","title":"异常处理机制","keywords":"","body":"异常处理机制 异常:程序执行过程中出现的问题 C++中的异常处理 方法 throw : 抛出异常 try : 尝试 catch : 处理异常try{ // code 直接或间接 throw 抛出异常 // code } catch(接收异常){ 处理异常 } 使用自定义异常 #include #include double test_func(double a, double b) { if (b == 0.0) { // throw 抛出异常 // 抛出异常信息：支持多种类型 throw \"这里有异常！b不能为0！！！\"; // 触发throw则会中断 test_func程序，后面的就不会再执行 } return a / b; } // 自定义异常类 class CustomException : public exception { public: const char *what() const; }; const char *CustomException::what() const { return \"自定义的异常\"; } int main() { std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 10:04:51 "},"basic/chap9/文件流.html":{"url":"basic/chap9/文件流.html","title":"文件流","keywords":"","body":"文件流 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 fstream :常用的文件操作类 文件的打开方式 void open(const char *filename, ios::openmode mode); 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 【将文件输入到程序】 ios::out 打开文件用于写入。【将文件从程序输出出去】 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 #include #include int main() { fstream obj; obj.open(\"test1.txt\", ios::out); // 打开文件，(文件路径，打开方式) obj.put('s12ad'); // 写入 obj.close(); obj.open(\"test1.txt\", ios::in); // 打开文件，(文件路径，打开方式) char outt; outt = obj.get(); // 读取 // obj.get(outt); // 读取 std::cout >读写文件 obj.open(\"test3.txt\", ios::out); // 打开文件，(文件路径，打开方式) obj > val; // 读取 std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 10:31:04 "},"basic/chap9/C++11标准.html":{"url":"basic/chap9/C++11标准.html","title":"C++11标准","keywords":"","body":"C++11标准 初始化的方式 新的写法不允许丢失精确度 int a = 0; int b(2.1); int m{4}; int n = {(int)3.14}; 指针置空 int *p = NULL; int *p = nullptr; 自动类型 int a=0; auto a=0; // 根据值匹配类型 decltype() 复制类型 int a=0; decltype(a)b; // 根据a的类型， 定义一个和a类型一致的b变量 decltype((a))m =a ; // 给a取别名 for规则 // 该方法 只能用来遍历 数组 等容器类型的数据 for(auto item:items){ std::cout 给类型取别名 typedef int INT; // 给int 取别名 INT typedef void(*pFun) PPFUN; using Int =int; // 给int 取别名 Int using PFUN = void(*pFun); default 在类中的用法 class CA{ public: CA(); } CA::CA() = default; // 默认调用默认构造 final OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 10:48:01 "},"game/summary.html":{"url":"game/summary.html","title":"C++游戏开发","keywords":"","body":"游戏开发 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:51:36 "}}