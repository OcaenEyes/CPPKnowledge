{"./":{"url":"./","title":"关于作者","keywords":"","body":"C++知识积累 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 14:40:48 "},"practice/summary.html":{"url":"practice/summary.html","title":"从入门到实战","keywords":"","body":"从入门到实战，一些经典有趣的实战案例 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:28:48 "},"practice/chap1/summary.html":{"url":"practice/chap1/summary.html","title":"基础知识","keywords":"","body":" Part 1 基础知识 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:37:47 "},"practice/chap1/c++语言概述.html":{"url":"practice/chap1/c++语言概述.html","title":"C++语言概述","keywords":"","body":" C++语言概述 C++ 语言的产生 C 语言最初是贝尔实验室的 Dennis Ritchie 在 B 语言的基础上开发出来的。C 语言具有运算符和数据结构丰富、语言简洁灵活、程序执行效率高等系列优点，被市场广泛应用。但 C 语言终究是面向过程的编程语言，与其他面向过程的编程语言一样，无法满足运用面向对象方法的开发需求。 而 C++ 语言便是在优化 C 语言的基础上为支持面向对象的程序设计而研制的一个通用目的的程序设计语言。在后来的持续研究中，C++ 增加了许多新概念，例如虚函数、重载、继承、标准模板库、异常处理、命名空间等。 C++ 语言的特点 C++ 语言的特点主要表现在两个方面： 全面兼容 C 语言 和 支持面向对象的方法。 由于 C++ 可以全面兼容 C，这就使得部分由 C 语言编写的代码在未经修改的情况下就可以为 C++ 所用，这极大的促进了 C++ 的普及和面向对象技术的广泛应用。 C++ 最具有意义的一面就是支持面向对象的方法。与 C 兼容的特点虽赋予 C++ 双重特点，但 C 和 C++ 在概念上却是两种完全不同的程序设计语言，所以在 C++ 中应注意按照面向对象的思维去编写代码。 此外，C++ 在保持 C 简洁、高效等特点的基础上，对 C 的类型系统进行改革和扩充，因此 C++ 编译环境能检测出的类型错误更多。 C++的扩展名和注释符 扩展名 C++ 源文件的扩展名与运行的具体编译器有关，一般有 .cc、.cxx、.cpp 和 .cp。与源文件相关的头文件扩展名一般是 .h。课程实验环境中的源文件扩展名一般为 .cpp，与之相关的头文件扩展名一般为 .h。 注释符 与其他语言类似，C++ 也有为代码提供辅助信息的注释符。 单行注释：//注释内容 int x;//定义 x 的数据类型为 int 块注释：/ 注释内容 / if(x>y)return x; else return y; /* 如果 x 大于 y 则返回 x 否则返回 y */ 注释符可以放置在代码的任何位置，且不参与代码运行。 命名空间 命名空间里面包含了逻辑结构上相互关联的一组类、函数、模板等。命名空间像是一个容器，把某些在逻辑结构上相关的 “ 对象 ” 放在一起并与外界区分。特别的，命名空间里的变量名或类名可以和命名空间外的变量名或类名重名。 使用命名空间的时候，我们可以用 花括号 把声明块括起来，再以关键字 namespace 开头并命名，其基本格式如下： namespace 命名空间的名字 { 声明块 } 其中声明块中可以包含变量、类、函数等。例如： namespace S { int x; void FunA() { ... } } 在命名空间外使用命名空间内的成员： 命名空间的名字加上作用域运算符 :: 。 参考上例 namespace S，若访问 x，可写成 S::x；访问 FunA() 则为 S::FunA()。 命名空间的嵌套， 具有分层屏蔽的作用。例如： namespace S1 { namespace S2 { int x; void FunA() { ... } } } 若要访问 x，则可写为 S1::S2::x，同理，访问 FunA() 则可写为 S1::S2::FunA()。 using 声明：若命名空间内的某个成员使用了 using 声明，那么这个成员在程序的后续使用中，可直接使用成员名，无需添加限定修饰名。使用 using 声明： 以关键字 using 开头后跟命名空间内的成员名。参考上例嵌套的命名空间： namespace S2 中 int x 的 using 声明为：using S1::S2::x; 。 注意： using namespace 后不能加类名或变量名。同上，若 namespace S2 中 int x 的 using 声明写为 using namespace S1::S2::x 便是错误的。 using 指示符可以一次性地使命名空间内的全体成员被直接使用。using 指示符的使用： 以关键字 using namespace 开头后跟命名空间名字。特别的，std 命名空间声明和定义了标准 C++ 库中的所有组件，使用 using namespace std; 则可使用标准 C++ 库中的所有成员。 C++语言的输入输出 C++ 标准 I/O 库包含 iostream、fstream 和 sstringstream。iostream、fstream 比较常用，一般操作于输入和输出，相较于前两者来说 sstringstream 的出现频率就低了许多，一般操作于数据的格式化。为了能更好的理解 C++ 语言的标准 I/O 库，我们参考 cplusplus 官网 的相关内容，整理注释了一份关于输入输出流类继承体系的关系图 标准输出流对象 cout 预定义的插入符 “ cout 在输出语句中，若串联多个插入符，则可输出多个数据项。例如： cout 则依次输出 a,b,c 三个数据项的值。 若插入符后面是复杂的表达式，则系统自动计算其表达式的值并传给插入符。例如： cout 依次输出字符串 “ a+b= ” 以及 a+b 的计算结果。 标准输入流对象 cin 预定义的提取符 “ >> ” 作用在流类对象 cin 上可实现对键盘输入的提取操作，其格式为： cin >> 表达式1 >> 表达式2... 其中表达式通常用于存放输入值的变量。例如： int a,b; cin >> a >> b; 即编译执行后，输入 a 和 b 的值，a 和 b 之间使用空格分隔。如输入：1 2，则给 a 赋值为 1，b 赋值为 2。 简单的 I/O 格式控制 一般情况下，使用 cin 和 cout 进行数据的输入和输出时，会自动按照默认的格式进行处理。如若需要设定特殊的格式，可利用 C++ I/O 流类库提供的操纵符进行调整。这些操纵符可直接嵌入到输入输出语句中实现格式控制。常用的 I/O 流类库操纵符： 操纵符名 含义 dec 数值数据采用十进制表示 hex 数值数据采用十六进制表示 oct 数值数据采用八进制表示 ws 提取空白符 endl 插入换行符，并刷新流 ends 插入空字符 setsprecision ( int ) 设置浮点数的小数位数，包括小数点 setw ( int ) 设置域宽 编译运行 GCC 和 G++ 是由 GNU 开发的编程语言编译器，其中 GCC 用来编译 C 语言程序；G++ 用来编译 C++ 语言程序。 g++ -o 的功能：生成可执行文件，其基本格式为: g++ 需生成可执行文件的源文件名 -o 可执行文件名称 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/基本数据类型.html":{"url":"practice/chap1/基本数据类型.html","title":"基本数据类型","keywords":"","body":" 基本数据类型 编写计算机程序的目的在于高效解决现实生活中的问题，正因如此，高级语言为我们提供了许多的数据类型。C++ 的数据类型分为基本数据类型和自定义数据类型，其基本数据类型如下： 数据类型名 长度（字节） 取值范围 char 1 -128 ~ 127 或 0 ~ 255 bool |1 |true, false signed char |1 |-128 ~ 127 unsigned char |1 |0 ~ 255 short |2 |-32768 ~ 32767 unsigned short |2 |0 ~ 65535 int |4 |-2147483648 到 2147483647 unsigned int |4 |0 ~ 4294967295 long |8 |-9223372036854775808 到 9223372036854775807 unsigned long |8 |0 到 18,446,744,073,709,551,615 float |4 |3.4E-38 ~ 3.4E+38 double |8 |1.7E-308 ~ 1.7E+308 long double |16 |长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 各种类型的存储大小和具体操作系统的位数有关，目前大部分系统为 64 位，与上表基本一致。 由上表可知，C++ 的基本数据类型一般包括：bool、char、int、float 和 double。其中关键字 signed、unsigned、short、long 被称为修饰符。特别的，当用 short 或 long 修饰 int 时，int 可省略不写，表示短整型数据或长整型数据。 string 类 string 是 C++ 标准库的一个重要部分，主要用于字符串的处理，string 类的头文件为：#include。使用 string 可以对字符串的对象执行某些操作，例如拼接、查找等。 此课程属性为基础入门，所以暂不对 string 类进行过多介绍。若想要深度了解或学习 string 类的相关知识，可在本次实验后继续学习 C++ 进阶应用实战 - 初识类与对象。 struct struct 是由一系列相同或不同的数据类型组成的数据集合，也称结构体，是一种复合型的数据类型。 C++ 语言中 struct 的基本结构 struct struct_name { memberList }varList 其中 struct 为结构体的关键字，struct_name 为结构体的名字，memberList 为结构体成员变量及成员函数的列表，varList 为结构体声明的变量。使用 varList.元素名 可调用结构体中的元素。 例如在实验环境中新建一个名为 stru.cpp 的文件并输入： #include using namespace std; struct shiyanlou //定义 shiyanlou 结构体。 { int a; //定义 a 的数据类型为整型。 int pri() {return a;}//定义 pri() 的功能为返回 a 的值。 }s1; int main() { cout其中 sbefore 输出未初始化变量的结果，safter 输出已初始化变量的结果： C++ 语言中 struct 与 C 语言中 struct 的区别 在 C++ 语言中，可直接使用结构体名来声明变量；在 C 语言中，不能直接使用结构体名来声明变量，需前缀 struct。 C++ 语言的 struct 中既可以定义成员变量又可以定义成员函数；C 语言的 struct 中只能定义成员变量，不能定义成员函数。例如： struct shiyanlou { int a; int pri() {return a;} }s1; 在 C++ 的编译过程中，此结构体不会出错。但若在 C 语言中，由于 int pri() {return a;} 为成员函数，会出现编译报错。 变量 变量来源于数学，是计算机语言中能储存计算结果且在程序执行过程中可以变化的量。变量需要用名字来标识且需指定相应的数据类型，变量声明的形式如下： 数据类型 变量名1，变量名2... 注意：变量的命名不是随意的，需遵守以下规则： 变量名只能包含字母（A-Z，a-z）和数字（0-9）或者下划线（_）。 变量名首位必须是字母或下划线。 不能使用 C++ 的关键字来命名变量，以免冲突。例如：struct。 变量名区分大小写。 例如声明两个 int 类型的变量：int a_1,b 变量分为局部变量与全局变量。由某对象或某个函数所创建的变量通常都是局部变量，只能被内部引用，而无法被其它对象或函数引用，全局变量是可以被本程序所有对象或函数引用。 局部变量 局部变量 只作用于当前模块。例如新建一个名为 localvar.cpp 的文件并输入： #include using namespace std; int main() { int a = 2; //此局部变量只作用于当前模块。 cout在主函数 int main() 中定义了一个局部变量 a 且赋值为 2，若在主函数中对局部变量 a 进行输出，则直接输出 2。 全局变量 当两个或两个以上模块或函数需要用到同一个变量时，可以把变量定义为 全局变量。例如新建一个名为 globalvar.cpp 的文件并输入： #include using namespace std; int global1 = 1; //定义全局变量 global1。 void func() { cout上述代码中，void func() 和 int main() 都需要使用变量 global1，即定义其为全局变量，供多个模块使用。 重名现象 当全局变量与局部变量重名的时候，起作用的是局部变量，全局变量被屏蔽掉。我们修改 globalvar.cpp 文件为以下内容： #include using namespace std; int global1 = 1; //定义全局变量 global1。 void func() { cout我们在 int main() 中定义局部变量 int global1，此时出现重名现象。则 int main() 中 cout 常量 常量是指具有固定值的表达式，其值在程序运行的整个过程中是不可改变的。常量一般分为整型常量、实型常量、字符常量、字符串常量和布尔常量。 整型常量 即以文字形式出现的整数，包括正整数、负整数和零。在 C++ 中支持十进制、八进制和十六进制的整数。 十进制表示的整型常量：由 - / + 和 若干 0 - 9 的数字组合，例如：2、- 2、356 等。 八进制表示的整型常量:以 0 开头后跟若干个 0 - 7 数字，例如：0333、06 等。 十六进制表示的整型常量：以 0x 开头后跟 0 - 9 的数字及 A-F 的字母，例如：0x12、0x3A 等。 一般的，当十进制表示的整型常量为正整数时，可省略 +；八进制和十六进制通常表示无符号的整数，所以不必添加 - / +。 实型常量 即以文字形式出现的实数，包括一般形式和指数形式。 一般形式，即正常表达的数字，例如：3.14、- 6.78 等。 指数形式，通俗来说就是我们在数学中常用的 n 乘以 10 的 x 次方，例如：3.1E+6 表示的则是 3.1 乘以 10 的 6 次方，即 3100000；6.9E-2 表示的则是 6.9 乘以 10 的 - 2 次方，即 0.069。 字符常量 用单引号括起来的一个字符称为字符常量。例如：'a'、'D' 等。 例如回车、换行、制表符等既无法显示又不能输入的特殊字符，需要利用 C++ 预定义的转义序列在程序中表示。下面是常用的预定义的转义序列表： 字符常量形式 含义 \\n |换行 \\r |回车 \\t |水平制表符 \\v |垂直制表符 \\a |响铃 \\f |换页 \\ |字符 '\\' \\\" |双引号 \\' |单引号 例如：input：\\n 则在输出字符串 'input：'后执行换行操作。 字符串常量 用双引号括起来的字符序列称为字符串常量。例如：\"shiyanlou\"、\"an apple\" 等。 若要在字符序列中包含双引号，例如表示语句：You choose \"time\" or \"happy\"，我们则需利用预定义的转义序列 \\\" 来表示句中的双引号。定义其字符串常量为：\"You choose \\\"time\\\" or \\\"happy\\\"\"。 布尔常量 布尔常量只有 TRUE 和 FALSE 两种。 常量声明 常量声明一般有两种方式，一是使用 #define 预处理、二是使用 const 关键字。 使用 #define 预处理 格式：#define name value #define PI 3.14159 #define NEWLINE '\\n' 使用 const 关键字 格式：const type name = value const double pi = 3.14; const char tab = '\\t'; 运算符和表达式 表达式是运算符及其运算数的序列，它指定一项计算。一般分为算数运算符和算数表达式、逻辑运算符和逻辑表达式、关系运算符和关系表达式、条件运算符和条件表达式。 算数运算符和算数表达式 算数运算符包括基本算数运算符和自增自减运算符；算数表达式一般由算数运算符、操作数和括号组成。下面是基本的算数运算符和算数表达式： 运算符名 语法 描述 表达式 一元加 |+a |正号 |+a = 6 一元减 |-a |负号 |-a = -6 加 |a + b |两数相加 |a + b = 6 减 |a - b |两数相减 |a - b = 6 乘 |a b |两数相乘 |a b = 8 除 |a / b |两数相除 |a / b = 8 模 |a % b |两数整除后取余 |a % b = 3 自增 |a++ 或 ++a |整数本身加一 |a++ = 6 或 ++a = 6 自减 |a-- 或 --a |整数本身减一 |a-- = 6 或 --a = 6 a++ 和 ++a 的区别：++a 称为前缀形式，在表达式计算之前完成自加运算；a++ 称为后缀形式，在表达式计算之后完成自加运算。同理，--a 和 a-- 亦如此，--a 在表达式计算之前完成自减运算；a-- 在表达式计算之后完成自减运算。例如新建 self.cpp 文档，输入： #include using namespace std; int main() { int i=1; cout其中 cout 逻辑运算符和逻辑表达式 逻辑表达式是通过逻辑运算符将操作数或等式进行逻辑判断的语句。在下面基本的逻辑运算符和逻辑表达式中，我们假设布尔变量 a 为 TRUE，b 为 FALSE： 运算符 运算符名 描述 表达式及结果 && |与 |当且仅当所有操作数都为 TRUE，表达式才为 TRUE |(a && b) 为 FALSE || |或 |任一操作数为 TRUE，表达式为 TRUE |(a || b) 为 TRUE ! |非 |取反。若操作数为 TRUE，表达式为 FALSE；若操作数为 FALSE，表达式为 TRUE |(!b) 为 TRUE 关系运算符和关系表达式 关系表达式最终产生的是一个布尔结果，它使用关系运算符判断操作数值之间的关系。若关系正确，则结果为 TRUE，若关系错误，则结果为 FALSE。在下面基本的关系运算符和关系表达式中，我们假设 a 为 3，b 为 4： 运算符 |运算符名 |描述 |表达式及结果 |-|-|-|-| == |等于 |判断两个操作数的值是否相等，如果相等则结果为 TRUE |(a == b) 为 FALSE != |不等于 |判断两个操作数的值是否相等，如果不等则结果为 TRUE |(a != b) 为 TRUE |大于 |判断左操作数的值是否大于右操作数的值，如果是那么结果为 TRUE |(a > b) 为 FALSE = |大于等于 |判断左操作数的值是否大于或等于右操作数的值，如果是那么结果为 TRUE |(a >= b) 为 FALSE 条件运算符和条件表达式 在 C++ 中条件运算符 ? 是三元运算符，其表达式为： 条件表达式 ? 表达式1 : 表达式2 如果条件表达式的值为 TRUE ，则返回 表达式1 的值，否则返回 表达式2 的值。 例如新建 condition.cpp 文件，输入： #include using namespace std; int main() { int a = 5; int b = 3; int c; c=(a>b)? a : b; //如果a大于b则返回a，否则返回b coutc 用于接收三元运算符的返回值，又因为 a>b 的布尔值为 TRUE，所以返回 a 的值。 拓展 sizeof 运算符 用于计算 对象 类型或 表达式结果 类型在内存中所占的字节数，其形式为：sizeof (对象类型名) 或 sizeof(表达式)。 在 C++ 中逗号也是一个运算符，称为 逗号运算符，其形式为：表达式1,表达式2。定义了从左到右的求解顺序，例如 a = 1,a + 1 其值为 2。 C++ 中最简单的赋值运算符是 '='。例如 a = (x=4) / (y=2) 表达的则是 x 赋值为 4，y 赋值为 2，a 赋值为 4 / 2，即 2。除了 =，C++ 中还有一些其他比较常用的赋值运算符： 运算符 运算符名 实例 等价于 += |加赋值 |i += 5 |i = i + 5 -= |减赋值 |i -= 5 |i = i - 5 = |乘赋值 |i = 5 |i = i * 5 /= |除赋值 |i /= 5 |i = i / 5 %= |求余赋值 |i %= 5 |i = i % 5 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/内存分配.html":{"url":"practice/chap1/内存分配.html","title":"内存分配","keywords":"","body":" 内存分配 不同的内存分配方式，有不同的内存调度机制。C++ 语言的三种内存分配方式分别是：静态存储区分配、栈内存分配和堆内存分配。 静态存储区分配 静态分配方式下的内存在程序编译的时候就已经分配好了且存在于程序的整个运行过程。例如 static 变量，其生命周期随程序的结束而结束，而非像一般变量随函数或作用域的结束而结束。 除了 static 变量，还有一种全局对象 static object，也可以存放在静态存储区。 栈内存分配 栈内存分配方式下的内存是存在于某作用域的一块空间。例如调用某个函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会被自动释放。 函数内局部变量的生命周期：起于变量声明，止于函数执行结束。 堆内存分配 堆内存分配，也称 动态内存分配，通常使用 new 和 delete 关键字进行管理。堆内存空间可由用户手动分配和释放，所以其生存周期由用户指定，较为灵活。但频繁的分配、释放大小不同的堆空间会产生内存碎片。 管理内存 C 语言中一般使用 malloc() 函数来分配内存空间，free() 函数来释放内存空间。但在 c++ 语言中我们使用 new 关键字来分配内存空间，delete 关键字来释放内存空间。后者在性能等方面优于前者。 在学习使用 new 和 delete 关键字之前我们先初步了解一下指针的概念及其一般形式。 指针是一个变量，其值是另一个变量的地址。指针变量声明的一般形式为： type *pointerVar-name 其中 type 为指针的数据类型，* 是定义指针的关键符，pointerVar-name 指定指针变量名。 例如：char *p，即定义了一个字符型指针变量 p。 指针的另一些基本内容会在后续的实验中详细介绍，本次实验对指针的内容仅做了解。现在我们正式学习 new 关键字和 delete 关键字。 new 关键字 new 关键字 用于堆内存的分配，可自动计算所要分配内存空间的大小，其基本使用形式为： 指针变量名 = new 类型 例如： int *p; //定义一个整型指针变量 p = new int; 其中 p = new int; 表示动态分配一个存放整型数据的内存空间，并将其首地址赋给整型指针变量 p，此时省略指针变量 p 前的 *。 delete 关键字 delete 关键字 用于堆内存的释放，其基本形式为： delete 指针变量 例如： int *p; //定义一个整型指针变量 p = new int; //省略指针操作过程 delete p; 其中 delete p; 表示释放指针变量 p 指向的内存空间，此时省略指针变量 p 前的 *。 注意：使用 new 获取的内存空间必须使用 delete 进行释放。 我们用实例来加深一下 new 和 delete 关键字的使用方式，新建 mans.cpp 文件，输入： #include using namespace std; int main() { int *p; //定义一个整型的指针变量 p。 p = new int; //动态分配一个存放整型数据的内存空间，并将其首地址赋给整型指针变量 p。 *p = 6; //为指针指向的内存块赋值为 6。 cout程序首先定义了整型指针变量 p，然后使用 new 关键字为其分配 int 型的内存空间，并让指针 p 指向分配的内存空间。随后为内存块赋值为 6，并且输出所赋的值。最后释放指针变量 p。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/基本控制结构.html":{"url":"practice/chap1/基本控制结构.html","title":"基本控制结构","keywords":"","body":" 基本控制结构 顺序结构 顺序结构是最简单的控制结构，也是 C++ 程序默认的执行流程。在此结构中，程序将按照书写的先后顺序自上而下依次执行。一般情况下，若程序中不包含选择结构、循环结构和跳转语句，则此程序为顺序结构。例如新建 sequence.cpp 文件，输入： #include using namespace std; int main() { int a,b; a=3; b=5; cout此程序中，语句按照从上至下的顺序依次执行：首先定义了 a 和 b 两个 int 型变量，然后给 a 赋值为 3，b 赋值为 5，最后输出 a+b 的结果。 选择结构 根据判定条件的结果，选择相应执行语句的控制结构称为选择结构。 使用条件运算符实现选择结构 利用条件运算符 ? 可以实现一个简单的选择结构，其基本形式为： 条件表达式 ? 表达式1 : 表达式2 此方式需根据条件表达式的判断结果，选择表达式 1 或者表达式 2。其具体意义是：若条件表达式的布尔值为 TRUE ，则返回 表达式1 的值，否则返回 表达式2 的值。例如新建 choose1.cpp 文件，输入： #include using namespace std; int main () { int x,y=7; //声明局部变量 x 和 y 并给 y 赋值为 7。 x=(y程序中 x=(y 使用 if 语句实现选择结构 if 是典型的用于实现选择结构的语句，例如 if(X==1) i++; 当满足条件 X==1 时，执行语句 i++。if 语句一般分为简单的 if...else 语句、嵌套的 if 语句和 if...else if 语句三类。 简单的 if...else 语句 的基本结构为： if(判定条件){ 判定条件为 TRUE 时的执行语句 } else{ 判定条件为 FALSE 时的执行语句 } 和使用条件运算符实现选择结构的方式类似。首先进入判定条件，若判定条件的布尔值为 TRUE 则执行 if 花括号内的语句，不执行 else 花括号内的语句；若判定条件的布尔值为 FALSE 则执行 else 花括号内的语句，不执行 if 花括号内的语句。例如新建 choose2.cpp 文件，输入： #include using namespace std; int main () { int x,y=7; //声明局部变量 x 和 y 并给 y 赋值为 7。 if(y因为 y = 7 即 y 嵌套的 if 语句 的基本结构为： if(判定条件 1){ if(判定条件 2){ 判定条件 1 和判定条件 2 均为 TRUE 时的执行语句 } else{ 判定条件 1 为 TRUE 且判定条件 2 为 FALSE 时的执行语句 } } else{ if(判定条件 3){ 判定条件 1 为 FALSE 且判定条件 3 为 TRUE 时的执行语句 } else{ 判定条件 1 和判定条件 3 均为 FALSE 时的执行语句 } } 嵌套的 if 语句只是把简单的 if...else 语句中的执行语句换成了 if...else 语句。当判定条件 1 的布尔值为 TRUE 时，进入判定条件 2；当判定条件 1 的布尔值为 FALSE 时，进入判定条件 3。例如新建 choose3.cpp 文件，输入： #include using namespace std; int main () { int x;//声明局部变量 x。 int y=7; //声明局部变量 y 且赋值为 7。 int z=3;//声明局部变量 z 且赋值为 3。 if(y2){ // 判定 z 是否大于 2。 x=2; //判定条件 z>2 为 TRUE 时。 } else{ x=3; //判定条件 z>2 为 FALSE 时。 } } cout因为 y = 7 即 y 2 的布尔值为 TRUE，所以 x 输出 2。 if...else if 语句 的基本结构为： if(判定条件1){ 满足判定条件 1 时执行的语句 } else if(判定条件2){ 满足判定条件 2 时执行的语句 } else{ 既不满足判定条件 1，也不满足判定条件 2 时的执行语句 } 注意：嵌套 if 语句的判定条件可针对不同对象进行判定，例如上例，先判定条件 y2。而 if...else if 语句只能针对同一对象进行判定，例如新建 choose4.cpp 文件，输入： #include using namespace std; int main () { int x,y=7; //声明局部变量 x 和 y 并给 y 赋值为 7。 if(y>8){ //判定 y 是否大于 8。 x=1; //当 y>8 时 x = 1。 } else if(y>5){ x=2; //当 y>5 时 x = 2。 } else{ x=3; //若既不满足 y>8，也不满足 y>5 时，x = 3。 } cout因为 y=7 不满足 y>8 而满足 y>5，所以 x 的值为 2。 使用 switch 语句实现选择结构 switch 语句比较特殊，其目的是检查常量表达式中的值，其基本结构为： switch(表达式){ case 值1: 代码块1 break; case 值2: 代码块2 break; ... default: 默认执行的代码块 } 当 switch 表达式的值和 case 语句选择的值相同时，从此 case 位置开始向下执行，直到遇到 break 语句或 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的默认代码。例如新建 choose5.cpp 文件，输入： #include using namespace std; int main () { cout>ch; //从键盘输入 ch 的值。 switch(ch){ case 'w': //键入 w 时。 cout键入 w 输出文本 \"上\" 并跳出 switch 语句；键入 s 输出文本 \"下\" 并跳出 switch 语句；键入 a 输出文本 \"左\" 并跳出 switch 语句；键入 d 输出文本 \"右\" 并跳出 switch 语句；键入非 a/s/d/w 中的字符，则输出提示信息 \"输入错误！\"。 循环结构 允许多次执行某一条语句或某个语句组的控制结构称为循环语句，在 C++ 中有 while 语句、do...while 语句、for 语句三种循环控制语句。 使用 while 语句实现循环结构 while 语句的执行过程是先判断，再执行。其基本结构为： while(条件){ 代码块 } while的语句流程 执行 while 语句时，首先判断 while 后面的条件是否成立( TRUE or FALSE )。若成立，则执行循环内的代码，直到条件不成立；若不成立，则执行 while 语句后的其他语句。例如新建 circle1.cpp 文件，输入： #include using namespace std; int main() { int sub = 0; //定义变量 sub 并赋值为 0。 int i = 1; //定义变量 i 并赋值为 1。 while(i在此程序中，sub 的初始值为 0，i 的初始值为 1。执行到 while 语句时，i 第一次循环：sub=0+1=1；执行 i++ 语句后的 i 值为 2，i 第二次循环：sub=0+1+2=3；执行 i++ 语句后的 i 值为 3，i 第三次循环：sub=0+1+2+3=6；执行 i++ 语句后的 i 值为 4，i 第四次循环：sub=0+1+2+3+4=10；执行 i++ 语句后的 i 值为 5，i 最后输出 sub 的值为 10。 使用 do...while 语句实现循环结构 do...while 语句的执行过程是先执行，再判断。其基本结构为： do{ 代码块 }while(条件); do...while的流程 执行 do...while 语句时，先执行一次循环体内的语句，然后再判断循环条件是否成立。如果条件成立，则继续执行，直到循环条件不成立；若条件不成立，执行 while 语句后的其他语句。例如新建 circle2.cpp 文件，输入： #include using namespace std; int main() { int sub = 0; //定义变量 sub 并赋值为 0。 int i = 1; //定义变量 i 并赋值为 1。 do{ sub += i; //执行 sub = sub + i。 i++; //i 累加 1 }while(i在此程序中，sub 的初始值为 0，i 的初始值为 1。执行到 do...while 语句时，直接进入循环体执行。 第一次循环：sub=0+1=1；执行 i++ 语句后的 i 值为 2。 i i i i 最后输出 sub 的值为 10。 使用 for 语句实现循环结构 for 语句允许指定循环的增量。其基本结构为： for(循环变量初始化;循环条件;循环增量) { 代码块 } for的流程 使用 for 语句实现循环结构的第一步就是初始化循环变量，然后判定循环条件，如果布尔值为 TRUE 则执行代码块中的语句，直到条件判定的布尔值为 FALSE 时终止循环；否则，循环结束。例如新建 circle3.cpp 文件，输入： #include using namespace std; int main() { int sub = 0; //定义变量 sub 并赋值为 0。 int i; //定义变量 i。 for(i=1;i执行 for 语句。设定 i 的初始值为 1，判定条件为 i i 执行第二次循环：sub=0+1+2=3；返回到循环增量处，执行 i++ 语句，此时 i=3，i 执行第三次循环：sub=0+1+2+3=6；返回到循环增量处，执行 i++ 语句，此时 i=4，i 执行第四次循环：sub=0+1+2+3+4=10；返回到循环增量处，执行 i++ 语句，此时 i=5，i 最后输出 sub 的值为 10。 拓展 与 if 嵌套语句类似，循环结构也可以进行 循环嵌套。循环结构为： for 嵌套 for(循环变量初始化1; 循环条件1; 循环增量1) { for(循环变量初始化2; 循环条件2; 循环增量2){ 代码块2 } 代码块1 } copy while 嵌套 while(条件1){ while(条件2){ 代码块2 } 代码块1 } do-while 循环 do{ 代码块1 do{ 代码块2 }while(条件2); }while(条件1); 注意：尽量避免设计层次过多的循环嵌套。 循环结构和选择结构可以互相嵌套，例如在 for 语句中嵌套 if 语句： for(循环变量初始化;循环条件;循环增量) { ... if(判定条件){ 判定条件为 TRUE 时的执行语句 } else{ 判定条件为 FALSE 时的执行语句 } } 判定条件永恒为 TRUE 的循环称为 死循环。例如： int i=1 while(i==1){ cout由于判定条件 i==1 的布尔值永恒为 TRUE，所以程序将无限循环输出字符串 \"1\"。值得注意的是，程序中应不含死循环，除非有特殊需求。 其他控制语句 continue 与 break 语句的区别 continue：结束本次循环，所在循环体并未结束。 例如新建 other.cpp 文件，输入： #include using namespace std; int main(){ int i; for (i=0;i循环至 i=3 时，满足条件 i==3 执行 continue 语句：直接跳出 本次循环 且不执行循环体内 continue 后的其他语句。随后再次执行循环增量 i++ 语句，判定循环条件，执行循环体。 break：结束整个循环体，所在循环体已结束。 将 other.cpp 文件中的 continue 修改为 break，如下： #include using namespace std; int main(){ int i; for (i=0;i循环至 i=3 时，满足条件 i==3 执行 break 语句，直接退出 for 循环，结果只输出数字 3 前面的数字 0 1 2。 goto 语句的使用 goto 语句允许把控制无条件转移到同一函数内的标记语句。但在任何的编程语言中，都不建议使用 goto 语句，因为它使得程序的控制流难以跟踪。 goto 语句的语法： goto label; ... label: statement; 当执行 goto label; 语句时，直接跳转并执行 label 标记的语句。例如新建 gtacc.cpp 文件，输入： #include using namespace std; int main(){ int i=3; if (i==3){ goto acc; } else{ cout因为 if 语句中判定条件 i==3 的布尔值为 TRUE ，所以执行语句 goto acc; 后直接跳转到语句 cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/函数的定义与使用.html":{"url":"practice/chap1/函数的定义与使用.html","title":"函数的定义与使用","keywords":"","body":" 函数的定义和使用 C++ 中的函数分为 C++ 标准库函数和自定义函数。使用标准库函数需要包含特定的头文件，比如使用 vector 功能时，需包含头文件 #include。而自定义函数是用户自定义命名和声明的一组语句，其基本结构为： type name(parameter list){ code } 其中 type 为函数的返回值类型；name 为函数的名称，也是调用函数所使用的标识符；parameter list 为传递给函数的参数列表；code 为函数的主体，存放函数需要执行的语句。例如我们定义一个 add 函数： int add(int a,int b){ return a + b; } add 函数的功能是利用 return 关键字返回 a 加 b 的和。 函数的声明与调用 函数的声明 如果希望在定义函数前调用函数，则需要在调用函数前声明函数，其结构为： type name(parameter list); 其中 type 为函数的返回值类型；name 为函数的名称；parameter list 为传递给函数的参数列表。例如上例的 add 函数，如果要在定义 add 函数前调用 add 函数，则需要在调用此函数前，对函数进行声明： int add(int a,int b); //函数声明。 int main(){ 调用 add 函数 //在未定义函数前调用函数。 } int add(int a,int b){ return a + b; } //定义函数 函数的调用 调用函数时，需暂停主调函数的执行，转入执行被调函数，当被调函数执行至 return 语句或函数末尾时，被调函数执行完毕，转回执行主调函数。可按如下格式调用函数： 函数名(实参列表) 注意：实参列表应与函数原型的参数个数及参数类型一致。 新建 addhs.cpp 文件，输入： #include using namespace std; int add(int a,int b); //函数声明。 int main() { int x,y; cout>x>>y; //通过输入的方式给 x y 赋值。 int c=add(x,y);//在未定义函数前调用函数。将函数的返回结果赋给变量 c。 cout执行语句 int c=add(a,b) 时，暂停执行 int main() 函数，转入执行 add 函数。把用户输入的 x、y 值传给 add 函数的变量 a、b，最后将语句 return a + b; 的结果赋给变量 c。 参数传递 在定义函数时，参数是没有实际值的，只起一个占位作用，所以称为形式参数，简称 \"形参\"；在调用函数时，参数必须有一个确定的值，是真正能对结果起作用的因素，所以称为实际参数，简称 \"实参\"。函数的 参数传递 指的是形参与实参结合的过程，其基本方式包括值传递和引用传递两种。 注意：形式参数的本质和局部变量相似，在进入函数的时候创建，退出函数的时候销毁。 值传递 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。例如新建 swapxy.cpp，输入： #include using namespace std; void swap(int a,int b){ //定义空函数 swap，用于交换 a 和 b 的值。 int t=a; //定义中间变量 t，并将 a 的值赋给变量 t。 a=b; //将 b 的值赋给 a。 b=t; //将 t 的值赋给 b，又因为 t=a，所以把 a 的值赋给 b。 } int main(){ int x=3; int y=4; cout主函数中第一句 cout 引用传递 使用引用传递，需要在定义函数时，在参数前加上符号 &，该方法把参数的引用复制给形式参数，修改形式参数会影响实际参数。例如修改 swapxy.cpp 文件为以下内容： #include using namespace std; void swap(int &a,int &b){ //定义空函数 swap，用于交换 a 和 b 的值。 int t=a; //定义中间变量 t，并将 a 的值赋给变量 t。 a=b; //将 b 的值赋给 a。 b=t; //将 t 的值赋给 b，又因为 t=a，所以把 a 的值赋给 b。 } int main(){ int x=3; int y=4; cout函数 swap 的形参属于引用类型，所以修改形参将影响实参。 拓展 默认参数 在 C++ 中，函数可定义具有默认值的参数，即 默认参数。当调用函数时，如果用户指定了参数值，则使用用户指定的值；如果参数值缺省，则使用默认参数。例如新建 defaultcs.cpp，输入： #include using namespace std; int add(int a,int b = 5){//变量 b 的值默认为 5。 return a + b; } int main() { int a,b; cout>a>>b; coutadd(a) 的返回结果为：输入的 a 值与默认 b 值之和。 add(a,b) 的返回结果为：输入的 a 值与输入的 b 值之和。 函数重载 函数重载 指定义一个参数类型或参数个数不同的重名函数。当程序执行时，编译器将调用参数类型与函数形参类型一致的函数。例如新建 renamehs.cpp，输入： #include using namespace std; int add(int a,int b){ //定义整型函数 add。 int c; c = a - b; return c; } double add(double a,double b){ //定义双精度型函数 add。 double c; c = a + b; return c; } int main() {//函数重载。 cout执行 add(3,4) 时，调用 int add(int a,int b) 函数。 执行 add(3.111,4.222) 时，调用 double add(double a,double b) 函数。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/类和对象.html":{"url":"practice/chap1/类和对象.html","title":"类和对象","keywords":"","body":" 类和对象 面向对象程序设计的基本特点包括：抽象、封装、继承、多态。 抽象 抽象是指对具体问题或对象进行概括，抽出其公共性质并加以描述的过程。一般情况抽象分为数据抽象和行为抽象，其中数据抽象是指一个对象区别于另一个对象的特征，行为抽象是指某类对象的共同特征。 封装 封装是指将抽象得到的数据和行为相结合，隐藏对象属性和实现细节且仅对外提供公共访问方式的过程。 继承 继承是指通过代码复用在保持原有类特性的基础上对子类进行具体说明的过程，通俗来说继承就是精简重复代码的手段。 多态 多态是指一段程序能够处理多种类型对象的能力，函数重载就是实现多态的一种手段。在 C++ 语言中多态可分为强制多态、重载多态、类型参数化多态和包含多态。 类 类是 C++ 语言支持面向对象思想的重要机制，是实现封装的基本单元。 类的定义 类一般由类名、数据成员、函数成员三部分组成，定义类的基本形式为： class 类的名称 { public： 外部接口 protected： 保护性成员 private： 私有成员 } 其中 public、protected、private 表示访问控制属性，用于控制类成员的访问权限。特别的，没有分配控制属性的默认为 private 私有成员。 类成员访问控制 使用 public 关键字声明的公有成员可在类外访问，即公有类型成员定义了外部接口。例如新建 pubtest.cpp 文件，输入： #include using namespace std; class area //定义 area 类。 { public: //定义公有成员，外部可以访问。 double width; double length; }; int main() { area area1; //定义对象 area1。 double AREA; //定义双精度型变量 AREA。 area1.width=3; //外部访问公有成员，设置宽为 3。 area1.length=3.1; //外部访问公有成员，设置长为 3.1。 AREA=area1.width*area1.length; //计算面积。 cout 此程序可以分为相对独立的两个部分，一是对 area 类的定义，二是主函数 main()。area 类定义了两个双精度型的公有成员，主函数访问类的公有成员实现数字相乘。 使用 protected 关键字声明的受保护成员可在子类中访问。例如新建 protest.cpp 文件，输入： #include using namespace std; class area //定义 area 类。 { protected://定义受保护的成员。 double width; }; class squarearea:area //定义 squarearea 子类。 { public: //定义公有成员。 void setsquarewidth(double wid); //定义成员函数。 double getsquarewidth(void); }; //定义子类的成员函数。 void squarearea::setsquarewidth(double wid) { width=wid; //通过 squarearea 子类访问 area 类中受保护的成员 width。 } double squarearea::getsquarewidth(void) { return width; } //程序的主函数 。 int main() { squarearea square; //定义对象。 square.setsquarewidth(3.1); //设置宽度为 3.1。 cout 此程序可以分为相对独立的三个部分，一是对 area 类的定义，二是对 squarearea 子类及子类函数的定义，三是主函数 main()。对于 area 类中受保护的成员 width 可以通过子类进行访问。 使用 private 关键字声明的私有成员只能被本类的成员函数访问。例如新建 pritest.cpp 文件，输入： #include using namespace std; class area { public: //定义公有成员 double length; void setwidth(double wid); double getwidth(void); private://定义私有成员 double width; }; //定义公有成员函数 void area::setwidth(double wid) { width=wid; } double area::getwidth(void) { return width; } //主函数 int main() { area len1; //定义对象 area wid1; len1.length=3.1; //访问 area 类公有成员。 cout此程序可以分为相对独立的两个部分，一是 area 类及其公有成员函数的定义，二是主函数 main()。私有成员 width 只能先被类中成员函数访问，再通过相关的公共成员函数实现外部访问。若在类外部使用 area.width=3.2; 方式访问 area 类的私有成员 width，则会报错。 对象 在 C++ 语言中，对象是某类事物的实例。其声明形式为： 类名 对象名； 例如声明 area 类的对象 square： area square； 访问对象的成员 定义了类及其对象后，则可访问对象的成员。访问 数据成员 基本形式为： 对象名.成员名 例如访问 area 类的对象 square 的数据成员 width： square.width=3.2; 访问函数成员的基本形式为： 对象名.函数名(参数表) 例如访问 area 类的对象 square 的函数成员 setwidth(double wid)： square.setwidth(3.2); 类的成员函数 成员函数描述了类的行为。成员函数在类中只用说明其函数的返回类型、名字和参数表，而函数的具体实现在类外说明，其基本形式为： class 类名 { 函数的返回类型 函数名(参数列表) } 返回值类型 类名::函数名(参数列表) //特别的，在类外说明函数的具体实现时，需要使用类名限制成员函数，其形式为：类名::函数名(参数列表)。 { 函数体 } 例如在 area 类中有成员函数 void setwidth(double wid);： class area { ... void setwidth(double wid); ... } //在类外说明函数的具体实现 void area::setwidth(double wid) { 函数体 } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap1/数组-字符串和指针.html":{"url":"practice/chap1/数组-字符串和指针.html","title":"数组和字符串和指针","keywords":"","body":" 数组、字符串和指针 数组 数组用于存储一系列类型相同的元素。例如定义五个类型相同的变量，可以不用定义五个变量，只需要将五个值存到一个数组中即可。 数组的声明格式： type name[elements] //一维数组的声明格式。 其中 type 为数组类型，name 为数组名，elements 表示数组长度。数组长度就是数组最多可以存放的元素个数。 声明不同类型的数组： int a[5]; //包含五个元素的 int 数组。 float a[5]; //包含五个元素的 float 数组。 char a[5]; //包含五个元素的 char 数组。 初始化数组 默认情况下，数组中所有元素的值在声明数组时是未确定的。 若要在声明数组时，将数组中的元素初始化为特定的值，可以使用 {} 实现，例如初始化数组 int a[5]： int a[5] = {1,2,3,4,5} 初始化数组时，若填充元素不完整，则剩下元素的值默认为 0。例如： int a[5] = {1,2,3} 访问数组 访问数组的表达式为： name[index] 其中 name 为数组名称，index 为元素编号。name[index] 称为数组下标。 例如定义且初始化一个数组：int a[5] = {1,2,3,4,5}。可以得到 a[0]=1,a[1]=2,a[2]=3,a[3]=4,a[4]=5。 则 a[2] 可以访问数组中的元素 3。 新建 arr1.cpp 文件，输入： #include using namespace std; int main () { int a[5] = {1,2,3,4,5}; //初始化数组。 cout多维数组 C++ 中支持多维数组，多维数组是指二维及以上的数组，其表达式为： type name[index1][index2][index3]...[indexn] 其中 index 的数量决定了数组的维度，例如 type name[index1][index2] 表示的则是一个二维数组。 二维数组 可以将二维数组看成一张二维表。定义一个二维数组 a[3][5]： 二维数组 a[3][5] 可以表示成一张三行五列的二维表，其初始化顺序为：从左到右，从上到下。 新建 arr2.cpp 文件，输入： #include using namespace std; int main () { int a[3][5] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}; //初始化数组。 coutC-style字符串 C++ 支持起源于 C 语言的 C-style 字符串。 例如定义一个可以容纳 10 个 char 型字符的数组： char ch[10]; 此数组具有存储 10 个字符的能力，但是这个容量不需要完全使用，数组也可以容纳更短的长度。 按照惯例，字符表示的字符串由特殊字符 null 结尾，其字面值可以写为 \\0。 例如在数组 char ch[10] 中存入一个 Hello 字符串：char ch[10] = \"Hello\";。 注意：null 字符不用手动添加，C++ 在编译的时候会自动添加。 cstring 在 C++ 中有大量用于操作 C-style 字符串的函数，它们集成在头文件 中。其常见的函数： 函数 作用 strcpy(s1,s2) |复制字符串 s2 到 s1 strcat(s1,s2) |将字符串 s2 连接到 s1 末尾 strlen(s) |计算字符串 s 长度 strcmp(s1,s2) |比较字符串 s1 和 s2 的长度，相同为 0；s1 s2 为 1 strchr(s1,ch) |返回一个指针，指向 s1 中字符 ch 第一次出现的位置 strstr(s1,s2) |返回一个指针，指向 s1 中字符串 s2 第一次出现的位置 新建 str1.cpp 文件，输入： #include #include using namespace std; int main() { char str1[18] = \"Hello \"; char str2[11] = \"Shiyanlou!\"; strcat(str1,str2);//连接字符串。 cout字符串 初始化字符串 初始化字符串 str1： string str1(\"Hello\"); 上述将 str1 初始化为 Hello，其等效于： string str1 = \"Hello\"; 注意：string 不需要像数组一样指定元素个数，它会自动分配内存。 新建 str2.cpp 文件，输入： #include using namespace std; int main() { string str1 = \"Hello \"; string str2 = \"Shiyanlou!\"; str1.append(str2);//连接字符串。 cout其中 str1.append(str2); 将字符串 str2 连接到 str1 末尾，输出 Hello Shiyanlou! 在 C++ 中，string 还支持常规操作符，如： ==， #include using namespace std; int main() { string str1 = \"Hello \"; string str2 = \"Shiyanlou!\"; cout对于字符串来说，常规操作符 + 的功能为 连接。 指针 指针是 C++ 从 C 中继承的重要数据类型，它提供了一种较为直接的地址操作手段，使用指针可灵活实现动态内存的分配。 指针变量的声明 指针是一种数据类型，具有指针类型的变量称为 指针变量，它用于存放内存地址。在使用指针之前，需对指针进行声明，其一般形式为： type *pointer_name; 其中 type 表示所指对象的数据类型，即说明所指内存单元存放的数据类型；* 表示声明一个指针类型的变量；pointer_name 表示指针名。 声明三个数据类型不同的指针变量： int *p; //声明 int 型的指针变量 p。 float *p1; //声明 float 型的指针变量 p1。 char *p2; //声明 char 型的指针变量 p2。 值得注意的是，指针实际存放的是内存地址，不同类型的指针变量用于指向数据类型不同的变量或常量。 C++ 中提供了两个与地址相关的运算符： 和 & 。其中 称为 指针运算符，用于获取指针所指变量的值，例如 *p 表示指针 p 所指变量的值；& 称为 取地址运算符，用于获取一个对象的地址，例如有变量 i，则 &i 表示 i 的存储地址。 指针的赋值与使用 定义指针后我们仅得到了一个用于存储地址的指针变量，若要确定指针变量存放的内存地址，可以通过给指针赋值实现。其基本形式为： 在定义指针时为指针赋值：type *pointer_name=初始地址; 在定义指针后为指针赋值：type *pointer_name; pointer_name=初始地址; 其中 初始地址 为某个对象的内存地址，一般使用 &对象名 获取。 例如将指针 p 指向变量 po1 的地址，其中变量 po1 的值为 6： int po1=6; //定义 int 型变量 po1，赋值为 6。 int *p=&po1; //指针变量 p 指向变量 po1 的地址。 其等价于： int po1=6; //定义 int 型变量 po1，赋值为 6。 int *p; //定义指针变量 p p=&po1; //指针变量 p 指向变量 po1 的地址。 我们通过一个例子加深一下指针的定义和使用，新建 pointer1.cpp，输入： #include using namespace std; int main () { int po1=6; //定义 int 型变量 po1，赋值为 6。 int *p=&po1; //指针变量 p 指向变量 po1 的地址。 cout 其中 p 运用指针运算符 获取指针 p 所指变量的值；&p 运用取地址运算符 & 获取指针 p 的地址。 引用 引用是指对已存在的变量别名，我们可以使用引用名来指向对象。 引用与指针主要有三个区别： 可以通过 指针名=0 描述一个空指针，但不存在空引用。 指针可在任何时间进行初始化操作，而引用只能在定义时进行初始化操作。 指针变量指向内存的一个存储单元；而引用只不过是原变量的一个别名而已。 声明引用变量的基本格式为： type &引用名=被指对象名； & 在这里是标识作用，而非取地址运算符。 例如定义引用 x，它是整型变量 i 的引用： int &x=i; 我们通过 初始化时间 来区别一下指针和引用，新建 pointer2.cpp 文件，输入： #include using namespace std; int main () { int i=3; int j=4; int &x=i; //定义引用 x，它是整型变量 i 的引用。 int *s; //定义指针 s。 s=&j; //指针 s 指向整型变量 j 的地址。 cout 其中 int &x=i; 表示在 定义引用时 进行的初始化操作。s=&j; 表示在 定义指针后 进行的初始化操作。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:30:55 "},"practice/chap3/3_0summary.html":{"url":"practice/chap3/3_0summary.html","title":"STL","keywords":"","body":" C++ STL “Standard Template Library”,STL 由算法，容器，迭代器，适配器，仿函数（函数对象），空间适配器六大部件组成 。 知识点： 模板编程 泛型编程 STL 常用组件 lambda 表达式 异常处理 内存处理 部分数据结构 部分算法 提示：本课程所有代码至少需要开启 -std=c++11 选项来支持 C++11 相关特性，在介绍 C++14 特性时的相关代码需要开启 -std=c++14 的编译选项，例如： g++ main.cpp -std=c++11 g++ main.cpp -std=c++14 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_0summary.html":{"url":"practice/chap4/4_0summary.html","title":"C++11&14","keywords":"","body":" C++11&14 C++ 算是一个用户群体比较大的语言了，从 C++ 98 到 C++ 11 经历了长达十年多之久的积累，C++ 14 则是作为对 C++ 11 的重要补充和优化，所有这些新标准中扩充的特性，给 C++ 这门语言注入了新的活力。 那些还在坚持使用 传统 C++ （本教程把 C++ 98 及其之前的 C++ 特性均称之为传统 C++）而未接触过 C++ 11 / 14 的 C++ 程序员在见到诸如 Lambda 表达式这类全新特性时，甚至会流露出『学的不是同一门语言』的惊叹之情。 C++ 1x （本教程中指 C++ 11 / 14, 甚至 C++ 17） 为传统 C++ 注入的大量特性使得整个 C++ 变得更加像一门现代化的语言。C++ 1x 不仅仅增强了 C++ 语言自身的可用性，auto 关键字语义的修改使得我们更加有信心来操控极度复杂的模板类型。同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python/Swift/... ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等。 C++ 1x 为自身的标准库增加了非常多的工具和方法，诸如在语言层面上提供了 std::thread 支持了并发编程，在不同平台上不再依赖于系统底层的 API，实现了语言层面的跨平台支持；std::regex提供了完整的正则表达式支持等等。 C++ 98 已经被实践证明了是一种非常成功的『范型』，而 C++ 1x 的出现，则进一步推动这种范型，让 C++ 成为系统程序设计和库开发更好的语言。 提示 提示：本课程所有代码至少需要开启 -std=c++11 选项来支持 C++ 11 相关特性，在介绍 C++ 14 特性时的相关代码需要开启 -std=c++14 的编译选项，例如： $ g++ main.cpp -std=c++11 $ g++ main.cpp -std=c++14 推荐所有代码均使用 -std=c++14 选项进行编译。 Part 1 C++11/14 简介 概述 教程目录 被弃用的特性 与 C 的兼容性 Part 2 语言可用性的强化 nullptr 与 constexpr 类型推导 auto decltype 尾返回类型、auto 与 decltype 配合 区间迭代 基于范围的 for 循环 初始化列表 std::initializer_list 统一初始化语法 模板增强 外部模板 尖括号 > 类型别名模板 变长参数模板 面向对象增强 委托构造 继承构造 显式虚函数重载 override final 显式禁用默认函数 强类型枚举 Part 3 语言运行期的强化 lambda 表达式 lambda 表达式基础 值捕获 引用捕获 隐式捕获 表达式捕获 泛型 lambda 函数对象包装器 std::function std::bind/std::placeholder 右值引用 左值、右值的纯右值、将亡值、右值 右值引用和左值引用 移动语义 完美转发 Part4 对标准库的扩充: 新增容器 std::array std::forward_list std::unordered_set std::unordered_map std::tuple 基本操作 运行期索引 合并与迭代 Part 5 对标准库的扩充: 智能指针和引用计数 引用计数 std::shared_ptr std::make_shared std::unique_ptr std::weak_ptr Part 6 对标准库的扩充: 正则表达式库 正则表达式简介 普通字符 特殊字符 限定符 std::regex 及其相关 std::regex std::regex_match std::match_results Part 7 对标准库的扩充: 语言级线程支持 std::thread std::mutex std::unique_lock std::future std::packaged_task std::condition_variable Part 8 其他杂项 新类型 long long int noexcept 的修饰和操作 字面量 原始字符串字面量 自定义字面量 Part 9 扩展主题: C++17 简介 主要入选特性 非类型模板参数的 auto std::variant<> 结构化绑定(Structured bindings) 变量声明的强化 未入选特性 Concepts 从 C++ 11 开始，被弃用的主要特性： 注意：弃用不等于废弃，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，这些特性其实会『永久』保留。 弃用的特性（1）：如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。** 弃用的特性（2）：不再允许字符串字面值常量赋值给一个 char 。如果需要用字符串字面值常量赋值和初始化一个 char ，应该使用 const char * 或者 auto。 char *str = \"hello world!\"; // 将出现弃用警告 弃用的特性（3）：C++98 异常说明、 unexpected_handler、set_unexpected() 等相关特性被弃用，应该使用 noexcept。** 弃用的特性（4）：auto_ptr 被弃用，应使用 unique_ptr。 弃用的特性（5）：register 关键字被弃用。 弃用的特性（6）：bool 类型的 ++ 操作被弃用。 弃用的特性（7）：C 语言风格的类型转换被弃用，应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换。 还有一些其他诸如参数绑定（C++11 提供了 std::bind 和 std::function）、export 等特性也均被弃用。前面提到的这些特性如果你从未使用或者听说过，也请不要尝试去了解他们，应该向新标准靠拢，直接学习新特性。毕竟，技术是向前发展的。 与 C 的兼容性 出于一些不可抗力、历史原因，我们不得不在 C++ 中使用一些 C 语言代码（甚至古老的 C 语言代码），例如 Linux 系统调用。在 C++11 出现之前，大部分人当谈及 『C 与 C++ 的区别是什么』时，普遍除了回答面向对象的类特性、泛型编程的模板特性外，就没有其他的看法了，甚至直接回答『差不多』，也是大有人在。下面的韦恩图大致上回答了 C 和 C++ 相关的兼容情况： 从现在开始，你的脑子里应该树立 『C++ 不是 C 的一个超集』 这个观念（而且从一开始就不是）。 在编写 C++ 时，也应该尽可能的避免使用诸如 void* 之类的程序风格。而在不得不使用 C 时，应该注意使用 extern \"C\" 这种特性，将 C 语言的代码与 C++ 代码进行分离编译，再统一链接这种做法，例如： 头文件 foo.h // foo.h #ifdef __cplusplus extern \"C\" { #endif int add(int x, int y); #ifdef __cplusplus } #endif 源文件 foo.c // foo.c int add(int x, int y) { return x+y; } 源文件 main.cpp // main.cpp #include \"foo.h\" int main() { add(1, 2); return 0; } 应先使用 gcc 编译 C 语言的代码： gcc -c foo.c 编译出 foo.o 文件，再使用 g++ 将 C++代码和 .o 文件链接起来（或者都编译为 .o 再统一链接）： g++ main.cpp foo.o -o main OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_1.html":{"url":"practice/chap4/4_1.html","title":"语言可用性的强化","keywords":"","body":" 语言可用性的强化 nullptr 与 constexpr （1）nullptr nullptr 出现的目的是为了替代 NULL。在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。 C++ 不允许直接将 void 隐式转换到其他类型，但如果 NULL 被定义为 ((void)0)，那么当编译 char *ch = NULL; 时，NULL 只好被定义为 0。而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱，考虑： void foo(char *); void foo(int); 对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。 为了解决这个问题，C++ 11 引入了 nullptr 关键字，专门用来区分空指针、0。nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。 你可以尝试使用 g++ 编译下面的代码： #include void foo(char *); void foo(int); int main() { if(NULL == (void *)0) std::cout 将输出： NULL == 0 call foo(int) call foo(char*) 当我们加上注释中的 foo(NULL) 将编译无法通过： foo.cpp: In function ‘int main()’: foo.cpp:10:13: error: call of overloaded ‘foo(NULL)’ is ambiguous foo(NULL); // 编译无法通过 ^ foo.cpp:2:6: note: candidate: void foo(char*) void foo(char *); ^ foo.cpp:3:6: note: candidate: void foo(int) void foo(int); 所以，当需要使用 NULL 时候，请养成直接使用 nullptr 的习惯。 （2）constexpr C++ 本身已经具备了常数表达式的概念，比如 1+2、3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。 一个非常显著的例子就是在数组的定义阶段： #define LEN 10 int len_foo() { return 5; } int main() { char arr_1[10]; char arr_2[LEN]; int len = 5; char arr_3[len+5]; // 非法 const int len_2 = 10; char arr_4[len_2+5]; // 合法 char arr_5[len_foo()+5]; // 非法 return 0; } 在 C++11 之前，可以在常量表达式中使用的变量必须被声明为 const，在上面代码中，len_2 被定义成了常量，因此 len_2+5 是一个常量表达式，所以能够合法的分配一个数组； 而对于 arr_5 来说，C++98 之前的编译器无法得知 len_foo() 在运行期实际上是返回一个常数，这也就导致了非法的产生。 C++ 11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译器会成为常数，这个关键字明确的告诉编译器应该去验证 len_foo 在编译器就应该是一个常数。 此外，constexpr 的函数可以使用递归： constexpr int fibonacci(const int n) { return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2); } 从 C++ 14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句，但 C++ 11 中是不可以的。例如下面的代码在 C++ 11 的标准下是不能够通过编译的： constexpr int fibonacci(const int n) { if(n == 1) return 1; if(n == 2) return 1; return fibonacci(n-1)+fibonacci(n-2); } 类型推导 在传统 C 和 C++中，参数的类型都必须明确定义，这其实对我们快速进行编码没有任何帮助，尤其是当我们面对一大堆复杂的模板类型时，必须明确的指出变量的类型才能进行后续的编码，这不仅拖慢我们的开发效率，也让代码变得又臭又长。 C++ 11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。 （1）auto auto 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 register 并存。在传统 C++ 中，如果一个变量没有声明为 register 变量，将自动被视为一个 auto 变量。而随着 register 被弃用，对 auto 的语义变更也就非常自然了。 使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。在以前我们需要这样来书写一个迭代器： for(vector::const_iterator itr = vec.cbegin(); itr != vec.cend(); ++itr) 而有了 auto 之后可以： // 由于 cbegin() 将返回 vector::const_iterator // 所以 itr 也应该是 vector::const_iterator 类型 for(auto itr = vec.cbegin(); itr != vec.cend(); ++itr); 一些其他的常见用法： auto i = 5; // i 被推导为 int auto arr = new auto(10) // arr 被推导为 int * 注意：auto 不能用于函数传参，因此下面的做法是无法通过编译的（考虑重载的问题，我们应该使用模板）： int add(auto x, auto y); 此外，auto 还不能用于推导数组类型： #include int main() { auto i = 5; int arr[10] = {0}; auto auto_arr = arr; auto auto_arr2[10] = arr; return 0; } （2）decltype decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。 它的用法和 sizeof 很相似： decltype(表达式) 在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。 有时候，我们可能需要计算某个表达式的类型，例如： auto x = 1; auto y = 2; decltype(x+y) z; // z 是一个 int 型的 （3）尾返回类型、auto 与 decltype 配合 你可能会思考，auto 能不能用于推导函数的返回类型。考虑这样一个例子加法函数的例子，在传统 C++ 中我们必须这么写： template R add(T x, U y) { return x+y } typename 和 class 在模板中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的 这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 add() 这个函数会做什么样的操作，获得一个什么样的返回类型。 在 C++11 中这个问题得到解决。虽然你可能马上回反应出来使用 decltype 推导 x+y 的类型，写出这样的代码： decltype(x+y) add(T x, U y); 但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定义。为了解决这个问题，C++ 11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键字将返回类型后置： template auto add(T x, U y) -> decltype(x+y) { return x+y; } 令人欣慰的是从 C++ 14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法： template auto add(T x, U y) { return x+y; } 区间迭代 区间迭代是指基于范围的 for 循环。 终于，C++ 11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句： int array[] = {1,2,3,4,5}; for(auto &x : array) { std::cout 最常用的 std::vector 遍历将从原来的样子： std::vector arr(5, 100); for(std::vector::iterator i = arr.begin(); i != arr.end(); ++i) { std::cout 变得非常的简单： // & 启用了引用, 如果没有则对 arr 中的元素只能读取不能修改 for(auto &i : arr) { std::cout 初始化列表 初始化是一个非常重要的语言特性，最常见的就是对对象进行初始化。在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、POD （plain old data，没有构造、析构和虚函数的类或结构体）类型都可以使用 {} 进行初始化，也就是我们所说的初始化列表。而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 () 进行。这些不同方法都针对各自对象，不能通用。 int arr[3] = {1,2,3}; // 列表初始化 class Foo { private: int value; public: Foo(int) {} }; Foo foo(1); // 普通构造初始化 为了解决这个问题，C++11 首先把初始化列表的概念绑定到了类型上，并将其称之为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如： #include class Magic { public: Magic(std::initializer_list list) {} }; Magic magic = {1,2,3,4,5}; std::vector v = {1, 2, 3, 4}; 这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。 初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如： void func(std::initializer_list list) { return; } func({1,2,3}); 其次，C++11 提供了统一的语法来初始化任意的对象，例如： struct A { int a; float b; }; struct B { B(int _a, float _b): a(_a), b(_b) {} private: int a; float b; }; A a {1, 1.1}; // 统一的初始化语法 B b {2, 2.2}; 模板增强 （1）外部模板 传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。 C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化： template class std::vector; // 强行实例化 extern template class std::vector; // 不在该编译文件中实例化模板 （2）尖括号 \">\" 在传统 C++ 的编译器中，>>一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码： std::vector> wow; 这在传统 C++ 编译器下是不能够被编译的，而 C++ 11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。 （3）类型别名模板 在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：模板是用来产生类型的。在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如： template class SuckType { public: T a; U b; SuckType():a(value),b(value){} }; template typedef SuckType, U, 1> NewType; // 不合法 C++ 11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效： 通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。 typedef int (*process)(void *); // 定义了一个返回类型为 int，参数为 void* 的函数指针类型，名字叫做 process using process = int(*)(void *); // 同上, 更加直观 template using NewType = SuckType; // 合法 （4）默认模板参数 我们可能定义了一个加法函数： template auto add(T x, U y) -> decltype(x+y) { return x+y } 但在使用时发现，要使用 add，就必须每次都指定其模板参数的类型。 在 C++11 中提供了一种便利，可以指定模板的默认参数： template auto add(T x, U y) -> decltype(x+y) { return x+y; } （5）变长参数模板 模板一直是 C++ 所独有的黑魔法（一起念：Dark Magic）之一。在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。 template class Magic; 模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义： class Magic, std::map>> darkMagic; 既然是任意形式，所以个数为 0 的模板参数也是可以的：class Magic<> nothing;。 如果不希望产生的模板参数个数为 0，可以手动的定义至少一个模板参数： template class Magic; 变长参数模板也能被直接调整到到模板函数上。传统 C 中的 printf 函数，虽然也能达成不定个数的形参的调用，但其并非类别安全。而 C++11 除了能定义类别安全的变长参数函数外，还可以使类似 printf 的函数能自然地处理非自带类别的对象。除了在模板参数中能使用 ... 表示不定长模板参数外，函数参数也使用同样的表示法代表不定长参数，这也就为我们简单编写变长参数函数提供了便捷的手段，例如： template void printf(const std::string &str, Args... args); 那么我们定义了变长的模板参数，如何对参数进行解包呢？ 首先，我们可以使用 sizeof... 来计算参数的个数，： template void magic(Args... args) { std::cout 我们可以传递任意个参数给 magic 函数： magic(); // 输出0 magic(1); // 输出1 magic(1, \"\"); // 输出2 其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法： 递归模板函数 递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归的向函数传递模板参数，进而达到递归遍历所有模板参数的目的： #include template void printf(T value) { std::cout void printf(T value, Args... args) { std::cout 初始化列表展开 这个方法需要之后介绍的知识，读者可以简单阅读以下，将这个代码段保存，在后面的内容了解过了之后再回过头来阅读此处方法会大有收获。 递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。 这里介绍一种使用初始化列表展开的黑魔法： // 编译这个代码需要开启 -std=c++14 // 因为版本原因，实验环境中的 g++ 尚不支持此特性，此处可以使用 clang++ 替代 g++ template auto print(T value, Args... args) { std::cout {([&] { std::cout 在这个代码中，额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性（下一节中将提到），而 std::initializer_list 也是 C++11 新引入的容器（以后会介绍到）。 通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。唯一不美观的地方在于如果不使用 return 编译器会给出未使用的变量作为警告。 事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 std::bind 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。 面向对象增强 （1）委托构造 C++ 11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的： class Base { public: int value1; int value2; Base() { value1 = 1; } Base(int value) : Base() { // 委托 Base() 构造函数 value2 = 2; } }; int main() { Base b(2); std::cout （2）继承构造 在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++ 11 利用关键字 using 引入了继承构造函数的概念： class Base { public: int value1; int value2; Base() { value1 = 1; } Base(int value) : Base() { // 委托 Base() 构造函数 value2 = 2; } }; class Subclass : public Base { public: using Base::Base; // 继承构造 }; int main() { Subclass s(3); std::cout （3）显式虚函数重载 在传统 C++ 中，经常容易发生意外重载虚函数的事情。例如： struct Base { virtual void foo(); }; struct SubClass: Base { void foo(); }; SubClass::foo 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。 C++ 11 引入了 override 和 final 这两个关键字来防止上述情形的发生。 （4）override 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译： struct Base { virtual void foo(int); }; struct SubClass: Base { virtual void foo(int) override; // 合法 virtual void foo(float) override; // 非法, 父类没有此虚函数 }; （5）final final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。 struct Base { virtual void foo() final; }; struct SubClass1 final: Base { }; // 合法 struct SubClass2 : SubClass1 { }; // 非法, SubClass 已 final struct SubClass3: Base { void foo(); // 非法, foo 已 final }; （6）显式禁用默认函数 在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、复制构造、赋值算符以及析构函数。另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。当程序员有需要时，可以重载这部分函数。 这就引发了一些需求：无法精确控制默认函数的生成行为。例如禁止类的拷贝时，必须将赋值构造函数与赋值算符声明为 private。尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。 并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。若用户定义了任何构造函数，编译器将不再生成默认构造函数，但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。 C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数。例如： class Magic { public: Magic() = default; // 显式声明使用编译器生成的构造 Magic& operator=(const Magic&) = delete; // 显式声明拒绝编译器生成构造 Magic(int magic_number); } 强类型枚举 在传统 C++ 中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），甚至枚举类型的枚举值名字不能相同，这不是我们希望看到的结果。 C++ 11 引入了枚举类（enumaration class），并使用 enum class 的语法进行声明： enum class new_enum : unsigned int { value1, value2, value3 = 100, value4 = 100 }; copy 这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较，更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较： if (new_enum::value3 == new_enum::value4) { // 会输出 std::cout 而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 #include template std::ostream& operator::value, std::ostream>::type& stream, const T& e) { return stream ::type>(e); } 这时，下面的代码将能够被编译： std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_2.html":{"url":"practice/chap4/4_2.html","title":"语言运行期的强化","keywords":"","body":" 语言运行期的强化 Lambda 表达式 Lambda 表达式是 C++ 11 中最重要的新特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多，所以匿名函数几乎是现代编程语言的标配。 （1）Lambda 表达式基础 Lambda 表达式的基本语法如下： [捕获列表](参数列表) mutable(可选) 异常属性 -> 返回类型 { // 函数体 } [ caputrue ] ( params ) opt -> ret { body; }; 上面的语法规则除了 [捕获列表] 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去，返回值使用了一个 -> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。 所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种： 值捕获 与参数传值类似，值捕获的前期是变量可以拷贝，不同之处则在于，被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝： void learn_lambda_func_1() { int value_1 = 1; auto copy_value_1 = [value_1] { return value_1; }; value_1 = 100; auto stored_value_1 = copy_value_1(); // 这时, stored_value_1 == 1, 而 value_1 == 100. // 因为 copy_value_1 在创建时就保存了一份 value_1 的拷贝 cout 引用捕获 与引用传参类似，引用捕获保存的是引用，值会发生变化。 void learn_lambda_func_2() { int value_2 = 1; auto copy_value_2 = [&value_2] { return value_2; }; value_2 = 100; auto stored_value_2 = copy_value_2(); // 这时, stored_value_2 == 100, value_1 == 100. // 因为 copy_value_2 保存的是引用 cout 隐式捕获 手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 & 或 = 向编译器声明采用 引用捕获或者值捕获. 总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是： [] 空捕获列表 [name1, name2, ...] 捕获一系列变量 [&] 引用捕获, 让编译器自行推导捕获列表 [=] 值捕获, 让编译器执行推导应用列表 表达式捕获（C++ 14） 这部分内容需要了解后面马上要提到的右值引用以及智能指针 上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。 C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的： #include #include void learn_lambda_func_3(){ auto important = std::make_unique(1); auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -> int { return x+y+v1+(*v2); }; std::cout 在上面的代码中，important 是一个独占指针，是不能够被捕获到的，这时候我们需要将其转移为右值，在表达式中初始化。 （2）泛型 Lambda (C++ 14) 上一节中我们提到了 auto 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。这就为我们造成了一定程度上的麻烦：参数表不能够泛化，必须明确参数表类型。 幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型： void learn_lambda_func_4(){ auto generic = [](auto x, auto y) { return x+y; }; std::cout 函数对象包装器 这部分内容虽然属于标准库的一部分，但是从本质上来看，它却增强了 C++ 语言运行时的能力，这部分内容也相当重要，所以放到这里来进行介绍。 （1）std::function Lambda 表达式的本质是一个函数对象，当 Lambda 表达式的捕获列表为空时，Lambda 表达式还能够作为一个函数指针进行传递，例如： #include using foo = void(int); // 定义函数指针, using 的使用见上一节中的别名语法 void functional(foo f) { f(1); } int main() { auto f = [](int value) { std::cout 上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数指针传递进行调用，而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型，统一称之为可调用类型。而这种类型，便是通过 std::function 引入的。 C++11 std::function 是一种通用、多态的函数封装，它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，它也是对 C++中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的），换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。例如： #include #include int foo(int para) { return para; } int main() { // std::function 包装了一个返回值为 int, 参数为 int 的函数 std::function func = foo; int important = 10; std::function func2 = [&](int value) -> int { return 1+value+important; }; std::cout （2）std::bind/std::placeholder 而 std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。例如： int foo(int a, int b, int c) { ; } int main() { // 将参数1,2绑定到函数 foo 上，但是使用 std::placeholders::_1 来对第一个参数进行占位 auto bindFoo = std::bind(foo, std::placeholders::_1, 1,2); // 这时调用 bindFoo 时，只需要提供第一个参数即可 bindFoo(1); } 提示：注意 auto 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型，但是我们却可以通过 auto 的使用来规避这一问题的出现。 右值引用 右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大量的历史遗留问题，消除了诸如 std::vector、std::string 之类的额外开销，也才使得函数对象容器 std::function 成为了可能。 （1）左值、右值的纯右值、将亡值、右值 要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。 左值(lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说，左值是表达式（不一定是赋值表达式）后依然存在的持久对象。 右值(rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。 而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。 纯右值(prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 10, true；要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。 将亡值(xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++中，纯右值和右值是统一个概念），也就是即将被销毁、却能够被移动的值。 将亡值可能稍有些难以理解，我们来看这样的代码： std::vector foo() { std::vector temp = {1, 2, 3, 4}; return temp; } std::vector v = foo(); 在这样的代码中，函数 foo 的返回值 temp 在内部创建然后被赋值给 v，然而 v 获得这个对象时，会将整个 temp 拷贝一份，然后把 temp 销毁，如果这个 temp 非常大，这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。在最后一行中，v 是左值、foo() 返回的值就是右值（也是纯右值）。 但是，v 可以被别的变量捕获到，而 foo() 产生的那个返回值作为一个临时值，一旦被 v 复制后，将立即被销毁，无法获取、也不能修改。 将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动。 （2）右值引用和左值引用 需要拿到一个将亡值，就需要用到右值引用的申明：T &&，其中 T 是类型。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。 C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象，例如： #include #include void reference(std::string& str) { std::cout 注意：rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。 （3）移动语义 传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、再把原来的东西全部销毁，这是非常反人类的一件事情。 传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据移动，浪费时间和空间。右值引用的出现恰好就解决了这两个概念的混淆问题，例如： #include class A { public: int *pointer; A() :pointer(new int(1)) { std::cout 在上面的代码中： 首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出； 函数返回后，产生一个将亡值，被 A 的移动构造（A(A&&)）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。 从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子： #include // std::cout #include // std::move #include // std::vector #include // std::string int main() { std::string str = \"Hello world.\"; std::vector v; // 将使用 push_back(const T&), 即产生拷贝行为 v.push_back(str); // 将输出 \"str: Hello world.\" std::cout （4）完美转发 前面我们提到了，一个声明的右值引用其实是一个左值。这就为我们进行参数转发（传递）造成了问题： void reference(int& v) { std::cout void pass(T&& v) { std::cout 对于 pass(1) 来说，虽然传递的是右值，但由于 v 是一个引用，所以同时也是左值。因此 reference(v) 会调用 reference(int&)，输出『左值』。而对于pass(v)而言，v是一个左值，为什么会成功传递给 pass(T&&) 呢？ 这是基于引用坍缩规则的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用，但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用，既能左引用，又能右引用。但是却遵循如下规则： 函数形参类型 实参参数类型 推导后函数形参类型 T& |左引用 |T& T& |右引用 |T& T&& |左引用 |T& T&& |右引用 |T&& 因此，模板函数中使用 T&& 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。更准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型。这才使得 v 作为左值的成功传递。 完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候，保持原来的参数类型（左引用保持左引用，右引用保持右引用）。为了解决这个问题，我们应该使用 std::forward 来进行参数的转发（传递）： #include #include void reference(int& v) { std::cout void pass(T&& v) { std::cout (v)); } int main() { std::cout 输出结果为： 传递右值: 普通传参:左值引用 std::move 传参:右值引用 std::forward 传参:右值引用 传递左值: 普通传参:左值引用 std::move 传参:右值引用 std::forward 传参:左值引用 无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发，所以 std::move 总会接受到一个左值，从而转发调用了reference(int&&) 输出右值引用。 唯独 std::forward 即没有造成任何多余的拷贝，同时完美转发(传递)了函数的实参给了内部调用的其他函数。 这里 std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值，std::forward 也只是单纯的将参数做了一个类型的转换，从是实现来看，std::forward(v) 和 static_cast(v) 是完全一样的。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_3.html":{"url":"practice/chap4/4_3.html","title":"对标准库的扩充：新增容器","keywords":"","body":" 对标准库的扩充：新增容器 std::array 和 std::forward_list （1）std::array 看到这个容器的时候肯定会出现这样的问题： 为什么要引入 std::array 而不是直接使用 std::vector？ 已经有了传统数组，为什么要用 std::array? 先回答第一个问题，std::vecotr 太强大了，以至于我们没有必要为了去敲碎一个鸡蛋而用一个钉锤。使用 std::array 保存在栈内存中，相比堆内存中的 std::vector，我们就能够灵活的访问这里面的元素，从而获得更高的性能；同时正式由于其堆内存存储的特性，有些时候我们还需要自己负责释放这些资源。 而第二个问题就更加简单，使用std::array能够让代码变得更加现代，且封装了一些操作函数，同时还能够友好的使用标准库中的容器算法等等，比如 std::sort。 std::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array 很简单，只需指定其类型和大小即可： std::array arr= {1,2,3,4}; int len = 4; std::array arr = {1,2,3,4}; // 非法, 数组大小参数必须是常量表达式 当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法： void foo(int *p, int len) { return; } std::array arr = {1,2,3,4}; // C 风格接口传参 // foo(arr, arr.size()); // 非法, 无法隐式转换 foo(&arr[0], arr.size()); foo(arr.data(), arr.size()); // 使用 `std::sort` std::sort(arr.begin(), arr.end()); （2）std::forward_list std::forward_list 是一个列表容器，使用方法和 std::list 基本类似，因此我们就不花费篇幅进行介绍了。 需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。 无序容器 我们已经熟知了传统 C++ 中的有序容器 std::map/std::set，这些容器内部通过红黑树进行实现，插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。 C++11 引入了两组无序容器：std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。 它们的用法和原有的 std::map/std::multimap/std::set/set::multiset 基本类似，由于这些容器我们已经很熟悉了，便不一一举例，我们直接来比较一下std::map和std::multimap： #include #include #include #include int main() { // 两组结构按同样的顺序初始化 std::unordered_map u = { {1, \"1\"}, {3, \"3\"}, {2, \"2\"} }; std::map v = { {1, \"1\"}, {3, \"3\"}, {2, \"2\"} }; // 分别对两种容器进行遍历 std::cout 最终的输出结果为： std::unordered_map Key:[2] Value:[2] Key:[3] Value:[3] Key:[1] Value:[1] std::map Key:[1] Value:[1] Key:[2] Value:[2] Key:[3] Value:[3] 元组 std::tuple 了解过 Python 的程序员应该知道元组的概念，纵观传统 C++ 中的容器，除了 std::pair 外，似乎没有现成的结构能够用来存放不同类型的数据（通常我们会自己定义结构）。但 std::pair 的缺陷是显而易见的，只能保存两个元素。 （1）元组基本操作 关于元组的使用有三个核心的函数： std::make_tuple: 构造元组 std::get: 获得元组某个位置的值 std::tie: 元组拆包 #include #include auto get_student(int id) { // 返回类型被推断为 std::tuple if (id == 0) return std::make_tuple(3.8, 'A', \"张三\"); if (id == 1) return std::make_tuple(2.9, 'C', \"李四\"); if (id == 2) return std::make_tuple(1.7, 'D', \"王五\"); return std::make_tuple(0.0, 'D', \"null\"); // 如果只写 0 会出现推断错误, 编译失败 } int main() { auto student = get_student(0); std::cout (student) (student) (student) std::get 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象： std::tuple t(\"123\", 4.5, 6.7, 8); std::cout (t) (t) (t) （2）运行期索引 如果你仔细思考一下可能就会发现上面代码的问题，std::get<> 依赖一个编译期的常量，所以下面的方式是不合法的： int index = 1; std::get(t); 那么要怎么处理？答案是，标准库做不到。这里介绍一个使用 boost::variant 配合变长模板参数的黑魔法： 提示：使用 boost 只是暂时性的解决方案，variant 已在 C++17 中被纳入标准库 std::variant，见扩展主题它的讨论。http://en.cppreference.com/w/cpp/utility/variant #include template boost::variant _tuple_index(size_t i, const std::tuple& tpl) { if (i == n) return std::get(tpl); else if (n == sizeof...(T) - 1) throw std::out_of_range(\"越界.\"); else return _tuple_index(i, tpl); } template boost::variant tuple_index(size_t i, const std::tuple& tpl) { return _tuple_index(i, tpl); } 这样我们就能： int i = 1; std::cout （3）元组合并与遍历 还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现： auto new_tuple = std::tuple_cat(get_student(1), std::move(t)); 马上就能够发现，应该如何快速遍历一个元组？但是我们刚才介绍了如何在运行期通过非常数索引一个 tuple 那么遍历就变得简单了，首先我们需要知道一个元组的长度，可以： template auto tuple_len(T &tpl) { return std::tuple_size::value; } 这样就能够对元组进行迭代了： // 迭代 for(int i = 0; i != tuple_len(new_tuple); ++i) // 运行期索引 std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_4.html":{"url":"practice/chap4/4_4.html","title":"对标准库的扩充: 智能指针和引用计数","keywords":"","body":" 对标准库的扩充: 智能指针和引用计数 RAII 与引用计数 了解 Objective-C/Swift 的程序员应该知道引用计数的概念。引用计数这种计数是为了防止内存泄露而产生的。基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。 在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。 凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 new 和 delete 去『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。这些智能指针就包括 std::shared_ptr/std::unique_ptr/std::weak_ptr，使用它们需要包含头文件 。 注意：引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待，更能够清晰明确的表明资源的生命周期。 std::shared_ptr std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式调用 delete，当引用计数变为零的时候就会将对象自动删除。 但还不够，因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。 std::make_shared 就能够用来消除显示的使用 new，所以std::make_shared 会分配创建传入参数中的对象，并返回这个对象类型的std::shared_ptr指针。例如： #include #include void foo(std::shared_ptr i) { (*i)++; } int main() { // auto pointer = new int(10); // 非法, 不允许直接赋值 // 构造了一个 std::shared_ptr auto pointer = std::make_shared(10); foo(pointer); std::cout std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数，并通过get_count()来查看一个对象的引用计数。例如： auto pointer = std::make_shared(10); auto pointer2 = pointer; // 引用计数+1 auto pointer3 = pointer; // 引用计数+1 int *p = pointer.get(); // 这样不会增加引用计数 std::cout std::unique_ptr std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证了代码的安全： std::unique_ptr pointer = std::make_unique(10); // make_unique 从 C++14 引入 std::unique_ptr pointer2 = pointer; // 非法 make_unique 并不复杂，C++11 没有提供 std::make_unique，可以自行实现： template std::unique_ptr make_unique( Args&& ...args ) { return std::unique_ptr( new T( std::forward(args)... ) ); } 至于为什么没有提供，C++ 标准委员会主席 Herb Sutter 在他的博客中提到原因是因为『被他们忘记了』。 既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr，例如： #include #include struct Foo { Foo() { std::cout p1(std::make_unique()); // p1 不空, 输出 if (p1) p1->foo(); { std::unique_ptr p2(std::move(p1)); // p2 不空, 输出 f(*p2); // p2 不空, 输出 if(p2) p2->foo(); // p1 为空, 无输出 if(p1) p1->foo(); p1 = std::move(p2); // p2 为空, 无输出 if(p2) p2->foo(); std::cout foo(); // Foo 的实例会在离开作用域时被销毁 } std::weak_ptr 如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。看下面这个例子： #include #include class A; class B; class A { public: std::shared_ptr pointer; ~A() { std::cout pointer; ~B() { std::cout a = std::make_shared(); std::shared_ptr b = std::make_shared(); a->pointer = b; b->pointer = a; return 0; } 运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，这使得 a,b 的引用计数均变为了 2，而离开作用域时，a,b 智能指针被析构，却智能造成这块区域的引用计数减一，这样就导致了 a,b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露 解决这个问题的办法就是使用弱引用指针 std::weak_ptr，std::weak_ptr是一种弱引用（相比较而言 std::shared_ptr 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的释放 std::weak_ptr 没有 * 运算符和 -> 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 std::shared_ptr 是否存在，expired() 方法在资源未被释放时，会返回 true，否则返回 false。 正确的代码如下： #include #include class A; class B; class A { public: // A 或 B 中至少有一个使用 weak_ptr std::weak_ptr pointer; ~A() { std::cout pointer; ~B() { std::cout a = std::make_shared(); std::shared_ptr b = std::make_shared(); a->pointer = b; b->pointer = a; return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_5.html":{"url":"practice/chap4/4_5.html","title":"对标准库的扩充: 正则表达式","keywords":"","body":" 对标准库的扩充: 正则表达式 正则表达式简介 正则表达式不是 C++ 语言的一部分，这里仅做简单的介绍。 正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求： 检查一个串是否包含某种形式的子串； 将匹配的子串替换； 从某个串中取出符合条件的子串。 正则表达式是由普通字符（例如 a 到 z）以及特殊字符组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 （1）普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 （2）特殊字符 特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表： 特别字符 描述 $ |匹配输入字符串的结尾位置。 (,) |标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。 |匹配前面的子表达式零次或多次。 |匹配前面的子表达式一次或多次。 . |匹配除换行符 \\n 之外的任何单字符。 [ |标记一个中括号表达式的开始。 ? |匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。 \\ |将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， n 匹配字符 n。 \\n |匹配换行符。序列 \\ 匹配 '\\' 字符，而 ( 则匹配 '(' 字符。 ^ |匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。 { |标记限定符表达式的开始。 | |指明两项之间的一个选择。 （3）限定符 限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表： 字符 描述 |匹配前面的子表达式零次或多次。例如，foo 能匹配 fo 以及 foooo。 等价于{0,}。 |匹配前面的子表达式一次或多次。例如，foo+ 能匹配 foo 以及 foooo，但不能匹配 fo。+ 等价于 {1,}。 ? |匹配前面的子表达式零次或一次。例如，Your(s)? 可以匹配 Your 或 Yours 中的Your 。? 等价于 {0,1}。 {n} |n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 for 中的 o，但是能匹配 foo 中的两个 o。 {n,} |n 是一个非负整数。至少匹配 n 次。例如，o{2,} 不能匹配 for 中的 o，但能匹配 foooooo 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。 {n,m} |m 和 n 均为非负整数，其中 n 小于等于 m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 foooooo 中的前三个 o。o{0,1} 等价于 o?。注意，在逗号和两个数之间不能有空格。 有了这三张表，我们通常就能够读懂几乎所有的正则表达式了。 std::regex 及其相关 对字符串内容进行匹配的最常见手段就是使用正则表达式。可惜在传统 C++ 中正则表达式一直没有得到语言层面的支持，没有纳入标准库，而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时，使用正则表达式也是工业界最为成熟的普遍做法。 一般的解决方案就是使用 boost 的正则表达式库。而 C++11 正式将正则表达式的的处理方法纳入标准库的行列，从语言级上提供了标准的支持，不再依赖第三方。 C++11 提供的正则表达式库操作 std::string 对象，模式 std::regex (本质是 std::basic_regex)进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch （本质是 std::match_results 对象）。 我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式 [a-z]+.txt: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多次，因此 [a-z]+ 能够匹配一个小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字符，而 . 则表示匹配字符 .，最后的 txt 表示严格匹配 txt 则三个字母。因此这个正则表达式的所要匹配的内容就是由纯小写字母组成的文本文件。 std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是传入std::string 以及一个 \u001bstd::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。例如： #include #include #include int main() { std::string fnames[] = {\"foo.txt\", \"bar.txt\", \"test\", \"a0.txt\", \"AAA.txt\"}; // 在 C++ 中 `\\` 会被作为字符串内的转义符，为使 `\\.` 作为正则表达式传递进去生效，需要对 `\\` 进行二次转义，从而有 `\\\\.` std::regex txt_regex(\"[a-z]+\\\\.txt\"); for (const auto &fname: fnames) std::cout 另一种常用的形式就是依次传入 std::string/std::smatch/std::regex 三个参数，其中 std::smatch 的本质其实是 std::match_results，在标准库中， std::smatch 被定义为了 std::match_results，也就是一个子串迭代器类型的 match_results。使用 std::smatch 可以方便的对匹配的结果进行获取，例如： std::regex base_regex(\"([a-z]+)\\\\.txt\"); std::smatch base_match; for(const auto &fname: fnames) { if (std::regex_match(fname, base_match, base_regex)) { // sub_match 的第一个元素匹配整个字符串 // sub_match 的第二个元素匹配了第一个括号表达式 if (base_match.size() == 2) { std::string base = base_match[1].str(); std::cout 以上两个代码段的输出结果为： foo.txt: 1 bar.txt: 1 test: 0 a0.txt: 0 AAA.txt: 0 sub-match[0]: foo.txt foo.txt sub-match[1]: foo sub-match[0]: bar.txt bar.txt sub-match[1]: bar OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_6.html":{"url":"practice/chap4/4_6.html","title":"对标准库的扩充: 语言级线程支持","keywords":"","body":" 对标准库的扩充: 语言级线程支持 std::thread std::thread 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含头文件，它提供了很多基本的线程操作，例如get_id()来获取所创建线程的线程 ID，例如使用 join() 来加入一个线程等等，例如： #include #include void foo() { std::cout std::mutex, std::unique_lock 我们在操作系统的相关知识中已经了解过了有关并发技术的基本知识，mutex 就是其中的核心之一。C++11 引入了 mutex 相关的类，其所有相关的函数都放在 头文件中。 std::mutex 是 C++11 中最基本的 mutex 类，通过实例化 std::mutex 可以创建互斥量，而通过其成员函数 lock() 可以仅此能上锁，unlock() 可以进行解锁。但是在在实际编写代码的过程中，最好不去直接调用成员函数，因为调用成员函数就需要在每个临界区的出口处调用 unlock()，当然，还包括异常。这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类std::lock_gurad。RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。 在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如： void some_operation(const std::string &message) { static std::mutex mutex; std::lock_guard lock(mutex); // ...操作 // 当离开这个作用域的时候，互斥锁会被析构，同时unlock互斥锁 // 因此这个函数内部的可以认为是临界区 } 由于 C++保证了所有栈对象在声明周期结束时会被销毁，所以这样的代码也是异常安全的。无论 some_operation() 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 unlock()。 而 std::unique_lock 则相对于 std::lock_guard 出现的，std::unique_lock 更加灵活，std::unique_lock 的对象会以独占所有权（没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权）的方式管理 mutex 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 std::unique_lock。例如： #include #include #include std::mutex mtx; void block_area() { std::unique_lock lock(mtx); //...临界区 } int main() { std::thread thd1(block_area); thd1.join(); return 0; } std::future, std::packaged_task std::future 则是提供了一个访问异步操作结果的途径，这句话很不好理解。为了理解这个特性，我们需要先理解一下在 C++ 11 之前的多线程行为。 试想，如果我们的主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务，并返回我一个结果。而这时候，线程 A 可能正在忙其他的事情，无暇顾及 B 的结果，所以我们会很自然的希望能够在某个特定的时间获得线程 B 的结果。 在 C++11 的 std::future 被引入之前，通常的做法是：创建一个线程 A，在线程 A 里启动任务 B，当准备完毕后发送一个事件，并将结果保存在全局变量中。而主函数线程 A 里正在做其他的事情，当需要结果的时候，调用一个线程等待函数来获得执行的结果。 而 C++11 提供的 std::future 简化了这个流程，可以用来获取异步任务的结果。自然地，我们很容易能够想象到把它作为一种简单的线程同步手段。 此外，std::packaged_task 可以用来封装任何可以调用的目标，从而用于实现异步的调用。例如： #include #include #include int main() { // 将一个返回值为7的 lambda 表达式封装到 task 中 // std::packaged_task 的模板参数为要封装函数的类型 std::packaged_task task([](){return 7;}); // 获得 task 的 future std::future result = task.get_future(); // 在一个线程中执行 task std::thread(std::move(task)).detach(); std::cout 在封装好要调用的目标后，可以使用 get_future() 来获得一个 std::future 对象，以便之后事实线程同步。 std::condition_variable std::condition_variable 是为了解决死锁而生的。当互斥操作不够用而引入的。比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，condition_variable 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。std::condition_variable的 notify_one() 用于唤醒一个线程；notify_all() 则是通知所有线程。下面是一个生产者和消费者模型的例子： #include #include #include #include #include #include int main() { // 生产者数量 std::queue produced_nums; // 互斥锁 std::mutex m; // 条件变量 std::condition_variable cond_var; // 结束标志 bool done = false; // 通知标志 bool notified = false; // 生产者线程 std::thread producer([&]() { for (int i = 0; i lock(m); std::cout lock(m); while (!done) { while (!notified) { // 循环避免虚假唤醒 cond_var.wait(lock); } while (!produced_nums.empty()) { std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap4/4_7.html":{"url":"practice/chap4/4_7.html","title":"其他杂项","keywords":"","body":" 其他杂项 新类型 long long int long long int 并不是 C++11 最先引入的，其实早在 C99，long long int 就已经被纳入 C 标准中，所以大部分的编译器早已支持。C++11 的工作则是正式把它纳入标准库，规定了一个 long long int 类型至少具备 64 位的比特数。 noexcept 的修饰和操作 C++ 相比于 C 的一大优势就在于 C++ 本身就定义了一套完整的异常处理机制。然而在 C++11 之前，几乎没有人去使用在函数名后书写异常声明表达式，从 C++11 开始，这套机制被弃用，所以我们不去讨论也不去介绍以前这套机制是如何工作如何使用，你更不应该主动去了解它。 C++11 将异常的声明简化为以下两种情况： 函数可能抛出任何异常 函数不能抛出任何异常 并使用 noexcept 对这两种行为进行限制，例如： void may_throw(); // 可能抛出异常 void no_throw() noexcept; // 不可能抛出异常 使用 noexcept 修饰过的函数如果抛出异常，编译器会使用 std::terminate() 来立即终止程序运行。 noexcept 还能用作操作符，用于操作一个表达式，当表达式无异常时，返回 true，否则返回 false。 #include void may_throw() { throw true; } auto non_block_throw = []{ may_throw(); }; void no_throw() noexcept { return; } auto block_throw = []() noexcept { no_throw(); }; int main() { std::cout noexcept 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发。例如： try { may_throw(); } catch (...) { std::cout 最终输出为： 捕获异常, 来自 my_throw() 捕获异常, 来自 non_block_throw() 字面量 原始字符串字面量 传统 C++ 里面要编写一个充满特殊字符的字符串其实是非常痛苦的一件事情，比如一个包含 HTML 本体的字符串需要添加大量的转义符，例如一个 Windows 上的文件路径经常会：C:\\What\\The\\Fxxk。 C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 R 来修饰这个字符串，同时，将原始字符串使用括号包裹，例如： #include #include int main() { std::string str = R\"(C:\\\\What\\\\The\\\\Fxxk)\"; std::cout 自定义字面量 C++11 引进了自定义字面量的能力，通过重载双引号后缀运算符实现： // 字符串字面量自定义必须设置如下的参数列表 std::string operator\"\" _wow1(const char *wow1, size_t len) { return std::string(wow1)+\"woooooooooow, amazing\"; } std::string operator\"\" _wow2 (unsigned long long i) { return std::to_string(i)+\"woooooooooow, amazing\"; } int main() { auto str = \"abc\"_wow1; auto num = 1_wow2; std::cout 自定义字面量支持四种字面量： 整型字面量：重载时必须使用 unsigned long long、const char *、模板字面量算符参数，在上面的代码中使用的是前者； 浮点型字面量：重载时必须使用 long double、const char *、模板字面量算符； 字符串字面量：必须使用 (const char *, size_t) 形式的参数表； 字符字面量：参数只能是 char, wchar_t, char16_t, char32_t 这几种类型。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:45:53 "},"practice/chap5/5_0summary.html":{"url":"practice/chap5/5_0summary.html","title":"C++ 实现高性能 RTTI 库","keywords":"","body":" C++ 实现高性能 RTTI 库 RTTI 是运行时类型识别的英文缩写，C++ 本身提供了运行时类型识别的运算符 dynamic_cast 和 typeid，然而 dynamic_cast 的效率其实并不理想，需要牺牲一定性能。本项目将手动实现一个高性能 RTTI 库。 项目涉及的知识点 运行时类型识别 dynamic_cast, typeid 显式类型转换 static_cast, const_cast, reinterpret_cast OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap5/5_1.html":{"url":"practice/chap5/5_1.html","title":"基础知识：运行时类型识别","keywords":"","body":" 基础知识：运行时类型识别 编译器运行时类型识别 C++ 提供了虚函数的特性，这导致了多态的存在，对于多态性的对象，程序编译时就可能出现无法确定对象的类型的情况。当类中含有虚函数时，基类指针就能够指向任何派生类的对象，这就导致了我们无法知道基类指针指向的到底是哪个对象的情况。所以类的类型就需要在运行时候利用运行时类型标识，RTTI 应运而生。 RTTI，Run Time Type Identification，通过运行时类型识别程序能够使用基类指针或引用检查这些指针或引用的对象。RTTI 提供了两个操作符，分别是： typeid：用于返回指针和引用所指的实际类型。 dynamic_cast: 将基类类型的指针或引用，安全地转换为派生类的指针或引用。 来看一个例子： #include struct V { virtual void f() {}; }; struct A : virtual V {}; struct B : virtual V { B(V* v, A* a) { // 在构造时进行转换 dynamic_cast(v); // 明确定义的: v 的类型为 V*, V 是 B 的基类, 结果为 B* dynamic_cast(a); // 未定义行为: a 的类型为 A*, A 不是 B 的基类 } }; struct D : A, B { D() : B((A*)this, this) { } }; struct Base { virtual ~Base() {} }; struct Derived: Base { virtual void name() {} }; int main() { D d; // 派生类对象 A& a = d; // upcast D& new_d = dynamic_cast(a); // downcast B& new_b = dynamic_cast(a); // sidecast Base* b1 = new Base; if(Derived* d = dynamic_cast(b1)) { std::cout name(); // 安全调用 } Base* b2 = new Derived; if(Derived* d = dynamic_cast(b2)) { std::cout name(); // 安全调用 } delete b1; delete b2; } 上面的代码只会输出 b2 到 d 的 downcast。 首先我们定义了一个 D 类型的派生类对象，D 派生自 A 和 B。然后用一个 A 类型的引用去应用了一个 D 类型的对象，这就是典型的 upcast。 而如果我们将 A 类型的引用使用 dynamic_cast 转换为其子类对象的引用，这就是典型的 downcast。 而如果我们把一个引用 D 类对象的父类 A 引用转换为 D 类对象的另一个父类 B 的引用，这就是 sidecast。 接着，b1 是一个基类指针，指向了一个基类的对象，如果我们把它在运行时视为一个子类对象，而去调用子类对象的方法，这是不安全的调用，因此从 b1 到 d 的 downcast 是不会成功的。 而对于 b2 来说，b2 也是一个基类指针，但其指向的是一个派生类的对象，我们是能够通过 dynamic_cast 安全的将其转换成一个派生类指针，从而成功调用派生类的方法。 C++ 的显式类型转换 C++ 的显式类型转换除了 dynamic_cast 外，还有 static_cast, const_cast, reinterpret_cast。 static_cast 能够将任何具有明确定义的类型转换，只要不包含底层 const，都可以使用 static_cast，由于是静态类型转换，也就没有了运行时类型转换来保证转换的安全性。而 const_cast 只能改变对象的底层 const 性质，不能改变表达式运算对象的类型，可以用于增加或者移除对象的 const 属性。但值得注意的是，通过 const_cast 移除的 const 属性对象的写值行为是未定义的。 例如： int *num; const int *const_num; void* p = &num; int *static_cast_num = static_cast(p); int *static_cast_num2 = static_cast(const_num); // 错误, 无法转换 const 类型 int *const_cast_num = const_cast(const_num); // 使用 const_cast_num 的写值行为是未定义的 reinterpret_cast 则能够对对象的位模式提供低层次上的重新解释。举个例子： struct A { int a; }; struct B { int b; }; struct C : A, B {}; C c; std::cout (&c) (&c) 对于上面的代码来说，我们 C 结构继承自 A, B。当我们把对象 c 的地址使用 reinterpret_cast 转型成 B 时候，会直接将整块内存单元重新解释，所以其地址与 c 的地址相同，但是 static_cast 会为父类指针计算偏移量，将含有 a,b 的 c 转换为 B 而指向 b，导致最终输出的地址不同。最后的一个 C 风格的强制类型转换的结果与 static_cast 结果类似。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap6/6_0summary.html":{"url":"practice/chap6/6_0summary.html","title":"Makefile基础入门","keywords":"","body":" Makefile基础入门 Makefile 是一种描述工程编译、链接的文件。在一个庞大的项目或工程中，往往存在非常复杂的编译和链接流程，而 Makefile 文件可以描述哪些源文件在何时需要编译，如何编译这些源文件，甚至可以调用 shell 和其它的工具来执行更加复杂的项目构建流程。一旦 Makefile 文件构建完毕，用户只需要使用 GNU make 工具读入 Makefile 即可完成整个工程的编译和链接流程，极大提高了项目开发和测试的效率。 本系列的实验主要是让大家学习 Makefile 的基本规则。在正式讲述 make 工具的使用方式和 Makefile 书写规则之前，本次实验先介绍一些简单的前导知识，这也是 GNU make 官方手册中采用的教学模式。本次实验用于演示 GNU GCC 编译和链接的基本方法，通过编译、链接、静态链接、动态链接让用户学习和理解 GCC 的使用方式。另一方面，用户也将在实验过程中体验手动编译链接的效率，从而理解自动编译的在项目工程管理中的重要性。 编写基本代码 对代码进行编译，链接，并执行查看效果 添加代码扩展功能，并进行静态链接 添加代码扩展功能,并进行动态链接 使用静态+动态的混合链接 http://labfile.oss.aliyuncs.com/courses/849/make_example-master.zip OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap6/6_1.html":{"url":"practice/chap6/6_1.html","title":"Makefile 基础规则","keywords":"","body":" Makefile 基础规则一 makefile作为工程管理文件可以提供工程下各个源代码的编译、链接规则。 GNU make 工具可以读入makefile并解析其中的规则，并自动对工程进行编译链接，提高项目开发的效率。 action： makefile基本规则。 makefile时间戳检验测试。 验证makefile依赖文件的执行顺序。 变量，PHONY和“-”功能测试。 makefile文件命名规则。 编写一段程序的makefile文件。 知识点 makefile 的基本编译规则 make 更新目标的依据 makefile 目标依赖的执行顺序 makefile 变量的赋值与使用 .PHONY 的作用 “-” 的作用 make 搜寻 makefile的命名规则 编写一段程序的 makefile 文件 小型计算程序说明 现在我们已经掌握了makefile的基本规则，可以尝试自己写一个makefile进行工程管理。 在make_example/chapter0目录下有一段简单的计算器示例程序，现在要为它建立一个makefile文件。 切换到chapter0目录，查看目录下的文件： cd ../chapter0 ls 终端打印： add_minus.c add_minus.h main.c multi_div.c multi_div.h readme.md v1.0.patch v2.0.patch v3.0.patch 简单介绍一下程序的需求： add_minus.c要求被编译成静态链接库libadd_minus.a。 multi_div.c要求被编译成动态链接库libmulti_div.so。 main.c是主要的源文件，会调用上述两个代码文件中的API，main.c要求被编译为main.o。 将main.o libadd_minus.a libmulti_div.so链接成可执行文件 main。 每次编译前要清除上次编译时产生的文件。 打上补丁 v3.0 并增加库文件路径，export环境变量LD_LIBRARY_PATH为当前路径： patch -p2 makefile文件示例 # this is a chapter0 makefile .PHONY:all clean depen depen=clean main.o add_minus.o libadd_minus.a libmulti_div.so all:$(depen) -gcc -o main main.o -L./ -ladd_minus -lmulti_div main.o:main.c gcc -c main.c add_minus.o: gcc -c add_minus.c libadd_minus.a:add_minus.o ar rc libadd_minus.a add_minus.o libmulti_div.so: gcc multi_div.c -fPIC -shared -o libmulti_div.so clean: -rm $(depen) OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap6/6_3.html":{"url":"practice/chap6/6_3.html","title":"关于makefile","keywords":"","body":" 关于makefile makefile 简介 makefile就是一个简单的文本文件，它基本上就是由一条条的规则构成。下面，我们就来看一下makefile里的最基本的语法单元，规则。一条makefile的规则构成如下： target:prerequisites command1 command2 ..... commandN target：规则的目标，可以简单理解为这条规则存在的目的是什么。通常是程序中间或者最后需要生成的文件名，也可以不对应具体的文件，而仅仅就是个概念上的规则目标。 prerequisites：规则的依赖列表，可以简单的理解为要达到本条规则的目标所需要的先决条件是什么。可以是文件名，也可以是其他规则的目标； command：规则的命令，可以简单的理解为当目标所需要的先决条件的满足了之后，需要执行什么动作来达成规则的目标。规则的命令其实就是shell命令。一条规则中可以有多行命令，特别注意：每行命令都必须以tab键开始！ # 最简单的makefile文件 all: echo \"Hello world!\" #注意：每行命令都必须以tab键开始！ 这个简单的makefile文件，只有一条规则，规则的目标是all，没有任何依赖(规则不可以没有目标但是可以没有依赖)，以及一条命令(其实规则也是可以不需要任何命令的)。怎么用这个makefile呢？ make 的工作机理 那make工具又到底是如何工作的呢？解释make的工作机理，需分别回答以下3个问题： make命令如何使用 ； make从哪读取makefile； make如何解析执行makefile文件的规则。 make命令的基本使用范式如下： make [ -f makefile ] [ options ] ... [ targets ] ... 使用make命令的最简单的方式主要有以下四种形式： 简单粗暴，不带任何参数，直接执行make： $ make 指定makefile文件： $ make -f 指定 makefile 目标： $ make 到指定目录下执行make： $ make -C 在执行make的时候，我们可以带上-f 参数，来指定make命令从哪里读取makefile文件；而如果我们不显式指定，则make就会在当前目录下依次查找名字为GNUmakefile, makefile,和 Makefile的文件来作为其makefile文件。 在读取完makefile的内容后，make工具并不是逐条去执行makefile里的规则，而是以某条规则为突破口，多米诺骨牌效应式的去执行makefile里的规则。而这条作为突破口的规则的目标，称为终极目标 ，我们可以在执行make时以参数的形式指定终极目标，从而执行作为突破口的规则，如果我们不显式指定终极目标，make一般情况下将选择makefile的第一条规则的目标作为终极目标。 make解析makefile的流程如下： 假设有mekefile内容如下： 终极目标：依赖A 依赖B 依赖C 终极目标命令 依赖A：子依赖A1 子依赖A2 依赖A命令 依赖B：子依赖B1 子依赖B2 依赖B命令 依赖C：子依赖C1 子依赖C2 依赖C命令 过程一，以终极目标为树根，解析出整颗依赖树： 过程二，对整颗依赖树以从底到上，从左到右的顺序，解析执行每一条规则： OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"practice/chap6/6_4.html":{"url":"practice/chap6/6_4.html","title":"丰富我们的 makefile 语法工具箱","keywords":"","body":"丰富我们的 makefile 语法工具箱 变量的定义 makefile中的变量，与C语言中的宏类似，它为一个文本字符串（变量的值，其类型只能是字符串类型）提供了一个名字(变量名)。 变量定义的基本格式： 变量名 赋值符 变量值 变量名指的就是该变量的名字，是不包括“:”、“#”、“=”、前置空白和尾空白的任何字符串。需要注意的是，尽管在GNU make中没有对变量的命名有其它的限制，但定义一个包含除字母、数字和下划线以外的变量的做法也是不可取的，因为除字母、数字和下划线以外的其它字符可能会在以后的make版本中被赋予特殊含义，并且这样命名的变量对于一些shell来说不能作为环境变量使用。变量名是大小写敏感的。变量“foo”、“Foo”和“FOO”指的是三个不同的变量。Makefile传统做法是变量名是全采用大写的方式。推荐的做法是在对于内部定义定义的一般变量（例如：目标文件列表objects）使用小写方式，而对于一些参数列表（例如：编译选项CFLAGS）采用大写方式。 变量值，指的是变量所代表的内容，可以是一个文件名列表、编译选项列表、程序运行的选项参数列表、搜索源文件的目录列表、编译输出的目录列表和所有我们能够想到的事物。变量的值，其本质就是一个字符串。 赋值符，有= 、 := 、 ?=和 +=四种格式，其中= 和 := 为基本定义类型， ?=和 +=为基于=的扩展定义类型。 一个在makefile中定义变量的例子： objects = program.o foo.o utils.o 2.4.2 变量的引用 当我们定义了一个变量之后，我们就可以在makfile中的目标、依赖、命令中引用我们的变量；而所谓的变量引用，就是在引用变量名的地方，用变量所代表的内容，执行一个严格的文本替换过程(该过程也称为变量被展开的过程 )，替换掉变量的名字。 变量的引用有以下几种方式： ${变量名} $（变量名） $单字符变量名 ，变量名仅包含一个字符，如$@ 、$^等 一个在makefile中引用变量的例子： ```变量定义 objects = program.o foo.o utils.o program : $(objects) #在依赖中引用变量 gcc -o program ${objects} #在命令中引用变量 $(objects) : defs.h #在目标中引用变量 ### 变量的分类与赋值 根据变量定义时所使用的赋值操作符的不同，可以将变量分成两种类型(或者说是两种风格)： 递归展开式变量和直接展开式变量； >使用赋值操作符= 、 += 和 ?=定义的变量都是递归展开式变量，使用赋值操作符 :=定义的变量为直接展开式变量 。 >两种变量类型的的最根本区别在于：变量值的求值时机，递归式变量的求值时机在于变量被引用时，直接展开式的求值时机在于变量被定义时。 我们来编写makefile 文件 /home/shiyanlou/Code/makefile_sample/variabletype.mk： foo1 = $(bar) #递归展开式变量 foo2 := $(bar) #直接展开式变量 bar = $(ugh) ugh = Huh? all: echo \"foo1 is $(foo1), foo2 is $(foo2)\" 然后，使用 $ make -f variabletype.mk 执行variabletype.mk 由于变量foo1的变量值是在执行echo命令时才求的值，所以foo1的值被递归的展开为Huh?； 而变量foo2的变量值在定义时就被求值了，此时由于变量bar的值为空，因此foo2的值也为空。 注意：使用递归展开式的变量定义，可能会由于出现变量的递归定义而导致make陷入到无限的变量展开过程中，最终使make执行失败 += 和 ?=是基于=扩展而来的两种变量赋值操作符； += 称为追加赋值操作符，它实现对于一个已经存在定义的变量进行追加赋值，如下例子： bar = foo1bar += foo2 #追加赋值，bar的值将为 foo1 foo2 all: echo $(bar) ?=称为条件赋值的赋值操作符，被称为条件赋值为：只有此变量在之前没有赋值的情况下才会对这个变量进行赋值。看一下例子： bar1 = foo1 bar1 ?= foo2 # bar1 的值还是foo1 bar2 ?= foo2 # bar2 的值为foo2 all: echo \"bar1 is $(bar1), bar2 is $(bar2)\" ### 特殊的变量 在makefile 中用户除了可以自定义变量外，还可以使用make工具为我们提供的一些特殊的变量及用法。 - 自动化变量 所谓自动化变量，就是在每条规则中，make自动为我们提供的用于指定规则各个组成部分的变量，一般情况下常用的有以下几个自动化变量： >$@ -- 代表规则中的目标文件名 >$$^ -- 代表规则中所有依赖文件的列表，文件名用空格分割 看例子，编写makefile 文件 /home/shiyanlou/Code/makefile_sample/auto_var.mk： all: first second third echo \"$$@ = $@\" echo \"$$ first second third: 这里有几点需要说明一下： >1. $字符在makefile中有特殊用途，因此如果要取消其特殊用途当成一个普通字符传递给echo命令执行，需要使用$$ >2. $@在bash shell中也有特殊用途，因此如果希望echo命令在bash中正常输出$@， 需要加上\\字符 >3. 该makefile的最后一行first second third: 看起来有点奇怪，这是一条没有依赖和命令的多目标规则，读者可自行将它删除看有什么效果，并思考原因。 ### 变量的替换引用 变量的分类与赋值 对于一个已经定义的变量，可以使用“替换引用”将其值使用指定的字符（字符串）进行替换。格式为$(VAR:A=B)或者${VAR:A=B}，意思是，将变量“VAR”所表示的值中所有字符串“A”结尾的字符替换为“B”的字。“结尾”的含义是空格之前（变量值的多个字以空格分开）。而对于变量其它部分的“A”字符不进行替换。例如： sources := a.c b.c c.c d.d objects := $(sources:.c=.o) all: echo \"objects = $(objects)\" 在这个定义中，变量“objects”的值就为“a.c b.c c.c d.d”。使用变量的替换引用将变量“sources”以空格分开的值中的所有的字的尾字符“o”替换为“c”，其他部分不变，注意这里的d.d并不会被替换。 使用变量改进我们complicated项目的makefile(v1.2)： 描述：complicated 项目 makefile文件 版本：v1.2 修改记录： 1. 为complicated项目makefile添加注释 2. 使用变量改进我们complicated项目的makefile 定义可执行文件变量 executbale := complicated 定义源文件列表变量 sources := main.c complicated.c 使用变量的引用替换，定义object文件列表 objects := $(sources:.c=.o) 定义编译命令变量 CC := gcc 终极目标规则，生成complicated可执行文件 $(executbale): $(objects) 使用自动化变量改造我们的编译命令 $(CC) -o $@ $^ 子规则1, main.o的生成规则 main.o: main.c $(CC) -o $@ -c $ 子规则2，complicated.o的生成规则 complicated.o: complicated.c $(CC) -o $@ -c $ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 15:44:33 "},"basic/summary.html":{"url":"basic/summary.html","title":"基础知识补充","keywords":"","body":"基础知识 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 10:51:22 "},"basic/chap1/SUMMARY_01.html":{"url":"basic/chap1/SUMMARY_01.html","title":"从C过渡到C++","keywords":"","body":"Part 1 从C过渡到C++ 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 14:41:53 "},"basic/chap1/内联函数.html":{"url":"basic/chap1/内联函数.html","title":"内联函数","keywords":"","body":"内联函数 通过“内存膨胀”，空间换时间，提高程序的运行速度 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用 如下风格的函数Foo 不能成为内联函数： inline void Foo(int x, int y); // inline 仅与函数声明放在一起 void Foo(int x, int y) { } 而如下风格的函数Foo 则成为内联函数： void Foo(int x, int y); inline void Foo(int x, int y) // inline 与函数定义体放在一起 { } 所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。 一般地，用户可以阅读函数的声明，但是看不到函数的定义。 尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。 inline只适合涵数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数(自己内部还调用自己的函数)。 以下情况不宜使用内联： （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 16:42:35 "},"basic/chap1/函数重载.html":{"url":"basic/chap1/函数重载.html","title":"函数重载","keywords":"","body":"函数重载 在同一个项目中定义的函数名字可以重复 函数名一致 参数列表不同 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 16:44:37 "},"basic/chap1/函数参数缺省.html":{"url":"basic/chap1/函数参数缺省.html","title":"函数参数缺省","keywords":"","body":"函数参数缺省 定义函数的时候可以让最右边的连续若干个参数有缺省值，在调用函数的时候，如果不写相应位置的参数，则调用的参数就为缺省值。 形参，从后往前给，必须倒着，譬如先c,后b,再后a 例如：void fun(int a, int b = 1, int c = 2) { cout 在调用时，如果参数b和c的参数没有给出，则默认为缺省值。 函数缺省参数的作用在于提高程序的可扩充性。 比如某个以及写好的函数需要添加新的参数，而原先调用函数的的那些语句未必需要新增加的参数，为了避免对原来所有调用该函数的地方进行修改，就可以使用函数缺省参数了。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 17:01:27 "},"basic/chap1/引用.html":{"url":"basic/chap1/引用.html","title":"引用","keywords":"","body":"引用 引用基础 引用的概念 引用是一个变量的“别名”，对应的是同一段内存，也就意味这可以通过引用来修改被引用变量的值； 引用的基础语法： Type & name = var； int b = 1; int &a = b; 引用基础使用 引用的定义时必须进行初始化； //test5.cpp #include using namespace std; struct Teacher { int age_ = 31; int &a; //error 引用没有初始化； float &b; //error 引用没有初始化； }; int main() { int a = 10; // int & b; // error, 引用没有初始化； //Teacher my_teacher; } 基础类型的引用； //test1.cpp #include using namespace std; int main() { int a = 10; int &b = a; // 必须进行初始化； b = 11; // 使用引用可以修改被引用变量的值； cout 自定义类型的引用； //test2.cpp #include using namespace std; struct Teacher { int age_ = 30; float height_ = 174.5; }; int main() { Teacher my_teacher; Teacher &one_teacher = my_teacher; one_teacher.age_ = 31; std::cout 引用不能改变目标（在定义时确认了引用对象后，不能再修改引用对象） //test4.cpp #include using namespace std; int main() { int a = 10; int c = 11; int &b = a; // 必须进行初始化； b = c; // b 并没有指向c, 它还是a的别名，但a的值变成了与c一样； cout 引用做函数参数 引用作为函数的参数可以不进行初始化； //test3.cpp #include using namespace std; struct Teacher { int age_ = 30; float height_ = 174.5; }; void MyFun(Teacher &OneTeacher) { OneTeacher.height_ = 185.9; } int main() { Teacher my_teacher; MyFun(my_teacher); std::cout 引用的本质 引用的实质 从基础类型的引用来看，引用规定定义时必须进行初始化，这一点与const变量的定义要求很像，且通过引用可以直接修改被引用变量中的值，所以带有指针的属性； 引用的本质： const类型的指针；（编译器实现） 本身所占地址空间与指针一样（跟系统和编译器有关）； //test7.cpp #include using namespace std; struct Teacher { int age_ = 30; // 8个字节 float height_ = 174.5; // 4字节 double weight_ = 70.0; //8字节 int &a; // 未初始化，仅仅用来试验内存占用大小，与指针占用大小一样 }; void MyFun(Teacher &OneTeacher) { OneTeacher.height_ = 185.9; } int main() { /* 基础数据类型 */ int a = 11; int &b = a; // 等价于： int *const b = &a; // b是一个int类型的指针，指针本身不能变，指针内所指内容可以变； b = 12; // 等价于 （*b) = 12; /* 引用本身占4个字节 */ int *pt = NULL; cout 引用的意义 是指针的一种封装和简化，提升了代码的可读性和安全性； 引用难点 引用作为函数的返回值 （1）返回基础数据类型的引用 若返回的是一个临时变量，不能作为其他引用的初始值，不能当做左值使用；（在有些编译器中，返回临时变量的引用，既不能当左值，又不能当右值）； //test8.cpp #include using namespace std; /* 返回临时变量的引用 */ int& MyFun1() { int var = 10; return var; } int main() { int a = 0; // a = MyFun1(); // error // int &b = MyFun1(); //error } 若返回的是一个静态变量或者全局变量，可以作为其他引用的初始值，既可以作为左值，也可以作为右值； //test9.cpp #include using namespace std; int global_var1 = 8; int global_var2 = 77; int& MyFun1() { return global_var1; } int& MyFun2() { return global_var2; } int& MyFun3() { static int c = 4; return c; } int main() { /* 返回引用作为右值 */ int a = MyFun1(); cout 思考： 本质返回的就是一个地址，关键是这个地址里面的数会不会变化； 当返回的是函数内部的临时变量时，函数运行完内存就销毁，所以不能作为左值； 承接的时候，需要结合返回的地址和接受的地址综合考虑，函数运行完，返回的是这个地址的副本，如果用值去接，能接到值，如果用地址（含引用）去接，那么接到的有可能就是值（跟编译器相关） （2）返回自定义类型的引用（类） 【todo】 涉及拷贝构造函数和运算符重载，后续填坑； 常引用 常引用：不能通过引用去修改被引用的变量； //test10.cpp #include using namespace std; int main() { int a = 11; const int &b = a; //b = 12; //error ，不能通过常引用去修改被引用对象； a = 13; // 原变量还是可以修改的 } 常引用的初始化，可以用字面量进行初始化，也可以使用变量进行初始化； 非const引用，不能使用字面量进行初始化； const引用使用字面量进行初始化时，c++中const本身应该放到符号表中，没有分配内存空间，但当看到&操作符时， C++编译器会单独分配一个内存空间用于存放字面量； //test11.cpp #include using namespace std; int main() { int a = 11; const int &b = a; // 通过变量进行初始化； const int &c = 12; // 通过值进行初始化； // int &d = 13; //error, 非const引用不能使用字面量进行初始化； } 指针与引用 引用 指针 必须初始化 可以不初始化 不能为空（NULL） 可以为空（NULL） 不能更换目标 可以更换目标 引用与指针的性能基本一致； 引用不能为NULL，但指针可以为NULL，所以指针使用前必须检查是否为NULL，指针不用； OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 17:11:10 "},"basic/chap1/引用与取址的区分.html":{"url":"basic/chap1/引用与取址的区分.html","title":"引用与取址的区别","keywords":"","body":"引用和取址的区别 引用在赋值=的左边，而取地址在赋值的右边，比如 int a=3； int &b=a； //引用 int *p=&a; //取地址 和类（或函数定义处）在一起的是引用， 和变量在一起的是取址。 举例同样如上，还有下例： int function(int &i) { } //和类型在一起的是引用 对于vector，上面2条同样适合 vector vec1(10,1); //initialize vec1: 10 elements, every element's value is 1 vector &vec2 = vec1; // vec2 is reference to vec1 vector *vec3 = &vec2; //vec3 is addresss of vec1 and vec2 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 02:20:03 "},"basic/chap1/指针和引用的区别.html":{"url":"basic/chap1/指针和引用的区别.html","title":"指针与引用的区别","keywords":"","body":"指针和引用的区别 指针和引用的区别： 首先，引用不可以为空，但指针可以为空。前面也说过了引用是对象的别名，引用为空——对象都不存在，怎么可能有别名！故定义一个引用的时候，必须初始化。因此如果你有一个变量是用于指向另一个对象，但是它可能为空，这时你应该使用指针；如果变量总是指向一个对象，i.e.，你的设计不允许变量为空，这时你应该使用引用。而声明指针是可以不指向任何对象，也正是因为这个原因，使用指针之前必须做判空操作，而引用就不必。 其次，引用不可以改变指向，对一个对象\"至死不渝\"；但是指针可以改变指向，而指向其它对象。说明：虽然引用不可以改变指向，但是可以改变初始化对象的内容。例如就++操作而言，对引用的操作直接反应到所指向的对象，而不是改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容。 再次，引用的大小是所指向的变量的大小，因为引用只是一个别名而已；指针是指针本身的大小，4个字节 最后，引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。const 指针虽然不能改变指向，但仍然存在空指针，并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针） 总之，一句话归纳为：指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名，引用不改变指向。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-27 17:18:29 "},"basic/chap1/命名空间.html":{"url":"basic/chap1/命名空间.html","title":"命名空间","keywords":"","body":"命名空间 命名空间的概述 在c++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等。工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namespace（命名空间/名字空间/名称空间），可以更好地控制标识符的作用域。 命名空间的定义 //定义一个名字为A的命名空间（变量、函数） namespace A { int a = 100; } namespace B { int a = 200; } void test02() { //A::a a是属于A中 cout 命名空间只能全局范围内定义 命名空间可以嵌套 namespace A { int a = 1000; namespace B { int a = 2000; } } void test03() { cout命名空间是开放的，即可以随时把新的成员加入已有的命名空间中(常用) namespace A { int a = 100; int b = 200; } //将c添加到已有的命名空间A中 namespace A { int c = 300; } void test04() { cout命名空间 可以存放 变量 和 函数 namespace A { int a=100;//变量 void func()//函数 { cout命名空间中的函数 可以在“命名空间”外 定义 namespace A { int a=100;//变量 void func(); } void A::func()//成员函数 在外部定义的时候 记得加作用域 { //访问命名空间的数据不用加作用域 cout无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接（了解） namespace{ int a = 10; void func(){ cout给命名空间 取个别名（了解） namespace veryLongName{ int a = 10; void func(){ cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 03:49:11 "},"basic/chap1/new和delete.html":{"url":"basic/chap1/new和delete.html","title":"new和delete","keywords":"","body":"new和delete new作用类似malloc delete作用类似free malloc/free 和 new/delete的区别 malloc和free是函数，new和delete是操作符 malloc申请的空间不会初始化，new可以初始化 malloc申请空间时需要手动计算空间大小并传递，new不需要 malloc的返回值为void*，使用时必须强转来接收，new不需要 malloc申请失败时返回NULL，new申请失败会抛异常 申请自定义类型的对象时，malloc/free不会调用构造函数和析构函数，而new会申请空间后调用构造函数，delete会调用析构函数后再释放空间 new 1、类型指针 指针变量名 = new 类型 2、类型指针 指针变量名 = new 类型(初始值) 3、类型指针 指针变量名 = new 类型[元素个数] delete 1、delete 指针变量名 2、delete[] 指针变量名 new去申请对象会先申请对象的空间并调用对象的构造函数完成对象的初始化；delete会先去完成对象的资源清理，再将对象所占的空间释放掉。 但是要注意，如果没有默认构造函数，我们必须在new一个对象时后面要加小括号给予初始值进行初始化。没有默认构造函数，我们也不能申请连续的多个空间。 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 11:23:30 "},"basic/chap1/cin和cout.html":{"url":"basic/chap1/cin和cout.html","title":"cin和cout","keywords":"","body":"cin和cout cin类似scanf cout类似printf OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 11:21:49 "},"basic/chap2/summary_02.html":{"url":"basic/chap2/summary_02.html","title":"面向对象的思想","keywords":"","body":"Part 2 面向对象的思想 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 14:43:04 "},"basic/chap2/面向过程与面向对象.html":{"url":"basic/chap2/面向过程与面向对象.html","title":"面向过程与面向对象","keywords":"","body":"面向过程与面向对象 面向过程 提出问题 --- 分析问题 --- 处理问题 大问题 --- 小问题 面向对象 面向对象的程序设计 是面向过程的继承和发展 可理解为： 现实世界是由对象组成的 对象在程序中抽象为两部分：属性【数据】、行为【函数】 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 14:59:34 "},"basic/chap2/类与对象.html":{"url":"basic/chap2/类与对象.html","title":"类与对象","keywords":"","body":"类与对象 类是一种用户自定义的数据类型（函数、数据） 类是 具有相同属性 和行为的 对象 的集合 类是对象的抽象， 对象是类的具体 对象： 通过使用类 类型定义的变量 定义类 class 类名 { // 默认是私有的 // 成员： 1数据 2函数 private: // 私有 ，在类的内部访问 public: // 公有 ， 在类的内部和外部都能访问 protected: // 被保护 ，在类的内部访问，在类的子类能访问 }; 定义对象 类名 对象名; 类名 指针名; C++中class 与 struct 可以用class定义类， 也可以用struct定义类(一般不建议用)，struct还可以定义结构体 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 15:20:53 "},"basic/chap3/summary_03.html":{"url":"basic/chap3/summary_03.html","title":"构造函数与析构函数","keywords":"","body":"Part 3 构造函数与析构函数 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 15:19:09 "},"basic/chap3/构造函数.html":{"url":"basic/chap3/构造函数.html","title":"构造函数","keywords":"","body":"构造函数 普通构造函数 是一个特殊的成员函数 主要用户来在创建对象的时候，初始化对象 为对象的成员变量 赋 初始值 构造函数 和 类名相同 构造函数没有返回值类型， 也没有返回值 构造函数可以重载，需满足函数重载的条件 在创建一个新的对象是，会自动调用构造函数 如果一个类中没有显式的给出构造函数， 系统会自动生成一个构造函数 有时数据成员必须初始化，但又不能在构造函数中赋值 可以使用 成员初始化列表 的方式给数据成员赋值 const ，修饰变量时，使其改变性质变成常量 class test { private: /* data */ int value; public: test(/* args */); ~test(); const int id = 0; // id变成常量 const int td = 0; // id变成常量 test(int v, int n); void set_value(int v); // 设置私有变量 int get_value(); // 获取私有变量 int num; }; test::test(/* args */) { } test::test(int v, int n) : id(v), td(n) // 使用成员函数列表给 成员赋值 { num = n; value = v; } test::~test() { } void test::set_value(int v) { } int test::get_value() { } int main() { test _t; // 创造对象时候，自动调用构造函数test() test _t1(1, 2); // 创建对象时候，自动调用构造函数 test(int v, int n) test *p = new test; // 无参构造test类型的指针 test *p1 = new test(1, 2); // 有参构造test类型的指针 return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 15:54:30 "},"basic/chap3/析构函数.html":{"url":"basic/chap3/析构函数.html","title":"析构函数","keywords":"","body":"析构函数 是一种特殊的函数 对象生命周期结束的时候，进行清理的函数 系统可以自动调用析构函数-- 在对象生命周期结束时， 会自动调用析构函数 不是因为调用析构而结束生命周期， 而是因为生命周期结束而调用析构 函数名与类名相同， 在前面加一个 ~ 没有返回值类型和返回值， 也没有参数 没有写，则系统会自动生成 析构函数可以主动通过 对象调用 析构函数必须是公有属性下 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-28 16:12:55 "},"basic/chap3/拷贝构造函数.html":{"url":"basic/chap3/拷贝构造函数.html","title":"拷贝构造函数","keywords":"","body":"拷贝构造函数 一种特殊的构造函数 通过拷贝构造函数完成一个复制的过程 特殊： 第一个参数是本类 的 对象 的引用 先是构造函数，才可能是拷贝构造函数 没写，但系统会生成， 将成员意义对应赋值 可以自定义 先构造出来的后析构 调用的时机 使用一个对象 给 另一个对象进行初始化 使用 一个对象 构造另一个对象 函数的参数是 类的对象 函数的返回值是 类的对象 浅拷贝 与 深拷贝 浅拷贝： 默认都是前拷贝， 属于无脑抄袭 深拷贝： 需根据自己实际情况实现， 属于改抄的地方抄， 不改抄的地方要修修改改 如何防止默认拷贝的发生？ 声明一个私有的拷贝构造函数，但不对其进行定义【防止低保，且不实现， 主动让程序报错，有备而来】 #include class testcpoy { private: /* data */ public: int m_age; int m_weight; float m_spped; int *p; public: testcpoy(/* args */); ~testcpoy(); testcpoy(int age, int weight, float spped); testcpoy(testcpoy &obj); // 拷贝构造函数，第一个参数是 本类型的对象的 引用 testcpoy(testcpoy &obj, int i); // 拷贝构造函数，第一个参数是 本类型的对象的 引用 testcpoy(testcpoy &obj, int i, int j); // 拷贝构造函数，都一个参数是 本类型的对象的 引用 }; testcpoy::testcpoy(/* args */) { // 无参数构造 p = NULL; } testcpoy::~testcpoy() { // 析构 } testcpoy::testcpoy(int age, int weight, float spped) { // 有参数构造 p = new int[10]; } testcpoy::testcpoy(testcpoy &obj) { // 拷贝构造 p = new int(10); for (size_t i = 0; i OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 03:02:15 "},"basic/chap4/summary_04.html":{"url":"basic/chap4/summary_04.html","title":"特殊情况","keywords":"","body":"Part 3 特殊情况 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 08:04:49 "},"basic/chap4/this指针.html":{"url":"basic/chap4/this指针.html","title":"this指针","keywords":"","body":"this指针 系统自动生成， 且是隐藏的，但可以使用 this指针， 不是对象的一部分， 作用域在类内部 类的普通函数 访问类的普通成员时， this指针总是指向 调用者对象 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 03:11:25 "},"basic/chap4/static成员.html":{"url":"basic/chap4/static成员.html","title":"static成员","keywords":"","body":"static成员 声明成员时，加上static关键字 静态成员分为：静态数据成员 + 静态函数成员 静态数据成员： 所有该类生成的对象， 都共用这些静态数据成员 静态成员函数： 函数里不能访问 类 内 的 普通成员， 且没有this指针 class test { private: /* data */ public: test(/* args */); ~test(); static int num; // 静态数据成员 ，不能在构造函数中初始化， 也不能在成员参数初始化列表 初始化 static void fun_1(); // 静态成员函数 }; int test::num = 0; // 可以这样初始化 test::test(/* args */) { } test::~test() { } void test::fun_1() { } int main() { int a = test::num; // 属于类，可以用类名调用 test::fun_1(); // 属于类，可以用类名调用 return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 03:57:31 "},"basic/chap4/单例模式.html":{"url":"basic/chap4/单例模式.html","title":"单例模式","keywords":"","body":"单例模式 一种设计模式， 创建一个 只能 实例化一个对象的类 通过对构造函数进行限制 设置为私有 #include class testSingleInstance { private: /* data */ testSingleInstance(/* args */); testSingleInstance(const testSingleInstance &obj); static testSingleInstance *p_instance; public: ~testSingleInstance(); static testSingleInstance *getInstance(); }; testSingleInstance *testSingleInstance::p_instance = NULL; testSingleInstance::testSingleInstance(/* args */) { } testSingleInstance::testSingleInstance(const testSingleInstance &obj) { } testSingleInstance::~testSingleInstance() { } testSingleInstance *testSingleInstance::getInstance() { if (p_instance == NULL) { p_instance = new testSingleInstance; } return p_instance; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 04:05:56 "},"basic/chap4/const成员.html":{"url":"basic/chap4/const成员.html","title":"const成员","keywords":"","body":"const成员 在声明成员时 加上const 关键字 常量成员分为： 常量数据成员 和 常量成员函数 常量数据成员： 常量成员函数： 不能修改类的任何普通数据成员 ，但可以修改 静态数据成员 常量对象： 常对象的普通数据成员都不能修改,但可以修改 静态数据成员 常对象 只能调用 静态成员函数， 不能调用普通成员函数 class testConst { private: /* data */ public: testConst(/* args */); testConst(int v); ~testConst(); int num; const int val; // 常量数据成员 ，使用成员初始化列表 void func_1(); void func_2() const; // 常量成员函数 }; testConst::testConst(/* args */) : val(10) // 使用成员初始化列表给值 { } testConst::testConst(int v) : val(v) // 使用成员初始化列表给值 { } testConst::~testConst() { } void testConst::func_1() { } void testConst::func_2() const // 类的外面 实现 常量成员函数时， const 是属于函数的一部分名不能省略 { } int main() { return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 05:21:21 "},"basic/chap4/友元关系.html":{"url":"basic/chap4/友元关系.html","title":"友元关系","keywords":"","body":"友元关系 类的特性之一是封装， 友元是打破封装的 手段 友元分为：友元函数、友元类, 【友元是单方向的，且不存在传递关系，且不继承】 友元函数： 友元类 ：可以创建友元对象 class testfriend { private: /* data */ friend void test_friend_1(testfriend obj); // testfriend 把test_friend_1 函数当作朋友， 友元函数, 把test_friend_1 函数就可以调用testfriend类的私有数据 friend class B; // testfriend B 类当作朋友， 友元类, 则B类 就可以调用testfriend类的私有数据 public: testfriend(/* args */); ~testfriend(); }; testfriend::testfriend(/* args */) { } testfriend::~testfriend() { } void test_friend_1(testfriend obj) { } class B { public: void test(testfriend obj); }; void B::test(testfriend obj){ } int main() { return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 08:02:06 "},"basic/chap5/summary_05.html":{"url":"basic/chap5/summary_05.html","title":"继承与派生","keywords":"","body":"Part 5 继承与派生 不影响到原来的类， 不该原来类的代码， 实现对功能的扩展 在原有类的基础上快递增加新的功能 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 09:10:54 "},"basic/chap5/继承和派生介绍.html":{"url":"basic/chap5/继承和派生介绍.html","title":"继承和派生介绍","keywords":"","body":"继承和派生 继承概念： 基于已有的类，创建新类的方式。【可以继承自一个，或 多个类】 A ====> B A：父类【基类】：原来的类， B：子类【派生类】：新创建的类 描述的是 类与类之间的关系 继承和派生： 实际是同一个过程，在不同角度的称呼 子类视角： 继承 ”自父亲“ 父类视角： 派生 “给孩子” 继承种类： 单继承：一个父类 多继承：多个父类 继承： 继承是 子类继承 父类的全部成员 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 08:20:54 "},"basic/chap5/继承方式.html":{"url":"basic/chap5/继承方式.html","title":"继承方式","keywords":"","body":"继承方式 单继承 /** * 单继承 * */ // 父类 class A { }; // 子类 // class 子类名称 : 继承权限 父类名 class B : public A { }; 多继承 /** * 多继承 * */ // 父类 class AA { }; class BB { }; // 子类 // class 子类名称 : 继承权限 父类名1, 继承权限 父类名2, ... ,继承权限 父类名N // 继承权限： // 公有继承 public // 私有继承 private // 保护继承 protected class CC : public AA, public BB { }; 继承权限 ||公有继承 public|私有继承 private|保护继承 protected| |public|public|privtae|protected| |private|不可访问|不可访问|不可访问| |protected|protected|private|protected| 多级继承（A -> B ->C） 继承权限，只需要关注最近的 父类结果， 直接分析最近父子类 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 08:28:28 "},"basic/chap5/父子关系.html":{"url":"basic/chap5/父子关系.html","title":"父子关系","keywords":"","body":"父子关系 派生类的构成 构造和析构不从父类继承，其他的都会继承 父类对象 不能给 子类对象赋值， 但 子类对象 可以给父类对象赋值 父类指针 可以指向 子类对象 ， 但 子类指针 不能 指向父类对象 派生类的构造析构顺序 子类如果要调用父类的带参构造，可以放在成员初始化列表中 父类先构造，之后子类构造 先构造的后析构 #include class A { public: A(); ~A(); int val; int num; }; A::A() { num = 10; } A::~A() { } class B : public A { public: B(); ~B(); int num; }; B::B() { num = 20; } B::~B() { } int main() { B b; std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 08:59:52 "},"basic/chap5/菱形继承.html":{"url":"basic/chap5/菱形继承.html","title":"菱形继承","keywords":"","body":"菱形继承 A ->A1 ; A -> A2; A1,A2 ->AA 同时从A 继承出来的 数据成员，怎么访问 方法一： 通过类名:: 成员名 方法二： 虚继承， class A1 : virtual public A ; class A2 : virtual public A ; 如果A1、A2有重复继承则最终只保留一份A的数据成员 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 09:09:13 "},"basic/chap6/summary_06.html":{"url":"basic/chap6/summary_06.html","title":"多态","keywords":"","body":"Part 6 多态 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:40:50 "},"basic/chap6/联编.html":{"url":"basic/chap6/联编.html","title":"联编","keywords":"","body":"联编 联编：就是将模块或者函数合并在一起生成可执行代码的处理过程，同时对每个模块或者函数调用分配内存地址，并且对外部访问也分配正确的内存地址，它是计算机程序彼此关联的过程。 按照联编所进行的阶段不同，可分为两种不同的联编方法：静态联编和动态联编。 静态联编：指在编译阶段就将函数实现和函数调用关联起来，因此静态联编也叫早绑定， 在编译阶段就必须了解所有的函数或模块执行所需要检测的信息，它对函数的选择是基于指向对象的指针（或者引用）的类型 C语言中，所有的联编都是静态联编,并且任何一种编译器都支持静态联编。 动态联编：指在程序执行的时候才将函数实现和函数调用关联，因此也叫运行时绑定或者晚绑定， 动态联编对函数的选择不是基于指针或者引用，而是基于对象类型，不同的对象类型将做出不同的编译结果 C++中一般情况下联编也是静态联编，但是一旦涉及到多态和虚拟函数就必须要使用动态联编了 实现动态联编的条件 在一个类里，且需要有虚函数， 且该类为父类，且被继承 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 12:39:08 "},"basic/chap6/多态.html":{"url":"basic/chap6/多态.html","title":"多态","keywords":"","body":"多态 多态的概念 意味着调用成员函数时，会根据 调用函数的 对象[主体]的类型 来执行不同的函数。 【主体】->调用函数 子类不会继承父类的 虚函数表 通过类的继承和虚函数，实现多态 虚函数成员的父类 同名函数成员的子类 指针： 父类类型的指针，指向父类 或 子类对象 #include class Fa { private: /* data */ public: Fa(/* args */); virtual ~Fa(); // 父类 虚析构 virtual void test_func(); // 声明虚函数 }; Fa::Fa(/* args */) { } Fa::~Fa() { } void Fa::test_func() { std::cout test_func(); // 根据指针 指向的类型，进行调用对应的函数，动态联编 p = &son; p->test_func(); p = &son1; p->test_func(); delete p; p = NULL; return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 12:39:06 "},"basic/chap6/纯虚函数.html":{"url":"basic/chap6/纯虚函数.html","title":"纯虚函数","keywords":"","body":"纯虚函数 纯虚函数：没有函数体的虚函数 virtual 函数类型 函数名() = 0; 纯虚函数， 当前类不做实现， 由他的子类去实现 只要包含纯虚函数的类，被称为 抽象类 不允许用来 定义对象， 但可以用来定义指针 class testvirtual { private: /* data */ public: testvirtual(/* args */); virtual ~testvirtual(); virtual void test_func() = 0; // 纯虚函数， 当前类不做实现， 由他的子类去实现 }; testvirtual::testvirtual(/* args */) { } testvirtual::~testvirtual() { } class son : public testvirtual { private: /* data */ public: son(/* args */); ~son(); void test_func(); }; son::son(/* args */) { } son::~son() { } void son::test_func() { } int main() { testvirtual *p; son son1; p = &son1; p->test_func(); return 0; } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 12:49:01 "},"basic/chap6/final.html":{"url":"basic/chap6/final.html","title":"final","keywords":"","body":"final 权限掠夺者 掠夺函数权限：阻止重写 掠夺类的权限：阻止派生 class testfinal { private: /* data */ public: testfinal(/* args */); ~testfinal(); virtual void test() ; }; testfinal::testfinal(/* args */) { } testfinal::~testfinal() { } class son : public testfinal { private: /* data */ public: son(/* args */); ~son(); void test() final; }; son::son(/* args */) { } son::~son() { } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:01:24 "},"basic/chap7/summary_07.html":{"url":"basic/chap7/summary_07.html","title":"运算符重载","keywords":"","body":"Part 7 运算符重载 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:02:48 "},"basic/chap7/基础语法.html":{"url":"basic/chap7/基础语法.html","title":"基础语法","keywords":"","body":"基础语法 重载的概念 在同一作用域中的某个函数和运算符指定多个定义，分别称为【函数重载】和【运算符重载】。 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。 当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策 重载函数 在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。 #include using namespace std; class printData { public: void print(int i) { cout 重载运算符 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 #include using namespace std; class Box { public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box& b) { Box box; box.length = this->length + b.length; box.breadth = this->breadth + b.breadth; box.height = this->height + b.height; return box; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; // 程序的主函数 int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:21:18 "},"basic/chap7/规则详解.html":{"url":"basic/chap7/规则详解.html","title":"规则详解","keywords":"","body":"规则详解 一个类两个对象之间成员进行运算必须重新定义，让编译器在遇到对象运算时能按我们要求的进行运算，这就是运算符重载的意义，即重定义运算符，【运算符重载就是为类对象服务的】 可重载运算符 和不可能重载运算符 运算符重载函数， 不能有默认的参数 运算符重载函数 可以做为类的 成员函数， 可以作为全局函数 下面是可重载的运算符列表 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)， (大于)，=(大于等于) 逻辑运算符 ||(逻辑或)，&&(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&(取地址) 自增自减运算符 ++(自增)，--(自减) 位运算符 | (按位或)，& (按位与)，~(按位取反)，^(按位异或),，>(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &=, |=, ^=, >= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，->(成员访问)，,(逗号)，[](下标) 下面是不可重载的运算符列表： . ：成员访问运算符 .*, ->* ：成员指针访问运算符 :: ：域运算符 sizeof ：长度运算符 ?: ：条件运算符 # ： 预处理符号 箭头运算符 -> 下标运算符[] 赋值运算符= 函数调用运算符() ; 只能以成员函数的形式重载 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:28:29 "},"basic/chap7/重载<< 与 >>.html":{"url":"basic/chap7/重载<< 与 >>.html","title":"重载<<与>>","keywords":"","body":"重载> 重载输出和输入 作为友元函数重载 istream :输入 ostream :输出 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 13:38:54 "},"basic/chap8/summary_08.html":{"url":"basic/chap8/summary_08.html","title":"模板","keywords":"","body":"Part 8 模版 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 10:51:20 "},"basic/chap8/函数模板.html":{"url":"basic/chap8/函数模板.html","title":"函数模板","keywords":"","body":"函数模板 通过函数模板 定义模板函数 /** * 通过函数模板 定义模板函数 * template * 返回值类型 函数名(形参列表){ * 函数体 * } */ 函数模板 与 普通函数对比 都可以重载 如果两个同名函数且同参数个数（模板 与普通）同时存在， 会先先访问普通函数 OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-29 14:47:28 "},"basic/chap8/类模板.html":{"url":"basic/chap8/类模板.html","title":"类模板","keywords":"","body":"类模板 类模板形式 /** * template * class 模板类名{ * 成员 * } * * 类型参数列表: * **/ 类模板当做函数参数 template // 将类型当作模板 template // 直接将类作为模板 template // 将类型当作模板 void test_func1(testclassTemplate &obj) { obj.showData(); } template // 直接将类作为模板 void test_func2(TTT1 &obj) { obj.showData(); } testclassTemplate data1(1, 2); data1.showData(); testclassTemplate data2('qwe', 21); data2.showData(); test_func(data1); test_func1(data1); test_func2>(data2); 模板类的继承 ``` /** 模板类的继承 */ template class Father { public: F_type num; }; template class Son : public Father { public: S_type1 val; }; include /** template class 模板类名{ 成员 } * 类型参数列表: */ template class testclassTemplate { private: / data / T1 name; T2 age; public: testclassTemplate(T1 i, T2 j) : name(i), age(j){}; ~testclassTemplate(); // get /set T1 getName() { return name; } T2 getAge() { return age; } void setName(T1 i) { name = i; } void setAge(T2 j) { age = j; } void showData(); }; template void testclassTemplate::showData() { std::cout testclassTemplate::~testclassTemplate() { } void test_func(testclassTemplate &obj) { obj.showData(); } template // 将类型当作模板 void test_func1(testclassTemplate &obj) { obj.showData(); } template // 直接将类作为模板 void test_func2(TTT1 &obj) { obj.showData(); } int main() { testclassTemplate data1(1, 2); data1.showData(); testclassTemplate data2('qwe', 21); data2.showData(); test_func(data1); test_func1(data1); test_func2>(data2); return 0; } ``` OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 07:46:22 "},"basic/chap8/模板和友元.html":{"url":"basic/chap8/模板和友元.html","title":"模板和友元","keywords":"","body":"模板和友元 #include template class A { private: /* data */ T m_a; friend void show(A &obj) { } // 模板类的友元函数 public: A(T t = 0) : m_a(t) {} ~A() {} }; template int main() { A obja; show(obja); } OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 07:57:30 "},"basic/chap9/summary_09.html":{"url":"basic/chap9/summary_09.html","title":"补充知识点","keywords":"","body":"Part 9 补充知识点 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 07:59:06 "},"basic/chap9/异常处理机制.html":{"url":"basic/chap9/异常处理机制.html","title":"异常处理机制","keywords":"","body":"异常处理机制 异常:程序执行过程中出现的问题 C++中的异常处理 方法 throw : 抛出异常 try : 尝试 catch : 处理异常try{ // code 直接或间接 throw 抛出异常 // code } catch(接收异常){ 处理异常 } 使用自定义异常 #include #include double test_func(double a, double b) { if (b == 0.0) { // throw 抛出异常 // 抛出异常信息：支持多种类型 throw \"这里有异常！b不能为0！！！\"; // 触发throw则会中断 test_func程序，后面的就不会再执行 } return a / b; } // 自定义异常类 class CustomException : public exception { public: const char *what() const; }; const char *CustomException::what() const { return \"自定义的异常\"; } int main() { std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 10:04:51 "},"basic/chap9/文件流.html":{"url":"basic/chap9/文件流.html","title":"文件流","keywords":"","body":"文件流 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 fstream :常用的文件操作类 文件的打开方式 void open(const char *filename, ios::openmode mode); 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 【将文件输入到程序】 ios::out 打开文件用于写入。【将文件从程序输出出去】 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 #include #include int main() { fstream obj; obj.open(\"test1.txt\", ios::out); // 打开文件，(文件路径，打开方式) obj.put('s12ad'); // 写入 obj.close(); obj.open(\"test1.txt\", ios::in); // 打开文件，(文件路径，打开方式) char outt; outt = obj.get(); // 读取 // obj.get(outt); // 读取 std::cout >读写文件 obj.open(\"test3.txt\", ios::out); // 打开文件，(文件路径，打开方式) obj > val; // 读取 std::cout OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 10:31:04 "},"basic/chap9/C++11标准.html":{"url":"basic/chap9/C++11标准.html","title":"C++11标准","keywords":"","body":"C++11标准 初始化的方式 新的写法不允许丢失精确度 int a = 0; int b(2.1); int m{4}; int n = {(int)3.14}; 指针置空 int *p = NULL; int *p = nullptr; 自动类型 int a=0; auto a=0; // 根据值匹配类型 decltype() 复制类型 int a=0; decltype(a)b; // 根据a的类型， 定义一个和a类型一致的b变量 decltype((a))m =a ; // 给a取别名 for规则 // 该方法 只能用来遍历 数组 等容器类型的数据 for(auto item:items){ std::cout 给类型取别名 typedef int INT; // 给int 取别名 INT typedef void(*pFun) PPFUN; using Int =int; // 给int 取别名 Int using PFUN = void(*pFun); default 在类中的用法 class CA{ public: CA(); } CA::CA() = default; // 默认调用默认构造 final OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 10:48:01 "},"game/summary.html":{"url":"game/summary.html","title":"游戏开发","keywords":"","body":"游戏开发 关于作者 👋 读书城南，🤔 在未来面前，我们都是孩子～ 📙 一个热衷于探索学习新方向、新事物的智能产品经理，闲暇时间喜欢coding💻、画图🎨、音乐🎵、学习ing~ 👋 Social Media 🛠️ Blog: http://oceaneyes.top 🛠️ OceanNote,一个好用的md工具: https://note.oceangzy.top ⚡ PM导航，一个好用的导航栏: https://pmhub.oceangzy.top ☘️ CNBLOG: https://www.cnblogs.com/oceaneyes-gzy/ 🌱 AI PRJ自己部署的一些算法demo: http://ai.oceangzy.top/ 📫 Email: 1450136519@qq.com 💬 WeChat: OCEANGZY 💬 公众号: UncleJoker-GZY 👋 加入小组~ 👋 感谢打赏~ OceanGZY © 2019-2022 all right reserved，powered by Gitbook文件修订时间： 2023-07-30 11:28:44 "}}